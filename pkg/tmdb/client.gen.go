// Package tmdb provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.3.0 DO NOT EDIT.
package tmdb

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	Sec0Scopes = "sec0.Scopes"
)

// Defines values for AccountGetFavoritesParamsSortBy.
const (
	AccountGetFavoritesParamsSortByCreatedAtAsc  AccountGetFavoritesParamsSortBy = "created_at.asc"
	AccountGetFavoritesParamsSortByCreatedAtDesc AccountGetFavoritesParamsSortBy = "created_at.desc"
)

// Defines values for AccountFavoriteTvParamsSortBy.
const (
	AccountFavoriteTvParamsSortByCreatedAtAsc  AccountFavoriteTvParamsSortBy = "created_at.asc"
	AccountFavoriteTvParamsSortByCreatedAtDesc AccountFavoriteTvParamsSortBy = "created_at.desc"
)

// Defines values for AccountRatedMoviesParamsSortBy.
const (
	AccountRatedMoviesParamsSortByCreatedAtAsc  AccountRatedMoviesParamsSortBy = "created_at.asc"
	AccountRatedMoviesParamsSortByCreatedAtDesc AccountRatedMoviesParamsSortBy = "created_at.desc"
)

// Defines values for AccountRatedTvParamsSortBy.
const (
	AccountRatedTvParamsSortByCreatedAtAsc  AccountRatedTvParamsSortBy = "created_at.asc"
	AccountRatedTvParamsSortByCreatedAtDesc AccountRatedTvParamsSortBy = "created_at.desc"
)

// Defines values for AccountRatedTvEpisodesParamsSortBy.
const (
	AccountRatedTvEpisodesParamsSortByCreatedAtAsc  AccountRatedTvEpisodesParamsSortBy = "created_at.asc"
	AccountRatedTvEpisodesParamsSortByCreatedAtDesc AccountRatedTvEpisodesParamsSortBy = "created_at.desc"
)

// Defines values for AccountWatchlistMoviesParamsSortBy.
const (
	AccountWatchlistMoviesParamsSortByCreatedAtAsc  AccountWatchlistMoviesParamsSortBy = "created_at.asc"
	AccountWatchlistMoviesParamsSortByCreatedAtDesc AccountWatchlistMoviesParamsSortBy = "created_at.desc"
)

// Defines values for AccountWatchlistTvParamsSortBy.
const (
	AccountWatchlistTvParamsSortByCreatedAtAsc  AccountWatchlistTvParamsSortBy = "created_at.asc"
	AccountWatchlistTvParamsSortByCreatedAtDesc AccountWatchlistTvParamsSortBy = "created_at.desc"
)

// Defines values for DiscoverMovieParamsSortBy.
const (
	DiscoverMovieParamsSortByOriginalTitleAsc       DiscoverMovieParamsSortBy = "original_title.asc"
	DiscoverMovieParamsSortByOriginalTitleDesc      DiscoverMovieParamsSortBy = "original_title.desc"
	DiscoverMovieParamsSortByPopularityAsc          DiscoverMovieParamsSortBy = "popularity.asc"
	DiscoverMovieParamsSortByPopularityDesc         DiscoverMovieParamsSortBy = "popularity.desc"
	DiscoverMovieParamsSortByPrimaryReleaseDateAsc  DiscoverMovieParamsSortBy = "primary_release_date.asc"
	DiscoverMovieParamsSortByPrimaryReleaseDateDesc DiscoverMovieParamsSortBy = "primary_release_date.desc"
	DiscoverMovieParamsSortByRevenueAsc             DiscoverMovieParamsSortBy = "revenue.asc"
	DiscoverMovieParamsSortByRevenueDesc            DiscoverMovieParamsSortBy = "revenue.desc"
	DiscoverMovieParamsSortByTitleAsc               DiscoverMovieParamsSortBy = "title.asc"
	DiscoverMovieParamsSortByTitleDesc              DiscoverMovieParamsSortBy = "title.desc"
	DiscoverMovieParamsSortByVoteAverageAsc         DiscoverMovieParamsSortBy = "vote_average.asc"
	DiscoverMovieParamsSortByVoteAverageDesc        DiscoverMovieParamsSortBy = "vote_average.desc"
	DiscoverMovieParamsSortByVoteCountAsc           DiscoverMovieParamsSortBy = "vote_count.asc"
	DiscoverMovieParamsSortByVoteCountDesc          DiscoverMovieParamsSortBy = "vote_count.desc"
)

// Defines values for DiscoverTvParamsSortBy.
const (
	DiscoverTvParamsSortByFirstAirDateAsc  DiscoverTvParamsSortBy = "first_air_date.asc"
	DiscoverTvParamsSortByFirstAirDateDesc DiscoverTvParamsSortBy = "first_air_date.desc"
	DiscoverTvParamsSortByNameAsc          DiscoverTvParamsSortBy = "name.asc"
	DiscoverTvParamsSortByNameDesc         DiscoverTvParamsSortBy = "name.desc"
	DiscoverTvParamsSortByOriginalNameAsc  DiscoverTvParamsSortBy = "original_name.asc"
	DiscoverTvParamsSortByOriginalNameDesc DiscoverTvParamsSortBy = "original_name.desc"
	DiscoverTvParamsSortByPopularityAsc    DiscoverTvParamsSortBy = "popularity.asc"
	DiscoverTvParamsSortByPopularityDesc   DiscoverTvParamsSortBy = "popularity.desc"
	DiscoverTvParamsSortByVoteAverageAsc   DiscoverTvParamsSortBy = "vote_average.asc"
	DiscoverTvParamsSortByVoteAverageDesc  DiscoverTvParamsSortBy = "vote_average.desc"
	DiscoverTvParamsSortByVoteCountAsc     DiscoverTvParamsSortBy = "vote_count.asc"
	DiscoverTvParamsSortByVoteCountDesc    DiscoverTvParamsSortBy = "vote_count.desc"
)

// Defines values for FindByIDParamsExternalSource.
const (
	Empty       FindByIDParamsExternalSource = ""
	FacebookID  FindByIDParamsExternalSource = "facebook_id"
	ImdbID      FindByIDParamsExternalSource = "imdb_id"
	InstagramID FindByIDParamsExternalSource = "instagram_id"
	TiktokID    FindByIDParamsExternalSource = "tiktok_id"
	TvdbID      FindByIDParamsExternalSource = "tvdb_id"
	TwitterID   FindByIDParamsExternalSource = "twitter_id"
	WikidataID  FindByIDParamsExternalSource = "wikidata_id"
	YoutubeID   FindByIDParamsExternalSource = "youtube_id"
)

// Defines values for GuestSessionRatedMoviesParamsSortBy.
const (
	GuestSessionRatedMoviesParamsSortByCreatedAtAsc  GuestSessionRatedMoviesParamsSortBy = "created_at.asc"
	GuestSessionRatedMoviesParamsSortByCreatedAtDesc GuestSessionRatedMoviesParamsSortBy = "created_at.desc"
)

// Defines values for GuestSessionRatedTvParamsSortBy.
const (
	GuestSessionRatedTvParamsSortByCreatedAtAsc  GuestSessionRatedTvParamsSortBy = "created_at.asc"
	GuestSessionRatedTvParamsSortByCreatedAtDesc GuestSessionRatedTvParamsSortBy = "created_at.desc"
)

// Defines values for GuestSessionRatedTvEpisodesParamsSortBy.
const (
	GuestSessionRatedTvEpisodesParamsSortByCreatedAtAsc  GuestSessionRatedTvEpisodesParamsSortBy = "created_at.asc"
	GuestSessionRatedTvEpisodesParamsSortByCreatedAtDesc GuestSessionRatedTvEpisodesParamsSortBy = "created_at.desc"
)

// Defines values for TrendingAllParamsTimeWindow.
const (
	TrendingAllParamsTimeWindowDay  TrendingAllParamsTimeWindow = "day"
	TrendingAllParamsTimeWindowWeek TrendingAllParamsTimeWindow = "week"
)

// Defines values for TrendingMoviesParamsTimeWindow.
const (
	TrendingMoviesParamsTimeWindowDay  TrendingMoviesParamsTimeWindow = "day"
	TrendingMoviesParamsTimeWindowWeek TrendingMoviesParamsTimeWindow = "week"
)

// Defines values for TrendingPeopleParamsTimeWindow.
const (
	TrendingPeopleParamsTimeWindowDay  TrendingPeopleParamsTimeWindow = "day"
	TrendingPeopleParamsTimeWindowWeek TrendingPeopleParamsTimeWindow = "week"
)

// Defines values for TrendingTvParamsTimeWindow.
const (
	TrendingTvParamsTimeWindowDay  TrendingTvParamsTimeWindow = "day"
	TrendingTvParamsTimeWindowWeek TrendingTvParamsTimeWindow = "week"
)

// AccountDetailsParams defines parameters for AccountDetails.
type AccountDetailsParams struct {
	SessionID *string `form:"session_id,omitempty" json:"session_id,omitempty"`
}

// AccountAddFavoriteJSONBody defines parameters for AccountAddFavorite.
type AccountAddFavoriteJSONBody struct {
	RAWBODY json.RawMessage `json:"RAW_BODY"`
}

// AccountAddFavoriteParams defines parameters for AccountAddFavorite.
type AccountAddFavoriteParams struct {
	SessionID *string `form:"session_id,omitempty" json:"session_id,omitempty"`
}

// AccountGetFavoritesParams defines parameters for AccountGetFavorites.
type AccountGetFavoritesParams struct {
	Language  *string                          `form:"language,omitempty" json:"language,omitempty"`
	Page      *int32                           `form:"page,omitempty" json:"page,omitempty"`
	SessionID *string                          `form:"session_id,omitempty" json:"session_id,omitempty"`
	SortBy    *AccountGetFavoritesParamsSortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`
}

// AccountGetFavoritesParamsSortBy defines parameters for AccountGetFavorites.
type AccountGetFavoritesParamsSortBy string

// AccountFavoriteTvParams defines parameters for AccountFavoriteTv.
type AccountFavoriteTvParams struct {
	Language  *string                        `form:"language,omitempty" json:"language,omitempty"`
	Page      *int32                         `form:"page,omitempty" json:"page,omitempty"`
	SessionID *string                        `form:"session_id,omitempty" json:"session_id,omitempty"`
	SortBy    *AccountFavoriteTvParamsSortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`
}

// AccountFavoriteTvParamsSortBy defines parameters for AccountFavoriteTv.
type AccountFavoriteTvParamsSortBy string

// AccountListsParams defines parameters for AccountLists.
type AccountListsParams struct {
	Page      *int32  `form:"page,omitempty" json:"page,omitempty"`
	SessionID *string `form:"session_id,omitempty" json:"session_id,omitempty"`
}

// AccountRatedMoviesParams defines parameters for AccountRatedMovies.
type AccountRatedMoviesParams struct {
	Language  *string                         `form:"language,omitempty" json:"language,omitempty"`
	Page      *int32                          `form:"page,omitempty" json:"page,omitempty"`
	SessionID *string                         `form:"session_id,omitempty" json:"session_id,omitempty"`
	SortBy    *AccountRatedMoviesParamsSortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`
}

// AccountRatedMoviesParamsSortBy defines parameters for AccountRatedMovies.
type AccountRatedMoviesParamsSortBy string

// AccountRatedTvParams defines parameters for AccountRatedTv.
type AccountRatedTvParams struct {
	Language  *string                     `form:"language,omitempty" json:"language,omitempty"`
	Page      *int32                      `form:"page,omitempty" json:"page,omitempty"`
	SessionID *string                     `form:"session_id,omitempty" json:"session_id,omitempty"`
	SortBy    *AccountRatedTvParamsSortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`
}

// AccountRatedTvParamsSortBy defines parameters for AccountRatedTv.
type AccountRatedTvParamsSortBy string

// AccountRatedTvEpisodesParams defines parameters for AccountRatedTvEpisodes.
type AccountRatedTvEpisodesParams struct {
	Language  *string                             `form:"language,omitempty" json:"language,omitempty"`
	Page      *int32                              `form:"page,omitempty" json:"page,omitempty"`
	SessionID *string                             `form:"session_id,omitempty" json:"session_id,omitempty"`
	SortBy    *AccountRatedTvEpisodesParamsSortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`
}

// AccountRatedTvEpisodesParamsSortBy defines parameters for AccountRatedTvEpisodes.
type AccountRatedTvEpisodesParamsSortBy string

// AccountAddToWatchlistJSONBody defines parameters for AccountAddToWatchlist.
type AccountAddToWatchlistJSONBody struct {
	RAWBODY json.RawMessage `json:"RAW_BODY"`
}

// AccountAddToWatchlistParams defines parameters for AccountAddToWatchlist.
type AccountAddToWatchlistParams struct {
	SessionID *string `form:"session_id,omitempty" json:"session_id,omitempty"`
}

// AccountWatchlistMoviesParams defines parameters for AccountWatchlistMovies.
type AccountWatchlistMoviesParams struct {
	Language  *string                             `form:"language,omitempty" json:"language,omitempty"`
	Page      *int32                              `form:"page,omitempty" json:"page,omitempty"`
	SessionID *string                             `form:"session_id,omitempty" json:"session_id,omitempty"`
	SortBy    *AccountWatchlistMoviesParamsSortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`
}

// AccountWatchlistMoviesParamsSortBy defines parameters for AccountWatchlistMovies.
type AccountWatchlistMoviesParamsSortBy string

// AccountWatchlistTvParams defines parameters for AccountWatchlistTv.
type AccountWatchlistTvParams struct {
	Language  *string                         `form:"language,omitempty" json:"language,omitempty"`
	Page      *int32                          `form:"page,omitempty" json:"page,omitempty"`
	SessionID *string                         `form:"session_id,omitempty" json:"session_id,omitempty"`
	SortBy    *AccountWatchlistTvParamsSortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`
}

// AccountWatchlistTvParamsSortBy defines parameters for AccountWatchlistTv.
type AccountWatchlistTvParamsSortBy string

// AuthenticationDeleteSessionJSONBody defines parameters for AuthenticationDeleteSession.
type AuthenticationDeleteSessionJSONBody struct {
	RAWBODY json.RawMessage `json:"RAW_BODY"`
}

// AuthenticationCreateSessionFromV4TokenJSONBody defines parameters for AuthenticationCreateSessionFromV4Token.
type AuthenticationCreateSessionFromV4TokenJSONBody struct {
	RAWBODY json.RawMessage `json:"RAW_BODY"`
}

// AuthenticationCreateSessionJSONBody defines parameters for AuthenticationCreateSession.
type AuthenticationCreateSessionJSONBody struct {
	RAWBODY json.RawMessage `json:"RAW_BODY"`
}

// AuthenticationCreateSessionFromLoginJSONBody defines parameters for AuthenticationCreateSessionFromLogin.
type AuthenticationCreateSessionFromLoginJSONBody struct {
	RAWBODY json.RawMessage `json:"RAW_BODY"`
}

// CollectionDetailsParams defines parameters for CollectionDetails.
type CollectionDetailsParams struct {
	Language *string `form:"language,omitempty" json:"language,omitempty"`
}

// CollectionImagesParams defines parameters for CollectionImages.
type CollectionImagesParams struct {
	// IncludeImageLanguage specify a comma separated list of ISO-639-1 values to query, for example: `en,null`
	IncludeImageLanguage *string `form:"include_image_language,omitempty" json:"include_image_language,omitempty"`
	Language             *string `form:"language,omitempty" json:"language,omitempty"`
}

// ConfigurationCountriesParams defines parameters for ConfigurationCountries.
type ConfigurationCountriesParams struct {
	Language *string `form:"language,omitempty" json:"language,omitempty"`
}

// DiscoverMovieParams defines parameters for DiscoverMovie.
type DiscoverMovieParams struct {
	// Certification use in conjunction with `region`
	Certification *string `form:"certification,omitempty" json:"certification,omitempty"`

	// CertificationGte use in conjunction with `region`
	CertificationGte *string `form:"certification.gte,omitempty" json:"certification.gte,omitempty"`

	// CertificationLte use in conjunction with `region`
	CertificationLte *string `form:"certification.lte,omitempty" json:"certification.lte,omitempty"`

	// CertificationCountry use in conjunction with the `certification`, `certification.gte` and `certification.lte` filters
	CertificationCountry  *string                    `form:"certification_country,omitempty" json:"certification_country,omitempty"`
	IncludeAdult          *bool                      `form:"include_adult,omitempty" json:"include_adult,omitempty"`
	IncludeVideo          *bool                      `form:"include_video,omitempty" json:"include_video,omitempty"`
	Language              *string                    `form:"language,omitempty" json:"language,omitempty"`
	Page                  *int32                     `form:"page,omitempty" json:"page,omitempty"`
	PrimaryReleaseYear    *int32                     `form:"primary_release_year,omitempty" json:"primary_release_year,omitempty"`
	PrimaryReleaseDateGte *openapi_types.Date        `form:"primary_release_date.gte,omitempty" json:"primary_release_date.gte,omitempty"`
	PrimaryReleaseDateLte *openapi_types.Date        `form:"primary_release_date.lte,omitempty" json:"primary_release_date.lte,omitempty"`
	Region                *string                    `form:"region,omitempty" json:"region,omitempty"`
	ReleaseDateGte        *openapi_types.Date        `form:"release_date.gte,omitempty" json:"release_date.gte,omitempty"`
	ReleaseDateLte        *openapi_types.Date        `form:"release_date.lte,omitempty" json:"release_date.lte,omitempty"`
	SortBy                *DiscoverMovieParamsSortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`
	VoteAverageGte        *float32                   `form:"vote_average.gte,omitempty" json:"vote_average.gte,omitempty"`
	VoteAverageLte        *float32                   `form:"vote_average.lte,omitempty" json:"vote_average.lte,omitempty"`
	VoteCountGte          *float32                   `form:"vote_count.gte,omitempty" json:"vote_count.gte,omitempty"`
	VoteCountLte          *float32                   `form:"vote_count.lte,omitempty" json:"vote_count.lte,omitempty"`

	// WatchRegion use in conjunction with `with_watch_monetization_types ` or `with_watch_providers `
	WatchRegion *string `form:"watch_region,omitempty" json:"watch_region,omitempty"`

	// WithCast can be a comma (`AND`) or pipe (`OR`) separated query
	WithCast *string `form:"with_cast,omitempty" json:"with_cast,omitempty"`

	// WithCompanies can be a comma (`AND`) or pipe (`OR`) separated query
	WithCompanies *string `form:"with_companies,omitempty" json:"with_companies,omitempty"`

	// WithCrew can be a comma (`AND`) or pipe (`OR`) separated query
	WithCrew *string `form:"with_crew,omitempty" json:"with_crew,omitempty"`

	// WithGenres can be a comma (`AND`) or pipe (`OR`) separated query
	WithGenres *string `form:"with_genres,omitempty" json:"with_genres,omitempty"`

	// WithKeywords can be a comma (`AND`) or pipe (`OR`) separated query
	WithKeywords         *string `form:"with_keywords,omitempty" json:"with_keywords,omitempty"`
	WithOriginCountry    *string `form:"with_origin_country,omitempty" json:"with_origin_country,omitempty"`
	WithOriginalLanguage *string `form:"with_original_language,omitempty" json:"with_original_language,omitempty"`

	// WithPeople can be a comma (`AND`) or pipe (`OR`) separated query
	WithPeople *string `form:"with_people,omitempty" json:"with_people,omitempty"`

	// WithReleaseType possible values are: [1, 2, 3, 4, 5, 6] can be a comma (`AND`) or pipe (`OR`) separated query, can be used in conjunction with `region`
	WithReleaseType *int32 `form:"with_release_type,omitempty" json:"with_release_type,omitempty"`
	WithRuntimeGte  *int32 `form:"with_runtime.gte,omitempty" json:"with_runtime.gte,omitempty"`
	WithRuntimeLte  *int32 `form:"with_runtime.lte,omitempty" json:"with_runtime.lte,omitempty"`

	// WithWatchMonetizationTypes possible values are: [flatrate, free, ads, rent, buy] use in conjunction with `watch_region`, can be a comma (`AND`) or pipe (`OR`) separated query
	WithWatchMonetizationTypes *string `form:"with_watch_monetization_types,omitempty" json:"with_watch_monetization_types,omitempty"`

	// WithWatchProviders use in conjunction with `watch_region`, can be a comma (`AND`) or pipe (`OR`) separated query
	WithWatchProviders    *string `form:"with_watch_providers,omitempty" json:"with_watch_providers,omitempty"`
	WithoutCompanies      *string `form:"without_companies,omitempty" json:"without_companies,omitempty"`
	WithoutGenres         *string `form:"without_genres,omitempty" json:"without_genres,omitempty"`
	WithoutKeywords       *string `form:"without_keywords,omitempty" json:"without_keywords,omitempty"`
	WithoutWatchProviders *string `form:"without_watch_providers,omitempty" json:"without_watch_providers,omitempty"`
	Year                  *int32  `form:"year,omitempty" json:"year,omitempty"`
}

// DiscoverMovieParamsSortBy defines parameters for DiscoverMovie.
type DiscoverMovieParamsSortBy string

// DiscoverTvParams defines parameters for DiscoverTv.
type DiscoverTvParams struct {
	AirDateGte               *openapi_types.Date     `form:"air_date.gte,omitempty" json:"air_date.gte,omitempty"`
	AirDateLte               *openapi_types.Date     `form:"air_date.lte,omitempty" json:"air_date.lte,omitempty"`
	FirstAirDateYear         *int32                  `form:"first_air_date_year,omitempty" json:"first_air_date_year,omitempty"`
	FirstAirDateGte          *openapi_types.Date     `form:"first_air_date.gte,omitempty" json:"first_air_date.gte,omitempty"`
	FirstAirDateLte          *openapi_types.Date     `form:"first_air_date.lte,omitempty" json:"first_air_date.lte,omitempty"`
	IncludeAdult             *bool                   `form:"include_adult,omitempty" json:"include_adult,omitempty"`
	IncludeNullFirstAirDates *bool                   `form:"include_null_first_air_dates,omitempty" json:"include_null_first_air_dates,omitempty"`
	Language                 *string                 `form:"language,omitempty" json:"language,omitempty"`
	Page                     *int32                  `form:"page,omitempty" json:"page,omitempty"`
	ScreenedTheatrically     *bool                   `form:"screened_theatrically,omitempty" json:"screened_theatrically,omitempty"`
	SortBy                   *DiscoverTvParamsSortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`
	Timezone                 *string                 `form:"timezone,omitempty" json:"timezone,omitempty"`
	VoteAverageGte           *float32                `form:"vote_average.gte,omitempty" json:"vote_average.gte,omitempty"`
	VoteAverageLte           *float32                `form:"vote_average.lte,omitempty" json:"vote_average.lte,omitempty"`
	VoteCountGte             *float32                `form:"vote_count.gte,omitempty" json:"vote_count.gte,omitempty"`
	VoteCountLte             *float32                `form:"vote_count.lte,omitempty" json:"vote_count.lte,omitempty"`

	// WatchRegion use in conjunction with `with_watch_monetization_types ` or `with_watch_providers `
	WatchRegion *string `form:"watch_region,omitempty" json:"watch_region,omitempty"`

	// WithCompanies can be a comma (`AND`) or pipe (`OR`) separated query
	WithCompanies *string `form:"with_companies,omitempty" json:"with_companies,omitempty"`

	// WithGenres can be a comma (`AND`) or pipe (`OR`) separated query
	WithGenres *string `form:"with_genres,omitempty" json:"with_genres,omitempty"`

	// WithKeywords can be a comma (`AND`) or pipe (`OR`) separated query
	WithKeywords         *string `form:"with_keywords,omitempty" json:"with_keywords,omitempty"`
	WithNetworks         *int32  `form:"with_networks,omitempty" json:"with_networks,omitempty"`
	WithOriginCountry    *string `form:"with_origin_country,omitempty" json:"with_origin_country,omitempty"`
	WithOriginalLanguage *string `form:"with_original_language,omitempty" json:"with_original_language,omitempty"`
	WithRuntimeGte       *int32  `form:"with_runtime.gte,omitempty" json:"with_runtime.gte,omitempty"`
	WithRuntimeLte       *int32  `form:"with_runtime.lte,omitempty" json:"with_runtime.lte,omitempty"`

	// WithStatus possible values are: [0, 1, 2, 3, 4, 5], can be a comma (`AND`) or pipe (`OR`) separated query
	WithStatus *string `form:"with_status,omitempty" json:"with_status,omitempty"`

	// WithWatchMonetizationTypes possible values are: [flatrate, free, ads, rent, buy] use in conjunction with `watch_region`, can be a comma (`AND`) or pipe (`OR`) separated query
	WithWatchMonetizationTypes *string `form:"with_watch_monetization_types,omitempty" json:"with_watch_monetization_types,omitempty"`

	// WithWatchProviders use in conjunction with `watch_region`, can be a comma (`AND`) or pipe (`OR`) separated query
	WithWatchProviders    *string `form:"with_watch_providers,omitempty" json:"with_watch_providers,omitempty"`
	WithoutCompanies      *string `form:"without_companies,omitempty" json:"without_companies,omitempty"`
	WithoutGenres         *string `form:"without_genres,omitempty" json:"without_genres,omitempty"`
	WithoutKeywords       *string `form:"without_keywords,omitempty" json:"without_keywords,omitempty"`
	WithoutWatchProviders *string `form:"without_watch_providers,omitempty" json:"without_watch_providers,omitempty"`

	// WithType possible values are: [0, 1, 2, 3, 4, 5, 6], can be a comma (`AND`) or pipe (`OR`) separated query
	WithType *string `form:"with_type,omitempty" json:"with_type,omitempty"`
}

// DiscoverTvParamsSortBy defines parameters for DiscoverTv.
type DiscoverTvParamsSortBy string

// FindByIDParams defines parameters for FindByID.
type FindByIDParams struct {
	ExternalSource FindByIDParamsExternalSource `form:"external_source" json:"external_source"`
	Language       *string                      `form:"language,omitempty" json:"language,omitempty"`
}

// FindByIDParamsExternalSource defines parameters for FindByID.
type FindByIDParamsExternalSource string

// GenreMovieListParams defines parameters for GenreMovieList.
type GenreMovieListParams struct {
	Language *string `form:"language,omitempty" json:"language,omitempty"`
}

// GenreTvListParams defines parameters for GenreTvList.
type GenreTvListParams struct {
	Language *string `form:"language,omitempty" json:"language,omitempty"`
}

// GuestSessionRatedMoviesParams defines parameters for GuestSessionRatedMovies.
type GuestSessionRatedMoviesParams struct {
	Language *string                              `form:"language,omitempty" json:"language,omitempty"`
	Page     *int32                               `form:"page,omitempty" json:"page,omitempty"`
	SortBy   *GuestSessionRatedMoviesParamsSortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`
}

// GuestSessionRatedMoviesParamsSortBy defines parameters for GuestSessionRatedMovies.
type GuestSessionRatedMoviesParamsSortBy string

// GuestSessionRatedTvParams defines parameters for GuestSessionRatedTv.
type GuestSessionRatedTvParams struct {
	Language *string                          `form:"language,omitempty" json:"language,omitempty"`
	Page     *int32                           `form:"page,omitempty" json:"page,omitempty"`
	SortBy   *GuestSessionRatedTvParamsSortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`
}

// GuestSessionRatedTvParamsSortBy defines parameters for GuestSessionRatedTv.
type GuestSessionRatedTvParamsSortBy string

// GuestSessionRatedTvEpisodesParams defines parameters for GuestSessionRatedTvEpisodes.
type GuestSessionRatedTvEpisodesParams struct {
	Language *string                                  `form:"language,omitempty" json:"language,omitempty"`
	Page     *int32                                   `form:"page,omitempty" json:"page,omitempty"`
	SortBy   *GuestSessionRatedTvEpisodesParamsSortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`
}

// GuestSessionRatedTvEpisodesParamsSortBy defines parameters for GuestSessionRatedTvEpisodes.
type GuestSessionRatedTvEpisodesParamsSortBy string

// KeywordMoviesParams defines parameters for KeywordMovies.
type KeywordMoviesParams struct {
	IncludeAdult *bool   `form:"include_adult,omitempty" json:"include_adult,omitempty"`
	Language     *string `form:"language,omitempty" json:"language,omitempty"`
	Page         *int32  `form:"page,omitempty" json:"page,omitempty"`
}

// ListCreateJSONBody defines parameters for ListCreate.
type ListCreateJSONBody struct {
	RAWBODY json.RawMessage `json:"RAW_BODY"`
}

// ListCreateParams defines parameters for ListCreate.
type ListCreateParams struct {
	SessionID string `form:"session_id" json:"session_id"`
}

// ListDeleteParams defines parameters for ListDelete.
type ListDeleteParams struct {
	SessionID string `form:"session_id" json:"session_id"`
}

// ListDetailsParams defines parameters for ListDetails.
type ListDetailsParams struct {
	Language *string `form:"language,omitempty" json:"language,omitempty"`
	Page     *int32  `form:"page,omitempty" json:"page,omitempty"`
}

// ListAddMovieJSONBody defines parameters for ListAddMovie.
type ListAddMovieJSONBody struct {
	RAWBODY json.RawMessage `json:"RAW_BODY,omitempty"`
}

// ListAddMovieParams defines parameters for ListAddMovie.
type ListAddMovieParams struct {
	SessionID string `form:"session_id" json:"session_id"`
}

// ListClearParams defines parameters for ListClear.
type ListClearParams struct {
	SessionID string `form:"session_id" json:"session_id"`
	Confirm   bool   `form:"confirm" json:"confirm"`
}

// ListCheckItemStatusParams defines parameters for ListCheckItemStatus.
type ListCheckItemStatusParams struct {
	Language *string `form:"language,omitempty" json:"language,omitempty"`
	MovieID  *int32  `form:"movie_id,omitempty" json:"movie_id,omitempty"`
}

// ListRemoveMovieJSONBody defines parameters for ListRemoveMovie.
type ListRemoveMovieJSONBody struct {
	RAWBODY json.RawMessage `json:"RAW_BODY"`
}

// ListRemoveMovieParams defines parameters for ListRemoveMovie.
type ListRemoveMovieParams struct {
	SessionID string `form:"session_id" json:"session_id"`
}

// ChangesMovieListParams defines parameters for ChangesMovieList.
type ChangesMovieListParams struct {
	EndDate   *openapi_types.Date `form:"end_date,omitempty" json:"end_date,omitempty"`
	Page      *int32              `form:"page,omitempty" json:"page,omitempty"`
	StartDate *openapi_types.Date `form:"start_date,omitempty" json:"start_date,omitempty"`
}

// MovieNowPlayingListParams defines parameters for MovieNowPlayingList.
type MovieNowPlayingListParams struct {
	Language *string `form:"language,omitempty" json:"language,omitempty"`
	Page     *int32  `form:"page,omitempty" json:"page,omitempty"`

	// Region ISO-3166-1 code
	Region *string `form:"region,omitempty" json:"region,omitempty"`
}

// MoviePopularListParams defines parameters for MoviePopularList.
type MoviePopularListParams struct {
	Language *string `form:"language,omitempty" json:"language,omitempty"`
	Page     *int32  `form:"page,omitempty" json:"page,omitempty"`

	// Region ISO-3166-1 code
	Region *string `form:"region,omitempty" json:"region,omitempty"`
}

// MovieTopRatedListParams defines parameters for MovieTopRatedList.
type MovieTopRatedListParams struct {
	Language *string `form:"language,omitempty" json:"language,omitempty"`
	Page     *int32  `form:"page,omitempty" json:"page,omitempty"`

	// Region ISO-3166-1 code
	Region *string `form:"region,omitempty" json:"region,omitempty"`
}

// MovieUpcomingListParams defines parameters for MovieUpcomingList.
type MovieUpcomingListParams struct {
	Language *string `form:"language,omitempty" json:"language,omitempty"`
	Page     *int32  `form:"page,omitempty" json:"page,omitempty"`

	// Region ISO-3166-1 code
	Region *string `form:"region,omitempty" json:"region,omitempty"`
}

// MovieDetailsParams defines parameters for MovieDetails.
type MovieDetailsParams struct {
	// AppendToResponse comma separated list of endpoints within this namespace, 20 items max
	AppendToResponse *string `form:"append_to_response,omitempty" json:"append_to_response,omitempty"`
	Language         *string `form:"language,omitempty" json:"language,omitempty"`
}

// MovieAccountStatesParams defines parameters for MovieAccountStates.
type MovieAccountStatesParams struct {
	SessionID      *string `form:"session_id,omitempty" json:"session_id,omitempty"`
	GuestSessionID *string `form:"guest_session_id,omitempty" json:"guest_session_id,omitempty"`
}

// MovieAlternativeTitlesParams defines parameters for MovieAlternativeTitles.
type MovieAlternativeTitlesParams struct {
	// Country specify a ISO-3166-1 value to filter the results
	Country *string `form:"country,omitempty" json:"country,omitempty"`
}

// MovieChangesParams defines parameters for MovieChanges.
type MovieChangesParams struct {
	EndDate   *openapi_types.Date `form:"end_date,omitempty" json:"end_date,omitempty"`
	Page      *int32              `form:"page,omitempty" json:"page,omitempty"`
	StartDate *openapi_types.Date `form:"start_date,omitempty" json:"start_date,omitempty"`
}

// MovieCreditsParams defines parameters for MovieCredits.
type MovieCreditsParams struct {
	Language *string `form:"language,omitempty" json:"language,omitempty"`
}

// MovieImagesParams defines parameters for MovieImages.
type MovieImagesParams struct {
	// IncludeImageLanguage specify a comma separated list of ISO-639-1 values to query, for example: `en,null`
	IncludeImageLanguage *string `form:"include_image_language,omitempty" json:"include_image_language,omitempty"`
	Language             *string `form:"language,omitempty" json:"language,omitempty"`
}

// MovieListsParams defines parameters for MovieLists.
type MovieListsParams struct {
	Language *string `form:"language,omitempty" json:"language,omitempty"`
	Page     *int32  `form:"page,omitempty" json:"page,omitempty"`
}

// MovieDeleteRatingParams defines parameters for MovieDeleteRating.
type MovieDeleteRatingParams struct {
	GuestSessionID *string `form:"guest_session_id,omitempty" json:"guest_session_id,omitempty"`
	SessionID      *string `form:"session_id,omitempty" json:"session_id,omitempty"`
	ContentType    *string `json:"Content-Type,omitempty"`
}

// MovieAddRatingJSONBody defines parameters for MovieAddRating.
type MovieAddRatingJSONBody struct {
	RAWBODY json.RawMessage `json:"RAW_BODY"`
}

// MovieAddRatingParams defines parameters for MovieAddRating.
type MovieAddRatingParams struct {
	GuestSessionID *string `form:"guest_session_id,omitempty" json:"guest_session_id,omitempty"`
	SessionID      *string `form:"session_id,omitempty" json:"session_id,omitempty"`
	ContentType    string  `json:"Content-Type"`
}

// MovieRecommendationsParams defines parameters for MovieRecommendations.
type MovieRecommendationsParams struct {
	Language *string `form:"language,omitempty" json:"language,omitempty"`
	Page     *int32  `form:"page,omitempty" json:"page,omitempty"`
}

// MovieReviewsParams defines parameters for MovieReviews.
type MovieReviewsParams struct {
	Language *string `form:"language,omitempty" json:"language,omitempty"`
	Page     *int32  `form:"page,omitempty" json:"page,omitempty"`
}

// MovieSimilarParams defines parameters for MovieSimilar.
type MovieSimilarParams struct {
	Language *string `form:"language,omitempty" json:"language,omitempty"`
	Page     *int32  `form:"page,omitempty" json:"page,omitempty"`
}

// MovieVideosParams defines parameters for MovieVideos.
type MovieVideosParams struct {
	Language *string `form:"language,omitempty" json:"language,omitempty"`
}

// ChangesPeopleListParams defines parameters for ChangesPeopleList.
type ChangesPeopleListParams struct {
	EndDate   *openapi_types.Date `form:"end_date,omitempty" json:"end_date,omitempty"`
	Page      *int32              `form:"page,omitempty" json:"page,omitempty"`
	StartDate *openapi_types.Date `form:"start_date,omitempty" json:"start_date,omitempty"`
}

// PersonPopularListParams defines parameters for PersonPopularList.
type PersonPopularListParams struct {
	Language *string `form:"language,omitempty" json:"language,omitempty"`
	Page     *int32  `form:"page,omitempty" json:"page,omitempty"`
}

// PersonDetailsParams defines parameters for PersonDetails.
type PersonDetailsParams struct {
	// AppendToResponse comma separated list of endpoints within this namespace, 20 items max
	AppendToResponse *string `form:"append_to_response,omitempty" json:"append_to_response,omitempty"`
	Language         *string `form:"language,omitempty" json:"language,omitempty"`
}

// PersonChangesParams defines parameters for PersonChanges.
type PersonChangesParams struct {
	EndDate   *openapi_types.Date `form:"end_date,omitempty" json:"end_date,omitempty"`
	Page      *int32              `form:"page,omitempty" json:"page,omitempty"`
	StartDate *openapi_types.Date `form:"start_date,omitempty" json:"start_date,omitempty"`
}

// PersonCombinedCreditsParams defines parameters for PersonCombinedCredits.
type PersonCombinedCreditsParams struct {
	Language *string `form:"language,omitempty" json:"language,omitempty"`
}

// PersonMovieCreditsParams defines parameters for PersonMovieCredits.
type PersonMovieCreditsParams struct {
	Language *string `form:"language,omitempty" json:"language,omitempty"`
}

// PersonTaggedImagesParams defines parameters for PersonTaggedImages.
type PersonTaggedImagesParams struct {
	Page *int32 `form:"page,omitempty" json:"page,omitempty"`
}

// PersonTvCreditsParams defines parameters for PersonTvCredits.
type PersonTvCreditsParams struct {
	Language *string `form:"language,omitempty" json:"language,omitempty"`
}

// SearchCollectionParams defines parameters for SearchCollection.
type SearchCollectionParams struct {
	Query        string  `form:"query" json:"query"`
	IncludeAdult *bool   `form:"include_adult,omitempty" json:"include_adult,omitempty"`
	Language     *string `form:"language,omitempty" json:"language,omitempty"`
	Page         *int32  `form:"page,omitempty" json:"page,omitempty"`
	Region       *string `form:"region,omitempty" json:"region,omitempty"`
}

// SearchCompanyParams defines parameters for SearchCompany.
type SearchCompanyParams struct {
	Query string `form:"query" json:"query"`
	Page  *int32 `form:"page,omitempty" json:"page,omitempty"`
}

// SearchKeywordParams defines parameters for SearchKeyword.
type SearchKeywordParams struct {
	Query string `form:"query" json:"query"`
	Page  *int32 `form:"page,omitempty" json:"page,omitempty"`
}

// SearchMovieParams defines parameters for SearchMovie.
type SearchMovieParams struct {
	Query              string  `form:"query" json:"query"`
	IncludeAdult       *bool   `form:"include_adult,omitempty" json:"include_adult,omitempty"`
	Language           *string `form:"language,omitempty" json:"language,omitempty"`
	PrimaryReleaseYear *string `form:"primary_release_year,omitempty" json:"primary_release_year,omitempty"`
	Page               *int32  `form:"page,omitempty" json:"page,omitempty"`
	Region             *string `form:"region,omitempty" json:"region,omitempty"`
	Year               *string `form:"year,omitempty" json:"year,omitempty"`
}

// SearchMultiParams defines parameters for SearchMulti.
type SearchMultiParams struct {
	Query        string  `form:"query" json:"query"`
	IncludeAdult *bool   `form:"include_adult,omitempty" json:"include_adult,omitempty"`
	Language     *string `form:"language,omitempty" json:"language,omitempty"`
	Page         *int32  `form:"page,omitempty" json:"page,omitempty"`
}

// SearchPersonParams defines parameters for SearchPerson.
type SearchPersonParams struct {
	Query        string  `form:"query" json:"query"`
	IncludeAdult *bool   `form:"include_adult,omitempty" json:"include_adult,omitempty"`
	Language     *string `form:"language,omitempty" json:"language,omitempty"`
	Page         *int32  `form:"page,omitempty" json:"page,omitempty"`
}

// SearchTvParams defines parameters for SearchTv.
type SearchTvParams struct {
	Query string `form:"query" json:"query"`

	// FirstAirDateYear Search only the first air date. Valid values are: 1000..9999
	FirstAirDateYear *int32  `form:"first_air_date_year,omitempty" json:"first_air_date_year,omitempty"`
	IncludeAdult     *bool   `form:"include_adult,omitempty" json:"include_adult,omitempty"`
	Language         *string `form:"language,omitempty" json:"language,omitempty"`
	Page             *int32  `form:"page,omitempty" json:"page,omitempty"`

	// Year Search the first air date and all episode air dates. Valid values are: 1000..9999
	Year *int32 `form:"year,omitempty" json:"year,omitempty"`
}

// TrendingAllParams defines parameters for TrendingAll.
type TrendingAllParams struct {
	// Language `ISO-639-1`-`ISO-3166-1` code
	Language *string `form:"language,omitempty" json:"language,omitempty"`
}

// TrendingAllParamsTimeWindow defines parameters for TrendingAll.
type TrendingAllParamsTimeWindow string

// TrendingMoviesParams defines parameters for TrendingMovies.
type TrendingMoviesParams struct {
	// Language `ISO-639-1`-`ISO-3166-1` code
	Language *string `form:"language,omitempty" json:"language,omitempty"`
}

// TrendingMoviesParamsTimeWindow defines parameters for TrendingMovies.
type TrendingMoviesParamsTimeWindow string

// TrendingPeopleParams defines parameters for TrendingPeople.
type TrendingPeopleParams struct {
	// Language `ISO-639-1`-`ISO-3166-1` code
	Language *string `form:"language,omitempty" json:"language,omitempty"`
}

// TrendingPeopleParamsTimeWindow defines parameters for TrendingPeople.
type TrendingPeopleParamsTimeWindow string

// TrendingTvParams defines parameters for TrendingTv.
type TrendingTvParams struct {
	// Language `ISO-639-1`-`ISO-3166-1` code
	Language *string `form:"language,omitempty" json:"language,omitempty"`
}

// TrendingTvParamsTimeWindow defines parameters for TrendingTv.
type TrendingTvParamsTimeWindow string

// TvSeriesAiringTodayListParams defines parameters for TvSeriesAiringTodayList.
type TvSeriesAiringTodayListParams struct {
	Language *string `form:"language,omitempty" json:"language,omitempty"`
	Page     *int32  `form:"page,omitempty" json:"page,omitempty"`
	Timezone *string `form:"timezone,omitempty" json:"timezone,omitempty"`
}

// ChangesTvListParams defines parameters for ChangesTvList.
type ChangesTvListParams struct {
	EndDate   *openapi_types.Date `form:"end_date,omitempty" json:"end_date,omitempty"`
	Page      *int32              `form:"page,omitempty" json:"page,omitempty"`
	StartDate *openapi_types.Date `form:"start_date,omitempty" json:"start_date,omitempty"`
}

// TvSeriesOnTheAirListParams defines parameters for TvSeriesOnTheAirList.
type TvSeriesOnTheAirListParams struct {
	Language *string `form:"language,omitempty" json:"language,omitempty"`
	Page     *int32  `form:"page,omitempty" json:"page,omitempty"`
	Timezone *string `form:"timezone,omitempty" json:"timezone,omitempty"`
}

// TvSeriesPopularListParams defines parameters for TvSeriesPopularList.
type TvSeriesPopularListParams struct {
	Language *string `form:"language,omitempty" json:"language,omitempty"`
	Page     *int32  `form:"page,omitempty" json:"page,omitempty"`
}

// TvSeasonChangesByIDParams defines parameters for TvSeasonChangesByID.
type TvSeasonChangesByIDParams struct {
	EndDate   *string `form:"end_date,omitempty" json:"end_date,omitempty"`
	Page      *int32  `form:"page,omitempty" json:"page,omitempty"`
	StartDate *string `form:"start_date,omitempty" json:"start_date,omitempty"`
}

// TvSeriesTopRatedListParams defines parameters for TvSeriesTopRatedList.
type TvSeriesTopRatedListParams struct {
	Language *string `form:"language,omitempty" json:"language,omitempty"`
	Page     *int32  `form:"page,omitempty" json:"page,omitempty"`
}

// TvSeriesDetailsParams defines parameters for TvSeriesDetails.
type TvSeriesDetailsParams struct {
	// AppendToResponse comma separated list of endpoints within this namespace, 20 items max
	AppendToResponse *string `form:"append_to_response,omitempty" json:"append_to_response,omitempty"`
	Language         *string `form:"language,omitempty" json:"language,omitempty"`
}

// TvSeriesAccountStatesParams defines parameters for TvSeriesAccountStates.
type TvSeriesAccountStatesParams struct {
	SessionID      *string `form:"session_id,omitempty" json:"session_id,omitempty"`
	GuestSessionID *string `form:"guest_session_id,omitempty" json:"guest_session_id,omitempty"`
}

// TvSeriesAggregateCreditsParams defines parameters for TvSeriesAggregateCredits.
type TvSeriesAggregateCreditsParams struct {
	Language *string `form:"language,omitempty" json:"language,omitempty"`
}

// TvSeriesChangesParams defines parameters for TvSeriesChanges.
type TvSeriesChangesParams struct {
	EndDate   *string `form:"end_date,omitempty" json:"end_date,omitempty"`
	Page      *int32  `form:"page,omitempty" json:"page,omitempty"`
	StartDate *string `form:"start_date,omitempty" json:"start_date,omitempty"`
}

// TvSeriesCreditsParams defines parameters for TvSeriesCredits.
type TvSeriesCreditsParams struct {
	Language *string `form:"language,omitempty" json:"language,omitempty"`
}

// TvSeriesImagesParams defines parameters for TvSeriesImages.
type TvSeriesImagesParams struct {
	// IncludeImageLanguage specify a comma separated list of ISO-639-1 values to query, for example: `en,null`
	IncludeImageLanguage *string `form:"include_image_language,omitempty" json:"include_image_language,omitempty"`
	Language             *string `form:"language,omitempty" json:"language,omitempty"`
}

// ListsCopyParams defines parameters for ListsCopy.
type ListsCopyParams struct {
	Language *string `form:"language,omitempty" json:"language,omitempty"`
	Page     *int32  `form:"page,omitempty" json:"page,omitempty"`
}

// TvSeriesDeleteRatingParams defines parameters for TvSeriesDeleteRating.
type TvSeriesDeleteRatingParams struct {
	GuestSessionID *string `form:"guest_session_id,omitempty" json:"guest_session_id,omitempty"`
	SessionID      *string `form:"session_id,omitempty" json:"session_id,omitempty"`
	ContentType    *string `json:"Content-Type,omitempty"`
}

// TvSeriesAddRatingJSONBody defines parameters for TvSeriesAddRating.
type TvSeriesAddRatingJSONBody struct {
	RAWBODY json.RawMessage `json:"RAW_BODY"`
}

// TvSeriesAddRatingParams defines parameters for TvSeriesAddRating.
type TvSeriesAddRatingParams struct {
	GuestSessionID *string `form:"guest_session_id,omitempty" json:"guest_session_id,omitempty"`
	SessionID      *string `form:"session_id,omitempty" json:"session_id,omitempty"`
	ContentType    string  `json:"Content-Type"`
}

// TvSeriesRecommendationsParams defines parameters for TvSeriesRecommendations.
type TvSeriesRecommendationsParams struct {
	Language *string `form:"language,omitempty" json:"language,omitempty"`
	Page     *int32  `form:"page,omitempty" json:"page,omitempty"`
}

// TvSeriesReviewsParams defines parameters for TvSeriesReviews.
type TvSeriesReviewsParams struct {
	Language *string `form:"language,omitempty" json:"language,omitempty"`
	Page     *int32  `form:"page,omitempty" json:"page,omitempty"`
}

// TvSeasonDetailsParams defines parameters for TvSeasonDetails.
type TvSeasonDetailsParams struct {
	// AppendToResponse comma separated list of endpoints within this namespace, 20 items max
	AppendToResponse *string `form:"append_to_response,omitempty" json:"append_to_response,omitempty"`
	Language         *string `form:"language,omitempty" json:"language,omitempty"`
}

// TvSeasonAccountStatesParams defines parameters for TvSeasonAccountStates.
type TvSeasonAccountStatesParams struct {
	SessionID      *string `form:"session_id,omitempty" json:"session_id,omitempty"`
	GuestSessionID *string `form:"guest_session_id,omitempty" json:"guest_session_id,omitempty"`
}

// TvSeasonAggregateCreditsParams defines parameters for TvSeasonAggregateCredits.
type TvSeasonAggregateCreditsParams struct {
	Language *string `form:"language,omitempty" json:"language,omitempty"`
}

// TvSeasonCreditsParams defines parameters for TvSeasonCredits.
type TvSeasonCreditsParams struct {
	Language *string `form:"language,omitempty" json:"language,omitempty"`
}

// TvEpisodeDetailsParams defines parameters for TvEpisodeDetails.
type TvEpisodeDetailsParams struct {
	// AppendToResponse comma separated list of endpoints within this namespace, 20 items max
	AppendToResponse *string `form:"append_to_response,omitempty" json:"append_to_response,omitempty"`
	Language         *string `form:"language,omitempty" json:"language,omitempty"`
}

// TvEpisodeAccountStatesParams defines parameters for TvEpisodeAccountStates.
type TvEpisodeAccountStatesParams struct {
	SessionID      *string `form:"session_id,omitempty" json:"session_id,omitempty"`
	GuestSessionID *string `form:"guest_session_id,omitempty" json:"guest_session_id,omitempty"`
}

// TvEpisodeCreditsParams defines parameters for TvEpisodeCredits.
type TvEpisodeCreditsParams struct {
	Language *string `form:"language,omitempty" json:"language,omitempty"`
}

// TvEpisodeImagesParams defines parameters for TvEpisodeImages.
type TvEpisodeImagesParams struct {
	// IncludeImageLanguage specify a comma separated list of ISO-639-1 values to query, for example: `en,null`
	IncludeImageLanguage *string `form:"include_image_language,omitempty" json:"include_image_language,omitempty"`
	Language             *string `form:"language,omitempty" json:"language,omitempty"`
}

// TvEpisodeDeleteRatingParams defines parameters for TvEpisodeDeleteRating.
type TvEpisodeDeleteRatingParams struct {
	GuestSessionID *string `form:"guest_session_id,omitempty" json:"guest_session_id,omitempty"`
	SessionID      *string `form:"session_id,omitempty" json:"session_id,omitempty"`
	ContentType    *string `json:"Content-Type,omitempty"`
}

// TvEpisodeAddRatingJSONBody defines parameters for TvEpisodeAddRating.
type TvEpisodeAddRatingJSONBody struct {
	RAWBODY json.RawMessage `json:"RAW_BODY"`
}

// TvEpisodeAddRatingParams defines parameters for TvEpisodeAddRating.
type TvEpisodeAddRatingParams struct {
	GuestSessionID *string `form:"guest_session_id,omitempty" json:"guest_session_id,omitempty"`
	SessionID      *string `form:"session_id,omitempty" json:"session_id,omitempty"`
	ContentType    string  `json:"Content-Type"`
}

// TvEpisodeVideosParams defines parameters for TvEpisodeVideos.
type TvEpisodeVideosParams struct {
	// IncludeVideoLanguage filter the list results by language, supports more than one value by using a comma
	IncludeVideoLanguage *string `form:"include_video_language,omitempty" json:"include_video_language,omitempty"`
	Language             *string `form:"language,omitempty" json:"language,omitempty"`
}

// TvSeasonImagesParams defines parameters for TvSeasonImages.
type TvSeasonImagesParams struct {
	// IncludeImageLanguage specify a comma separated list of ISO-639-1 values to query, for example: `en,null`
	IncludeImageLanguage *string `form:"include_image_language,omitempty" json:"include_image_language,omitempty"`
	Language             *string `form:"language,omitempty" json:"language,omitempty"`
}

// TvSeasonVideosParams defines parameters for TvSeasonVideos.
type TvSeasonVideosParams struct {
	// IncludeVideoLanguage filter the list results by language, supports more than one value by using a comma
	IncludeVideoLanguage *string `form:"include_video_language,omitempty" json:"include_video_language,omitempty"`
	Language             *string `form:"language,omitempty" json:"language,omitempty"`
}

// TvSeasonWatchProvidersParams defines parameters for TvSeasonWatchProviders.
type TvSeasonWatchProvidersParams struct {
	Language *string `form:"language,omitempty" json:"language,omitempty"`
}

// TvSeriesSimilarParams defines parameters for TvSeriesSimilar.
type TvSeriesSimilarParams struct {
	Language *string `form:"language,omitempty" json:"language,omitempty"`
	Page     *int32  `form:"page,omitempty" json:"page,omitempty"`
}

// TvSeriesVideosParams defines parameters for TvSeriesVideos.
type TvSeriesVideosParams struct {
	// IncludeVideoLanguage filter the list results by language, supports more than one value by using a comma
	IncludeVideoLanguage *string `form:"include_video_language,omitempty" json:"include_video_language,omitempty"`
	Language             *string `form:"language,omitempty" json:"language,omitempty"`
}

// WatchProvidersMovieListParams defines parameters for WatchProvidersMovieList.
type WatchProvidersMovieListParams struct {
	Language    *string `form:"language,omitempty" json:"language,omitempty"`
	WatchRegion *string `form:"watch_region,omitempty" json:"watch_region,omitempty"`
}

// WatchProvidersAvailableRegionsParams defines parameters for WatchProvidersAvailableRegions.
type WatchProvidersAvailableRegionsParams struct {
	Language *string `form:"language,omitempty" json:"language,omitempty"`
}

// WatchProviderTvListParams defines parameters for WatchProviderTvList.
type WatchProviderTvListParams struct {
	Language    *string `form:"language,omitempty" json:"language,omitempty"`
	WatchRegion *string `form:"watch_region,omitempty" json:"watch_region,omitempty"`
}

// AccountAddFavoriteJSONRequestBody defines body for AccountAddFavorite for application/json ContentType.
type AccountAddFavoriteJSONRequestBody AccountAddFavoriteJSONBody

// AccountAddToWatchlistJSONRequestBody defines body for AccountAddToWatchlist for application/json ContentType.
type AccountAddToWatchlistJSONRequestBody AccountAddToWatchlistJSONBody

// AuthenticationDeleteSessionJSONRequestBody defines body for AuthenticationDeleteSession for application/json ContentType.
type AuthenticationDeleteSessionJSONRequestBody AuthenticationDeleteSessionJSONBody

// AuthenticationCreateSessionFromV4TokenJSONRequestBody defines body for AuthenticationCreateSessionFromV4Token for application/json ContentType.
type AuthenticationCreateSessionFromV4TokenJSONRequestBody AuthenticationCreateSessionFromV4TokenJSONBody

// AuthenticationCreateSessionJSONRequestBody defines body for AuthenticationCreateSession for application/json ContentType.
type AuthenticationCreateSessionJSONRequestBody AuthenticationCreateSessionJSONBody

// AuthenticationCreateSessionFromLoginJSONRequestBody defines body for AuthenticationCreateSessionFromLogin for application/json ContentType.
type AuthenticationCreateSessionFromLoginJSONRequestBody AuthenticationCreateSessionFromLoginJSONBody

// ListCreateJSONRequestBody defines body for ListCreate for application/json ContentType.
type ListCreateJSONRequestBody ListCreateJSONBody

// ListAddMovieJSONRequestBody defines body for ListAddMovie for application/json ContentType.
type ListAddMovieJSONRequestBody ListAddMovieJSONBody

// ListRemoveMovieJSONRequestBody defines body for ListRemoveMovie for application/json ContentType.
type ListRemoveMovieJSONRequestBody ListRemoveMovieJSONBody

// MovieAddRatingJSONRequestBody defines body for MovieAddRating for application/json ContentType.
type MovieAddRatingJSONRequestBody MovieAddRatingJSONBody

// TvSeriesAddRatingJSONRequestBody defines body for TvSeriesAddRating for application/json ContentType.
type TvSeriesAddRatingJSONRequestBody TvSeriesAddRatingJSONBody

// TvEpisodeAddRatingJSONRequestBody defines body for TvEpisodeAddRating for application/json ContentType.
type TvEpisodeAddRatingJSONRequestBody TvEpisodeAddRatingJSONBody

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// AccountDetails request
	AccountDetails(ctx context.Context, accountID int32, params *AccountDetailsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AccountAddFavoriteWithBody request with any body
	AccountAddFavoriteWithBody(ctx context.Context, accountID int32, params *AccountAddFavoriteParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AccountAddFavorite(ctx context.Context, accountID int32, params *AccountAddFavoriteParams, body AccountAddFavoriteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AccountGetFavorites request
	AccountGetFavorites(ctx context.Context, accountID int32, params *AccountGetFavoritesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AccountFavoriteTv request
	AccountFavoriteTv(ctx context.Context, accountID int32, params *AccountFavoriteTvParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AccountLists request
	AccountLists(ctx context.Context, accountID int32, params *AccountListsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AccountRatedMovies request
	AccountRatedMovies(ctx context.Context, accountID int32, params *AccountRatedMoviesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AccountRatedTv request
	AccountRatedTv(ctx context.Context, accountID int32, params *AccountRatedTvParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AccountRatedTvEpisodes request
	AccountRatedTvEpisodes(ctx context.Context, accountID int32, params *AccountRatedTvEpisodesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AccountAddToWatchlistWithBody request with any body
	AccountAddToWatchlistWithBody(ctx context.Context, accountID int32, params *AccountAddToWatchlistParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AccountAddToWatchlist(ctx context.Context, accountID int32, params *AccountAddToWatchlistParams, body AccountAddToWatchlistJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AccountWatchlistMovies request
	AccountWatchlistMovies(ctx context.Context, accountID int32, params *AccountWatchlistMoviesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AccountWatchlistTv request
	AccountWatchlistTv(ctx context.Context, accountID int32, params *AccountWatchlistTvParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AuthenticationValidateKey request
	AuthenticationValidateKey(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AuthenticationCreateGuestSession request
	AuthenticationCreateGuestSession(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AuthenticationDeleteSessionWithBody request with any body
	AuthenticationDeleteSessionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AuthenticationDeleteSession(ctx context.Context, body AuthenticationDeleteSessionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AuthenticationCreateSessionFromV4TokenWithBody request with any body
	AuthenticationCreateSessionFromV4TokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AuthenticationCreateSessionFromV4Token(ctx context.Context, body AuthenticationCreateSessionFromV4TokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AuthenticationCreateSessionWithBody request with any body
	AuthenticationCreateSessionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AuthenticationCreateSession(ctx context.Context, body AuthenticationCreateSessionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AuthenticationCreateRequestToken request
	AuthenticationCreateRequestToken(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AuthenticationCreateSessionFromLoginWithBody request with any body
	AuthenticationCreateSessionFromLoginWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AuthenticationCreateSessionFromLogin(ctx context.Context, body AuthenticationCreateSessionFromLoginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CertificationMovieList request
	CertificationMovieList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CertificationsTvList request
	CertificationsTvList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CollectionDetails request
	CollectionDetails(ctx context.Context, collectionID int32, params *CollectionDetailsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CollectionImages request
	CollectionImages(ctx context.Context, collectionID int32, params *CollectionImagesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CollectionTranslations request
	CollectionTranslations(ctx context.Context, collectionID int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CompanyDetails request
	CompanyDetails(ctx context.Context, companyID int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CompanyAlternativeNames request
	CompanyAlternativeNames(ctx context.Context, companyID int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CompanyImages request
	CompanyImages(ctx context.Context, companyID int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ConfigurationDetails request
	ConfigurationDetails(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ConfigurationCountries request
	ConfigurationCountries(ctx context.Context, params *ConfigurationCountriesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ConfigurationJobs request
	ConfigurationJobs(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ConfigurationLanguages request
	ConfigurationLanguages(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ConfigurationPrimaryTranslations request
	ConfigurationPrimaryTranslations(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ConfigurationTimezones request
	ConfigurationTimezones(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreditDetails request
	CreditDetails(ctx context.Context, creditID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DiscoverMovie request
	DiscoverMovie(ctx context.Context, params *DiscoverMovieParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DiscoverTv request
	DiscoverTv(ctx context.Context, params *DiscoverTvParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindByID request
	FindByID(ctx context.Context, externalID string, params *FindByIDParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GenreMovieList request
	GenreMovieList(ctx context.Context, params *GenreMovieListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GenreTvList request
	GenreTvList(ctx context.Context, params *GenreTvListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GuestSessionRatedMovies request
	GuestSessionRatedMovies(ctx context.Context, guestSessionID string, params *GuestSessionRatedMoviesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GuestSessionRatedTv request
	GuestSessionRatedTv(ctx context.Context, guestSessionID string, params *GuestSessionRatedTvParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GuestSessionRatedTvEpisodes request
	GuestSessionRatedTvEpisodes(ctx context.Context, guestSessionID string, params *GuestSessionRatedTvEpisodesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// KeywordDetails request
	KeywordDetails(ctx context.Context, keywordID int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// KeywordMovies request
	KeywordMovies(ctx context.Context, keywordID string, params *KeywordMoviesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListCreateWithBody request with any body
	ListCreateWithBody(ctx context.Context, params *ListCreateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ListCreate(ctx context.Context, params *ListCreateParams, body ListCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListDelete request
	ListDelete(ctx context.Context, listID int32, params *ListDeleteParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListDetails request
	ListDetails(ctx context.Context, listID int32, params *ListDetailsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAddMovieWithBody request with any body
	ListAddMovieWithBody(ctx context.Context, listID int32, params *ListAddMovieParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ListAddMovie(ctx context.Context, listID int32, params *ListAddMovieParams, body ListAddMovieJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListClear request
	ListClear(ctx context.Context, listID int32, params *ListClearParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListCheckItemStatus request
	ListCheckItemStatus(ctx context.Context, listID int32, params *ListCheckItemStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListRemoveMovieWithBody request with any body
	ListRemoveMovieWithBody(ctx context.Context, listID int32, params *ListRemoveMovieParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ListRemoveMovie(ctx context.Context, listID int32, params *ListRemoveMovieParams, body ListRemoveMovieJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ChangesMovieList request
	ChangesMovieList(ctx context.Context, params *ChangesMovieListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MovieLatestID request
	MovieLatestID(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MovieNowPlayingList request
	MovieNowPlayingList(ctx context.Context, params *MovieNowPlayingListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MoviePopularList request
	MoviePopularList(ctx context.Context, params *MoviePopularListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MovieTopRatedList request
	MovieTopRatedList(ctx context.Context, params *MovieTopRatedListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MovieUpcomingList request
	MovieUpcomingList(ctx context.Context, params *MovieUpcomingListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MovieDetails request
	MovieDetails(ctx context.Context, movieID int32, params *MovieDetailsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MovieAccountStates request
	MovieAccountStates(ctx context.Context, movieID int32, params *MovieAccountStatesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MovieAlternativeTitles request
	MovieAlternativeTitles(ctx context.Context, movieID int32, params *MovieAlternativeTitlesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MovieChanges request
	MovieChanges(ctx context.Context, movieID int32, params *MovieChangesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MovieCredits request
	MovieCredits(ctx context.Context, movieID int32, params *MovieCreditsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MovieExternalIds request
	MovieExternalIds(ctx context.Context, movieID int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MovieImages request
	MovieImages(ctx context.Context, movieID int32, params *MovieImagesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MovieKeywords request
	MovieKeywords(ctx context.Context, movieID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MovieLists request
	MovieLists(ctx context.Context, movieID int32, params *MovieListsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MovieDeleteRating request
	MovieDeleteRating(ctx context.Context, movieID int32, params *MovieDeleteRatingParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MovieAddRatingWithBody request with any body
	MovieAddRatingWithBody(ctx context.Context, movieID int32, params *MovieAddRatingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MovieAddRating(ctx context.Context, movieID int32, params *MovieAddRatingParams, body MovieAddRatingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MovieRecommendations request
	MovieRecommendations(ctx context.Context, movieID int32, params *MovieRecommendationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MovieReleaseDates request
	MovieReleaseDates(ctx context.Context, movieID int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MovieReviews request
	MovieReviews(ctx context.Context, movieID int32, params *MovieReviewsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MovieSimilar request
	MovieSimilar(ctx context.Context, movieID int32, params *MovieSimilarParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MovieTranslations request
	MovieTranslations(ctx context.Context, movieID int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MovieVideos request
	MovieVideos(ctx context.Context, movieID int32, params *MovieVideosParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MovieWatchProviders request
	MovieWatchProviders(ctx context.Context, movieID int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NetworkDetails request
	NetworkDetails(ctx context.Context, networkID int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DetailsCopy request
	DetailsCopy(ctx context.Context, networkID int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AlternativeNamesCopy request
	AlternativeNamesCopy(ctx context.Context, networkID int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ChangesPeopleList request
	ChangesPeopleList(ctx context.Context, params *ChangesPeopleListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersonLatestID request
	PersonLatestID(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersonPopularList request
	PersonPopularList(ctx context.Context, params *PersonPopularListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersonDetails request
	PersonDetails(ctx context.Context, personID int32, params *PersonDetailsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersonChanges request
	PersonChanges(ctx context.Context, personID int32, params *PersonChangesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersonCombinedCredits request
	PersonCombinedCredits(ctx context.Context, personID string, params *PersonCombinedCreditsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersonExternalIds request
	PersonExternalIds(ctx context.Context, personID int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersonImages request
	PersonImages(ctx context.Context, personID int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersonMovieCredits request
	PersonMovieCredits(ctx context.Context, personID int32, params *PersonMovieCreditsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersonTaggedImages request
	PersonTaggedImages(ctx context.Context, personID int32, params *PersonTaggedImagesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Translations request
	Translations(ctx context.Context, personID int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersonTvCredits request
	PersonTvCredits(ctx context.Context, personID int32, params *PersonTvCreditsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReviewDetails request
	ReviewDetails(ctx context.Context, reviewID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchCollection request
	SearchCollection(ctx context.Context, params *SearchCollectionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchCompany request
	SearchCompany(ctx context.Context, params *SearchCompanyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchKeyword request
	SearchKeyword(ctx context.Context, params *SearchKeywordParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchMovie request
	SearchMovie(ctx context.Context, params *SearchMovieParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchMulti request
	SearchMulti(ctx context.Context, params *SearchMultiParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchPerson request
	SearchPerson(ctx context.Context, params *SearchPersonParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchTv request
	SearchTv(ctx context.Context, params *SearchTvParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TrendingAll request
	TrendingAll(ctx context.Context, timeWindow TrendingAllParamsTimeWindow, params *TrendingAllParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TrendingMovies request
	TrendingMovies(ctx context.Context, timeWindow TrendingMoviesParamsTimeWindow, params *TrendingMoviesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TrendingPeople request
	TrendingPeople(ctx context.Context, timeWindow TrendingPeopleParamsTimeWindow, params *TrendingPeopleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TrendingTv request
	TrendingTv(ctx context.Context, timeWindow TrendingTvParamsTimeWindow, params *TrendingTvParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TvSeriesAiringTodayList request
	TvSeriesAiringTodayList(ctx context.Context, params *TvSeriesAiringTodayListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ChangesTvList request
	ChangesTvList(ctx context.Context, params *ChangesTvListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TvEpisodeChangesByID request
	TvEpisodeChangesByID(ctx context.Context, episodeID int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TvEpisodeGroupDetails request
	TvEpisodeGroupDetails(ctx context.Context, tvEpisodeGroupID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TvSeriesLatestID request
	TvSeriesLatestID(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TvSeriesOnTheAirList request
	TvSeriesOnTheAirList(ctx context.Context, params *TvSeriesOnTheAirListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TvSeriesPopularList request
	TvSeriesPopularList(ctx context.Context, params *TvSeriesPopularListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TvSeasonChangesByID request
	TvSeasonChangesByID(ctx context.Context, seasonID int32, params *TvSeasonChangesByIDParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TvSeriesTopRatedList request
	TvSeriesTopRatedList(ctx context.Context, params *TvSeriesTopRatedListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TvSeriesDetails request
	TvSeriesDetails(ctx context.Context, seriesID int32, params *TvSeriesDetailsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TvSeriesAccountStates request
	TvSeriesAccountStates(ctx context.Context, seriesID int32, params *TvSeriesAccountStatesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TvSeriesAggregateCredits request
	TvSeriesAggregateCredits(ctx context.Context, seriesID int32, params *TvSeriesAggregateCreditsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TvSeriesAlternativeTitles request
	TvSeriesAlternativeTitles(ctx context.Context, seriesID int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TvSeriesChanges request
	TvSeriesChanges(ctx context.Context, seriesID int32, params *TvSeriesChangesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TvSeriesContentRatings request
	TvSeriesContentRatings(ctx context.Context, seriesID int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TvSeriesCredits request
	TvSeriesCredits(ctx context.Context, seriesID int32, params *TvSeriesCreditsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TvSeriesEpisodeGroups request
	TvSeriesEpisodeGroups(ctx context.Context, seriesID int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TvSeriesExternalIds request
	TvSeriesExternalIds(ctx context.Context, seriesID int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TvSeriesImages request
	TvSeriesImages(ctx context.Context, seriesID int32, params *TvSeriesImagesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TvSeriesKeywords request
	TvSeriesKeywords(ctx context.Context, seriesID int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListsCopy request
	ListsCopy(ctx context.Context, seriesID int32, params *ListsCopyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TvSeriesDeleteRating request
	TvSeriesDeleteRating(ctx context.Context, seriesID int32, params *TvSeriesDeleteRatingParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TvSeriesAddRatingWithBody request with any body
	TvSeriesAddRatingWithBody(ctx context.Context, seriesID int32, params *TvSeriesAddRatingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TvSeriesAddRating(ctx context.Context, seriesID int32, params *TvSeriesAddRatingParams, body TvSeriesAddRatingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TvSeriesRecommendations request
	TvSeriesRecommendations(ctx context.Context, seriesID int32, params *TvSeriesRecommendationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TvSeriesReviews request
	TvSeriesReviews(ctx context.Context, seriesID int32, params *TvSeriesReviewsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TvSeriesScreenedTheatrically request
	TvSeriesScreenedTheatrically(ctx context.Context, seriesID int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TvSeasonDetails request
	TvSeasonDetails(ctx context.Context, seriesID int32, seasonNumber int32, params *TvSeasonDetailsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TvSeasonAccountStates request
	TvSeasonAccountStates(ctx context.Context, seriesID int32, seasonNumber int32, params *TvSeasonAccountStatesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TvSeasonAggregateCredits request
	TvSeasonAggregateCredits(ctx context.Context, seriesID int32, seasonNumber int32, params *TvSeasonAggregateCreditsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TvSeasonCredits request
	TvSeasonCredits(ctx context.Context, seriesID int32, seasonNumber int32, params *TvSeasonCreditsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TvEpisodeDetails request
	TvEpisodeDetails(ctx context.Context, seriesID int32, seasonNumber int32, episodeNumber int32, params *TvEpisodeDetailsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TvEpisodeAccountStates request
	TvEpisodeAccountStates(ctx context.Context, seriesID int32, seasonNumber int32, episodeNumber int32, params *TvEpisodeAccountStatesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TvEpisodeCredits request
	TvEpisodeCredits(ctx context.Context, seriesID int32, seasonNumber int32, episodeNumber int32, params *TvEpisodeCreditsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TvEpisodeExternalIds request
	TvEpisodeExternalIds(ctx context.Context, seriesID int32, seasonNumber int32, episodeNumber string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TvEpisodeImages request
	TvEpisodeImages(ctx context.Context, seriesID int32, seasonNumber int32, episodeNumber int32, params *TvEpisodeImagesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TvEpisodeDeleteRating request
	TvEpisodeDeleteRating(ctx context.Context, seriesID int32, seasonNumber int32, episodeNumber int32, params *TvEpisodeDeleteRatingParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TvEpisodeAddRatingWithBody request with any body
	TvEpisodeAddRatingWithBody(ctx context.Context, seriesID int32, seasonNumber int32, episodeNumber int32, params *TvEpisodeAddRatingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TvEpisodeAddRating(ctx context.Context, seriesID int32, seasonNumber int32, episodeNumber int32, params *TvEpisodeAddRatingParams, body TvEpisodeAddRatingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TvEpisodeTranslations request
	TvEpisodeTranslations(ctx context.Context, seriesID int32, seasonNumber int32, episodeNumber int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TvEpisodeVideos request
	TvEpisodeVideos(ctx context.Context, seriesID int32, seasonNumber int32, episodeNumber int32, params *TvEpisodeVideosParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TvSeasonExternalIds request
	TvSeasonExternalIds(ctx context.Context, seriesID int32, seasonNumber int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TvSeasonImages request
	TvSeasonImages(ctx context.Context, seriesID int32, seasonNumber int32, params *TvSeasonImagesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TvSeasonTranslations request
	TvSeasonTranslations(ctx context.Context, seriesID int32, seasonNumber int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TvSeasonVideos request
	TvSeasonVideos(ctx context.Context, seriesID int32, seasonNumber int32, params *TvSeasonVideosParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TvSeasonWatchProviders request
	TvSeasonWatchProviders(ctx context.Context, seriesID int32, seasonNumber int32, params *TvSeasonWatchProvidersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TvSeriesSimilar request
	TvSeriesSimilar(ctx context.Context, seriesID string, params *TvSeriesSimilarParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TvSeriesTranslations request
	TvSeriesTranslations(ctx context.Context, seriesID int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TvSeriesVideos request
	TvSeriesVideos(ctx context.Context, seriesID int32, params *TvSeriesVideosParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TvSeriesWatchProviders request
	TvSeriesWatchProviders(ctx context.Context, seriesID int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WatchProvidersMovieList request
	WatchProvidersMovieList(ctx context.Context, params *WatchProvidersMovieListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WatchProvidersAvailableRegions request
	WatchProvidersAvailableRegions(ctx context.Context, params *WatchProvidersAvailableRegionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WatchProviderTvList request
	WatchProviderTvList(ctx context.Context, params *WatchProviderTvListParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) AccountDetails(ctx context.Context, accountID int32, params *AccountDetailsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAccountDetailsRequest(c.Server, accountID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AccountAddFavoriteWithBody(ctx context.Context, accountID int32, params *AccountAddFavoriteParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAccountAddFavoriteRequestWithBody(c.Server, accountID, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AccountAddFavorite(ctx context.Context, accountID int32, params *AccountAddFavoriteParams, body AccountAddFavoriteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAccountAddFavoriteRequest(c.Server, accountID, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AccountGetFavorites(ctx context.Context, accountID int32, params *AccountGetFavoritesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAccountGetFavoritesRequest(c.Server, accountID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AccountFavoriteTv(ctx context.Context, accountID int32, params *AccountFavoriteTvParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAccountFavoriteTvRequest(c.Server, accountID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AccountLists(ctx context.Context, accountID int32, params *AccountListsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAccountListsRequest(c.Server, accountID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AccountRatedMovies(ctx context.Context, accountID int32, params *AccountRatedMoviesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAccountRatedMoviesRequest(c.Server, accountID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AccountRatedTv(ctx context.Context, accountID int32, params *AccountRatedTvParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAccountRatedTvRequest(c.Server, accountID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AccountRatedTvEpisodes(ctx context.Context, accountID int32, params *AccountRatedTvEpisodesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAccountRatedTvEpisodesRequest(c.Server, accountID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AccountAddToWatchlistWithBody(ctx context.Context, accountID int32, params *AccountAddToWatchlistParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAccountAddToWatchlistRequestWithBody(c.Server, accountID, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AccountAddToWatchlist(ctx context.Context, accountID int32, params *AccountAddToWatchlistParams, body AccountAddToWatchlistJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAccountAddToWatchlistRequest(c.Server, accountID, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AccountWatchlistMovies(ctx context.Context, accountID int32, params *AccountWatchlistMoviesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAccountWatchlistMoviesRequest(c.Server, accountID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AccountWatchlistTv(ctx context.Context, accountID int32, params *AccountWatchlistTvParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAccountWatchlistTvRequest(c.Server, accountID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthenticationValidateKey(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthenticationValidateKeyRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthenticationCreateGuestSession(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthenticationCreateGuestSessionRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthenticationDeleteSessionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthenticationDeleteSessionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthenticationDeleteSession(ctx context.Context, body AuthenticationDeleteSessionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthenticationDeleteSessionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthenticationCreateSessionFromV4TokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthenticationCreateSessionFromV4TokenRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthenticationCreateSessionFromV4Token(ctx context.Context, body AuthenticationCreateSessionFromV4TokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthenticationCreateSessionFromV4TokenRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthenticationCreateSessionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthenticationCreateSessionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthenticationCreateSession(ctx context.Context, body AuthenticationCreateSessionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthenticationCreateSessionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthenticationCreateRequestToken(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthenticationCreateRequestTokenRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthenticationCreateSessionFromLoginWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthenticationCreateSessionFromLoginRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthenticationCreateSessionFromLogin(ctx context.Context, body AuthenticationCreateSessionFromLoginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthenticationCreateSessionFromLoginRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CertificationMovieList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCertificationMovieListRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CertificationsTvList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCertificationsTvListRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CollectionDetails(ctx context.Context, collectionID int32, params *CollectionDetailsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCollectionDetailsRequest(c.Server, collectionID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CollectionImages(ctx context.Context, collectionID int32, params *CollectionImagesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCollectionImagesRequest(c.Server, collectionID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CollectionTranslations(ctx context.Context, collectionID int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCollectionTranslationsRequest(c.Server, collectionID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CompanyDetails(ctx context.Context, companyID int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCompanyDetailsRequest(c.Server, companyID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CompanyAlternativeNames(ctx context.Context, companyID int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCompanyAlternativeNamesRequest(c.Server, companyID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CompanyImages(ctx context.Context, companyID int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCompanyImagesRequest(c.Server, companyID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConfigurationDetails(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConfigurationDetailsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConfigurationCountries(ctx context.Context, params *ConfigurationCountriesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConfigurationCountriesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConfigurationJobs(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConfigurationJobsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConfigurationLanguages(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConfigurationLanguagesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConfigurationPrimaryTranslations(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConfigurationPrimaryTranslationsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConfigurationTimezones(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConfigurationTimezonesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreditDetails(ctx context.Context, creditID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreditDetailsRequest(c.Server, creditID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DiscoverMovie(ctx context.Context, params *DiscoverMovieParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDiscoverMovieRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DiscoverTv(ctx context.Context, params *DiscoverTvParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDiscoverTvRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindByID(ctx context.Context, externalID string, params *FindByIDParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindByIDRequest(c.Server, externalID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenreMovieList(ctx context.Context, params *GenreMovieListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenreMovieListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenreTvList(ctx context.Context, params *GenreTvListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenreTvListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GuestSessionRatedMovies(ctx context.Context, guestSessionID string, params *GuestSessionRatedMoviesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGuestSessionRatedMoviesRequest(c.Server, guestSessionID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GuestSessionRatedTv(ctx context.Context, guestSessionID string, params *GuestSessionRatedTvParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGuestSessionRatedTvRequest(c.Server, guestSessionID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GuestSessionRatedTvEpisodes(ctx context.Context, guestSessionID string, params *GuestSessionRatedTvEpisodesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGuestSessionRatedTvEpisodesRequest(c.Server, guestSessionID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) KeywordDetails(ctx context.Context, keywordID int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewKeywordDetailsRequest(c.Server, keywordID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) KeywordMovies(ctx context.Context, keywordID string, params *KeywordMoviesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewKeywordMoviesRequest(c.Server, keywordID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListCreateWithBody(ctx context.Context, params *ListCreateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListCreateRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListCreate(ctx context.Context, params *ListCreateParams, body ListCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListCreateRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListDelete(ctx context.Context, listID int32, params *ListDeleteParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListDeleteRequest(c.Server, listID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListDetails(ctx context.Context, listID int32, params *ListDetailsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListDetailsRequest(c.Server, listID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAddMovieWithBody(ctx context.Context, listID int32, params *ListAddMovieParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAddMovieRequestWithBody(c.Server, listID, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAddMovie(ctx context.Context, listID int32, params *ListAddMovieParams, body ListAddMovieJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAddMovieRequest(c.Server, listID, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListClear(ctx context.Context, listID int32, params *ListClearParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListClearRequest(c.Server, listID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListCheckItemStatus(ctx context.Context, listID int32, params *ListCheckItemStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListCheckItemStatusRequest(c.Server, listID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListRemoveMovieWithBody(ctx context.Context, listID int32, params *ListRemoveMovieParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListRemoveMovieRequestWithBody(c.Server, listID, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListRemoveMovie(ctx context.Context, listID int32, params *ListRemoveMovieParams, body ListRemoveMovieJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListRemoveMovieRequest(c.Server, listID, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ChangesMovieList(ctx context.Context, params *ChangesMovieListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewChangesMovieListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MovieLatestID(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMovieLatestIDRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MovieNowPlayingList(ctx context.Context, params *MovieNowPlayingListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMovieNowPlayingListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MoviePopularList(ctx context.Context, params *MoviePopularListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMoviePopularListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MovieTopRatedList(ctx context.Context, params *MovieTopRatedListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMovieTopRatedListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MovieUpcomingList(ctx context.Context, params *MovieUpcomingListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMovieUpcomingListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MovieDetails(ctx context.Context, movieID int32, params *MovieDetailsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMovieDetailsRequest(c.Server, movieID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MovieAccountStates(ctx context.Context, movieID int32, params *MovieAccountStatesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMovieAccountStatesRequest(c.Server, movieID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MovieAlternativeTitles(ctx context.Context, movieID int32, params *MovieAlternativeTitlesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMovieAlternativeTitlesRequest(c.Server, movieID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MovieChanges(ctx context.Context, movieID int32, params *MovieChangesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMovieChangesRequest(c.Server, movieID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MovieCredits(ctx context.Context, movieID int32, params *MovieCreditsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMovieCreditsRequest(c.Server, movieID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MovieExternalIds(ctx context.Context, movieID int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMovieExternalIdsRequest(c.Server, movieID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MovieImages(ctx context.Context, movieID int32, params *MovieImagesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMovieImagesRequest(c.Server, movieID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MovieKeywords(ctx context.Context, movieID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMovieKeywordsRequest(c.Server, movieID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MovieLists(ctx context.Context, movieID int32, params *MovieListsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMovieListsRequest(c.Server, movieID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MovieDeleteRating(ctx context.Context, movieID int32, params *MovieDeleteRatingParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMovieDeleteRatingRequest(c.Server, movieID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MovieAddRatingWithBody(ctx context.Context, movieID int32, params *MovieAddRatingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMovieAddRatingRequestWithBody(c.Server, movieID, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MovieAddRating(ctx context.Context, movieID int32, params *MovieAddRatingParams, body MovieAddRatingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMovieAddRatingRequest(c.Server, movieID, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MovieRecommendations(ctx context.Context, movieID int32, params *MovieRecommendationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMovieRecommendationsRequest(c.Server, movieID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MovieReleaseDates(ctx context.Context, movieID int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMovieReleaseDatesRequest(c.Server, movieID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MovieReviews(ctx context.Context, movieID int32, params *MovieReviewsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMovieReviewsRequest(c.Server, movieID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MovieSimilar(ctx context.Context, movieID int32, params *MovieSimilarParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMovieSimilarRequest(c.Server, movieID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MovieTranslations(ctx context.Context, movieID int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMovieTranslationsRequest(c.Server, movieID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MovieVideos(ctx context.Context, movieID int32, params *MovieVideosParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMovieVideosRequest(c.Server, movieID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MovieWatchProviders(ctx context.Context, movieID int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMovieWatchProvidersRequest(c.Server, movieID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NetworkDetails(ctx context.Context, networkID int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNetworkDetailsRequest(c.Server, networkID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DetailsCopy(ctx context.Context, networkID int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDetailsCopyRequest(c.Server, networkID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AlternativeNamesCopy(ctx context.Context, networkID int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAlternativeNamesCopyRequest(c.Server, networkID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ChangesPeopleList(ctx context.Context, params *ChangesPeopleListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewChangesPeopleListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersonLatestID(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersonLatestIDRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersonPopularList(ctx context.Context, params *PersonPopularListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersonPopularListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersonDetails(ctx context.Context, personID int32, params *PersonDetailsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersonDetailsRequest(c.Server, personID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersonChanges(ctx context.Context, personID int32, params *PersonChangesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersonChangesRequest(c.Server, personID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersonCombinedCredits(ctx context.Context, personID string, params *PersonCombinedCreditsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersonCombinedCreditsRequest(c.Server, personID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersonExternalIds(ctx context.Context, personID int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersonExternalIdsRequest(c.Server, personID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersonImages(ctx context.Context, personID int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersonImagesRequest(c.Server, personID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersonMovieCredits(ctx context.Context, personID int32, params *PersonMovieCreditsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersonMovieCreditsRequest(c.Server, personID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersonTaggedImages(ctx context.Context, personID int32, params *PersonTaggedImagesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersonTaggedImagesRequest(c.Server, personID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Translations(ctx context.Context, personID int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTranslationsRequest(c.Server, personID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersonTvCredits(ctx context.Context, personID int32, params *PersonTvCreditsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersonTvCreditsRequest(c.Server, personID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReviewDetails(ctx context.Context, reviewID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReviewDetailsRequest(c.Server, reviewID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchCollection(ctx context.Context, params *SearchCollectionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchCollectionRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchCompany(ctx context.Context, params *SearchCompanyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchCompanyRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchKeyword(ctx context.Context, params *SearchKeywordParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchKeywordRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchMovie(ctx context.Context, params *SearchMovieParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchMovieRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchMulti(ctx context.Context, params *SearchMultiParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchMultiRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchPerson(ctx context.Context, params *SearchPersonParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchPersonRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchTv(ctx context.Context, params *SearchTvParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchTvRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TrendingAll(ctx context.Context, timeWindow TrendingAllParamsTimeWindow, params *TrendingAllParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTrendingAllRequest(c.Server, timeWindow, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TrendingMovies(ctx context.Context, timeWindow TrendingMoviesParamsTimeWindow, params *TrendingMoviesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTrendingMoviesRequest(c.Server, timeWindow, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TrendingPeople(ctx context.Context, timeWindow TrendingPeopleParamsTimeWindow, params *TrendingPeopleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTrendingPeopleRequest(c.Server, timeWindow, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TrendingTv(ctx context.Context, timeWindow TrendingTvParamsTimeWindow, params *TrendingTvParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTrendingTvRequest(c.Server, timeWindow, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TvSeriesAiringTodayList(ctx context.Context, params *TvSeriesAiringTodayListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTvSeriesAiringTodayListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ChangesTvList(ctx context.Context, params *ChangesTvListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewChangesTvListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TvEpisodeChangesByID(ctx context.Context, episodeID int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTvEpisodeChangesByIDRequest(c.Server, episodeID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TvEpisodeGroupDetails(ctx context.Context, tvEpisodeGroupID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTvEpisodeGroupDetailsRequest(c.Server, tvEpisodeGroupID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TvSeriesLatestID(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTvSeriesLatestIDRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TvSeriesOnTheAirList(ctx context.Context, params *TvSeriesOnTheAirListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTvSeriesOnTheAirListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TvSeriesPopularList(ctx context.Context, params *TvSeriesPopularListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTvSeriesPopularListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TvSeasonChangesByID(ctx context.Context, seasonID int32, params *TvSeasonChangesByIDParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTvSeasonChangesByIDRequest(c.Server, seasonID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TvSeriesTopRatedList(ctx context.Context, params *TvSeriesTopRatedListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTvSeriesTopRatedListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TvSeriesDetails(ctx context.Context, seriesID int32, params *TvSeriesDetailsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTvSeriesDetailsRequest(c.Server, seriesID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TvSeriesAccountStates(ctx context.Context, seriesID int32, params *TvSeriesAccountStatesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTvSeriesAccountStatesRequest(c.Server, seriesID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TvSeriesAggregateCredits(ctx context.Context, seriesID int32, params *TvSeriesAggregateCreditsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTvSeriesAggregateCreditsRequest(c.Server, seriesID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TvSeriesAlternativeTitles(ctx context.Context, seriesID int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTvSeriesAlternativeTitlesRequest(c.Server, seriesID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TvSeriesChanges(ctx context.Context, seriesID int32, params *TvSeriesChangesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTvSeriesChangesRequest(c.Server, seriesID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TvSeriesContentRatings(ctx context.Context, seriesID int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTvSeriesContentRatingsRequest(c.Server, seriesID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TvSeriesCredits(ctx context.Context, seriesID int32, params *TvSeriesCreditsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTvSeriesCreditsRequest(c.Server, seriesID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TvSeriesEpisodeGroups(ctx context.Context, seriesID int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTvSeriesEpisodeGroupsRequest(c.Server, seriesID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TvSeriesExternalIds(ctx context.Context, seriesID int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTvSeriesExternalIdsRequest(c.Server, seriesID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TvSeriesImages(ctx context.Context, seriesID int32, params *TvSeriesImagesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTvSeriesImagesRequest(c.Server, seriesID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TvSeriesKeywords(ctx context.Context, seriesID int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTvSeriesKeywordsRequest(c.Server, seriesID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListsCopy(ctx context.Context, seriesID int32, params *ListsCopyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListsCopyRequest(c.Server, seriesID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TvSeriesDeleteRating(ctx context.Context, seriesID int32, params *TvSeriesDeleteRatingParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTvSeriesDeleteRatingRequest(c.Server, seriesID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TvSeriesAddRatingWithBody(ctx context.Context, seriesID int32, params *TvSeriesAddRatingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTvSeriesAddRatingRequestWithBody(c.Server, seriesID, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TvSeriesAddRating(ctx context.Context, seriesID int32, params *TvSeriesAddRatingParams, body TvSeriesAddRatingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTvSeriesAddRatingRequest(c.Server, seriesID, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TvSeriesRecommendations(ctx context.Context, seriesID int32, params *TvSeriesRecommendationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTvSeriesRecommendationsRequest(c.Server, seriesID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TvSeriesReviews(ctx context.Context, seriesID int32, params *TvSeriesReviewsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTvSeriesReviewsRequest(c.Server, seriesID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TvSeriesScreenedTheatrically(ctx context.Context, seriesID int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTvSeriesScreenedTheatricallyRequest(c.Server, seriesID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TvSeasonDetails(ctx context.Context, seriesID int32, seasonNumber int32, params *TvSeasonDetailsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTvSeasonDetailsRequest(c.Server, seriesID, seasonNumber, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TvSeasonAccountStates(ctx context.Context, seriesID int32, seasonNumber int32, params *TvSeasonAccountStatesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTvSeasonAccountStatesRequest(c.Server, seriesID, seasonNumber, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TvSeasonAggregateCredits(ctx context.Context, seriesID int32, seasonNumber int32, params *TvSeasonAggregateCreditsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTvSeasonAggregateCreditsRequest(c.Server, seriesID, seasonNumber, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TvSeasonCredits(ctx context.Context, seriesID int32, seasonNumber int32, params *TvSeasonCreditsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTvSeasonCreditsRequest(c.Server, seriesID, seasonNumber, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TvEpisodeDetails(ctx context.Context, seriesID int32, seasonNumber int32, episodeNumber int32, params *TvEpisodeDetailsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTvEpisodeDetailsRequest(c.Server, seriesID, seasonNumber, episodeNumber, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TvEpisodeAccountStates(ctx context.Context, seriesID int32, seasonNumber int32, episodeNumber int32, params *TvEpisodeAccountStatesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTvEpisodeAccountStatesRequest(c.Server, seriesID, seasonNumber, episodeNumber, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TvEpisodeCredits(ctx context.Context, seriesID int32, seasonNumber int32, episodeNumber int32, params *TvEpisodeCreditsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTvEpisodeCreditsRequest(c.Server, seriesID, seasonNumber, episodeNumber, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TvEpisodeExternalIds(ctx context.Context, seriesID int32, seasonNumber int32, episodeNumber string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTvEpisodeExternalIdsRequest(c.Server, seriesID, seasonNumber, episodeNumber)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TvEpisodeImages(ctx context.Context, seriesID int32, seasonNumber int32, episodeNumber int32, params *TvEpisodeImagesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTvEpisodeImagesRequest(c.Server, seriesID, seasonNumber, episodeNumber, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TvEpisodeDeleteRating(ctx context.Context, seriesID int32, seasonNumber int32, episodeNumber int32, params *TvEpisodeDeleteRatingParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTvEpisodeDeleteRatingRequest(c.Server, seriesID, seasonNumber, episodeNumber, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TvEpisodeAddRatingWithBody(ctx context.Context, seriesID int32, seasonNumber int32, episodeNumber int32, params *TvEpisodeAddRatingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTvEpisodeAddRatingRequestWithBody(c.Server, seriesID, seasonNumber, episodeNumber, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TvEpisodeAddRating(ctx context.Context, seriesID int32, seasonNumber int32, episodeNumber int32, params *TvEpisodeAddRatingParams, body TvEpisodeAddRatingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTvEpisodeAddRatingRequest(c.Server, seriesID, seasonNumber, episodeNumber, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TvEpisodeTranslations(ctx context.Context, seriesID int32, seasonNumber int32, episodeNumber int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTvEpisodeTranslationsRequest(c.Server, seriesID, seasonNumber, episodeNumber)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TvEpisodeVideos(ctx context.Context, seriesID int32, seasonNumber int32, episodeNumber int32, params *TvEpisodeVideosParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTvEpisodeVideosRequest(c.Server, seriesID, seasonNumber, episodeNumber, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TvSeasonExternalIds(ctx context.Context, seriesID int32, seasonNumber int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTvSeasonExternalIdsRequest(c.Server, seriesID, seasonNumber)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TvSeasonImages(ctx context.Context, seriesID int32, seasonNumber int32, params *TvSeasonImagesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTvSeasonImagesRequest(c.Server, seriesID, seasonNumber, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TvSeasonTranslations(ctx context.Context, seriesID int32, seasonNumber int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTvSeasonTranslationsRequest(c.Server, seriesID, seasonNumber)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TvSeasonVideos(ctx context.Context, seriesID int32, seasonNumber int32, params *TvSeasonVideosParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTvSeasonVideosRequest(c.Server, seriesID, seasonNumber, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TvSeasonWatchProviders(ctx context.Context, seriesID int32, seasonNumber int32, params *TvSeasonWatchProvidersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTvSeasonWatchProvidersRequest(c.Server, seriesID, seasonNumber, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TvSeriesSimilar(ctx context.Context, seriesID string, params *TvSeriesSimilarParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTvSeriesSimilarRequest(c.Server, seriesID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TvSeriesTranslations(ctx context.Context, seriesID int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTvSeriesTranslationsRequest(c.Server, seriesID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TvSeriesVideos(ctx context.Context, seriesID int32, params *TvSeriesVideosParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTvSeriesVideosRequest(c.Server, seriesID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TvSeriesWatchProviders(ctx context.Context, seriesID int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTvSeriesWatchProvidersRequest(c.Server, seriesID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WatchProvidersMovieList(ctx context.Context, params *WatchProvidersMovieListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWatchProvidersMovieListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WatchProvidersAvailableRegions(ctx context.Context, params *WatchProvidersAvailableRegionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWatchProvidersAvailableRegionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WatchProviderTvList(ctx context.Context, params *WatchProviderTvListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWatchProviderTvListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewAccountDetailsRequest generates requests for AccountDetails
func NewAccountDetailsRequest(server string, accountID int32, params *AccountDetailsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "account_id", runtime.ParamLocationPath, accountID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/account/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SessionID != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "session_id", runtime.ParamLocationQuery, *params.SessionID); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAccountAddFavoriteRequest calls the generic AccountAddFavorite builder with application/json body
func NewAccountAddFavoriteRequest(server string, accountID int32, params *AccountAddFavoriteParams, body AccountAddFavoriteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAccountAddFavoriteRequestWithBody(server, accountID, params, "application/json", bodyReader)
}

// NewAccountAddFavoriteRequestWithBody generates requests for AccountAddFavorite with any type of body
func NewAccountAddFavoriteRequestWithBody(server string, accountID int32, params *AccountAddFavoriteParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "account_id", runtime.ParamLocationPath, accountID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/account/%s/favorite", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SessionID != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "session_id", runtime.ParamLocationQuery, *params.SessionID); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAccountGetFavoritesRequest generates requests for AccountGetFavorites
func NewAccountGetFavoritesRequest(server string, accountID int32, params *AccountGetFavoritesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "account_id", runtime.ParamLocationPath, accountID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/account/%s/favorite/movies", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Language != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, *params.Language); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SessionID != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "session_id", runtime.ParamLocationQuery, *params.SessionID); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAccountFavoriteTvRequest generates requests for AccountFavoriteTv
func NewAccountFavoriteTvRequest(server string, accountID int32, params *AccountFavoriteTvParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "account_id", runtime.ParamLocationPath, accountID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/account/%s/favorite/tv", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Language != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, *params.Language); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SessionID != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "session_id", runtime.ParamLocationQuery, *params.SessionID); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAccountListsRequest generates requests for AccountLists
func NewAccountListsRequest(server string, accountID int32, params *AccountListsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "account_id", runtime.ParamLocationPath, accountID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/account/%s/lists", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SessionID != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "session_id", runtime.ParamLocationQuery, *params.SessionID); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAccountRatedMoviesRequest generates requests for AccountRatedMovies
func NewAccountRatedMoviesRequest(server string, accountID int32, params *AccountRatedMoviesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "account_id", runtime.ParamLocationPath, accountID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/account/%s/rated/movies", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Language != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, *params.Language); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SessionID != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "session_id", runtime.ParamLocationQuery, *params.SessionID); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAccountRatedTvRequest generates requests for AccountRatedTv
func NewAccountRatedTvRequest(server string, accountID int32, params *AccountRatedTvParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "account_id", runtime.ParamLocationPath, accountID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/account/%s/rated/tv", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Language != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, *params.Language); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SessionID != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "session_id", runtime.ParamLocationQuery, *params.SessionID); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAccountRatedTvEpisodesRequest generates requests for AccountRatedTvEpisodes
func NewAccountRatedTvEpisodesRequest(server string, accountID int32, params *AccountRatedTvEpisodesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "account_id", runtime.ParamLocationPath, accountID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/account/%s/rated/tv/episodes", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Language != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, *params.Language); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SessionID != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "session_id", runtime.ParamLocationQuery, *params.SessionID); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAccountAddToWatchlistRequest calls the generic AccountAddToWatchlist builder with application/json body
func NewAccountAddToWatchlistRequest(server string, accountID int32, params *AccountAddToWatchlistParams, body AccountAddToWatchlistJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAccountAddToWatchlistRequestWithBody(server, accountID, params, "application/json", bodyReader)
}

// NewAccountAddToWatchlistRequestWithBody generates requests for AccountAddToWatchlist with any type of body
func NewAccountAddToWatchlistRequestWithBody(server string, accountID int32, params *AccountAddToWatchlistParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "account_id", runtime.ParamLocationPath, accountID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/account/%s/watchlist", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SessionID != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "session_id", runtime.ParamLocationQuery, *params.SessionID); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAccountWatchlistMoviesRequest generates requests for AccountWatchlistMovies
func NewAccountWatchlistMoviesRequest(server string, accountID int32, params *AccountWatchlistMoviesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "account_id", runtime.ParamLocationPath, accountID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/account/%s/watchlist/movies", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Language != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, *params.Language); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SessionID != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "session_id", runtime.ParamLocationQuery, *params.SessionID); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAccountWatchlistTvRequest generates requests for AccountWatchlistTv
func NewAccountWatchlistTvRequest(server string, accountID int32, params *AccountWatchlistTvParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "account_id", runtime.ParamLocationPath, accountID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/account/%s/watchlist/tv", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Language != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, *params.Language); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SessionID != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "session_id", runtime.ParamLocationQuery, *params.SessionID); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAuthenticationValidateKeyRequest generates requests for AuthenticationValidateKey
func NewAuthenticationValidateKeyRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/authentication")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAuthenticationCreateGuestSessionRequest generates requests for AuthenticationCreateGuestSession
func NewAuthenticationCreateGuestSessionRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/authentication/guest_session/new")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAuthenticationDeleteSessionRequest calls the generic AuthenticationDeleteSession builder with application/json body
func NewAuthenticationDeleteSessionRequest(server string, body AuthenticationDeleteSessionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAuthenticationDeleteSessionRequestWithBody(server, "application/json", bodyReader)
}

// NewAuthenticationDeleteSessionRequestWithBody generates requests for AuthenticationDeleteSession with any type of body
func NewAuthenticationDeleteSessionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/authentication/session")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAuthenticationCreateSessionFromV4TokenRequest calls the generic AuthenticationCreateSessionFromV4Token builder with application/json body
func NewAuthenticationCreateSessionFromV4TokenRequest(server string, body AuthenticationCreateSessionFromV4TokenJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAuthenticationCreateSessionFromV4TokenRequestWithBody(server, "application/json", bodyReader)
}

// NewAuthenticationCreateSessionFromV4TokenRequestWithBody generates requests for AuthenticationCreateSessionFromV4Token with any type of body
func NewAuthenticationCreateSessionFromV4TokenRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/authentication/session/convert/4")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAuthenticationCreateSessionRequest calls the generic AuthenticationCreateSession builder with application/json body
func NewAuthenticationCreateSessionRequest(server string, body AuthenticationCreateSessionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAuthenticationCreateSessionRequestWithBody(server, "application/json", bodyReader)
}

// NewAuthenticationCreateSessionRequestWithBody generates requests for AuthenticationCreateSession with any type of body
func NewAuthenticationCreateSessionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/authentication/session/new")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAuthenticationCreateRequestTokenRequest generates requests for AuthenticationCreateRequestToken
func NewAuthenticationCreateRequestTokenRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/authentication/token/new")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAuthenticationCreateSessionFromLoginRequest calls the generic AuthenticationCreateSessionFromLogin builder with application/json body
func NewAuthenticationCreateSessionFromLoginRequest(server string, body AuthenticationCreateSessionFromLoginJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAuthenticationCreateSessionFromLoginRequestWithBody(server, "application/json", bodyReader)
}

// NewAuthenticationCreateSessionFromLoginRequestWithBody generates requests for AuthenticationCreateSessionFromLogin with any type of body
func NewAuthenticationCreateSessionFromLoginRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/authentication/token/validate_with_login")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCertificationMovieListRequest generates requests for CertificationMovieList
func NewCertificationMovieListRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/certification/movie/list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCertificationsTvListRequest generates requests for CertificationsTvList
func NewCertificationsTvListRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/certification/tv/list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCollectionDetailsRequest generates requests for CollectionDetails
func NewCollectionDetailsRequest(server string, collectionID int32, params *CollectionDetailsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "collection_id", runtime.ParamLocationPath, collectionID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/collection/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Language != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, *params.Language); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCollectionImagesRequest generates requests for CollectionImages
func NewCollectionImagesRequest(server string, collectionID int32, params *CollectionImagesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "collection_id", runtime.ParamLocationPath, collectionID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/collection/%s/images", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IncludeImageLanguage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_image_language", runtime.ParamLocationQuery, *params.IncludeImageLanguage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Language != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, *params.Language); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCollectionTranslationsRequest generates requests for CollectionTranslations
func NewCollectionTranslationsRequest(server string, collectionID int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "collection_id", runtime.ParamLocationPath, collectionID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/collection/%s/translations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCompanyDetailsRequest generates requests for CompanyDetails
func NewCompanyDetailsRequest(server string, companyID int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "company_id", runtime.ParamLocationPath, companyID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/company/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCompanyAlternativeNamesRequest generates requests for CompanyAlternativeNames
func NewCompanyAlternativeNamesRequest(server string, companyID int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "company_id", runtime.ParamLocationPath, companyID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/company/%s/alternative_names", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCompanyImagesRequest generates requests for CompanyImages
func NewCompanyImagesRequest(server string, companyID int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "company_id", runtime.ParamLocationPath, companyID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/company/%s/images", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewConfigurationDetailsRequest generates requests for ConfigurationDetails
func NewConfigurationDetailsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/configuration")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewConfigurationCountriesRequest generates requests for ConfigurationCountries
func NewConfigurationCountriesRequest(server string, params *ConfigurationCountriesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/configuration/countries")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Language != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, *params.Language); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewConfigurationJobsRequest generates requests for ConfigurationJobs
func NewConfigurationJobsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/configuration/jobs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewConfigurationLanguagesRequest generates requests for ConfigurationLanguages
func NewConfigurationLanguagesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/configuration/languages")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewConfigurationPrimaryTranslationsRequest generates requests for ConfigurationPrimaryTranslations
func NewConfigurationPrimaryTranslationsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/configuration/primary_translations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewConfigurationTimezonesRequest generates requests for ConfigurationTimezones
func NewConfigurationTimezonesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/configuration/timezones")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreditDetailsRequest generates requests for CreditDetails
func NewCreditDetailsRequest(server string, creditID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "credit_id", runtime.ParamLocationPath, creditID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/credit/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDiscoverMovieRequest generates requests for DiscoverMovie
func NewDiscoverMovieRequest(server string, params *DiscoverMovieParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/discover/movie")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Certification != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "certification", runtime.ParamLocationQuery, *params.Certification); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CertificationGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "certification.gte", runtime.ParamLocationQuery, *params.CertificationGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CertificationLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "certification.lte", runtime.ParamLocationQuery, *params.CertificationLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CertificationCountry != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "certification_country", runtime.ParamLocationQuery, *params.CertificationCountry); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeAdult != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_adult", runtime.ParamLocationQuery, *params.IncludeAdult); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeVideo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_video", runtime.ParamLocationQuery, *params.IncludeVideo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Language != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, *params.Language); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PrimaryReleaseYear != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "primary_release_year", runtime.ParamLocationQuery, *params.PrimaryReleaseYear); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PrimaryReleaseDateGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "primary_release_date.gte", runtime.ParamLocationQuery, *params.PrimaryReleaseDateGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PrimaryReleaseDateLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "primary_release_date.lte", runtime.ParamLocationQuery, *params.PrimaryReleaseDateLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Region != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "region", runtime.ParamLocationQuery, *params.Region); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ReleaseDateGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "release_date.gte", runtime.ParamLocationQuery, *params.ReleaseDateGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ReleaseDateLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "release_date.lte", runtime.ParamLocationQuery, *params.ReleaseDateLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VoteAverageGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "vote_average.gte", runtime.ParamLocationQuery, *params.VoteAverageGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VoteAverageLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "vote_average.lte", runtime.ParamLocationQuery, *params.VoteAverageLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VoteCountGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "vote_count.gte", runtime.ParamLocationQuery, *params.VoteCountGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VoteCountLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "vote_count.lte", runtime.ParamLocationQuery, *params.VoteCountLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WatchRegion != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "watch_region", runtime.ParamLocationQuery, *params.WatchRegion); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithCast != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "with_cast", runtime.ParamLocationQuery, *params.WithCast); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithCompanies != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "with_companies", runtime.ParamLocationQuery, *params.WithCompanies); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithCrew != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "with_crew", runtime.ParamLocationQuery, *params.WithCrew); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithGenres != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "with_genres", runtime.ParamLocationQuery, *params.WithGenres); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithKeywords != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "with_keywords", runtime.ParamLocationQuery, *params.WithKeywords); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithOriginCountry != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "with_origin_country", runtime.ParamLocationQuery, *params.WithOriginCountry); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithOriginalLanguage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "with_original_language", runtime.ParamLocationQuery, *params.WithOriginalLanguage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithPeople != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "with_people", runtime.ParamLocationQuery, *params.WithPeople); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithReleaseType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "with_release_type", runtime.ParamLocationQuery, *params.WithReleaseType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithRuntimeGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "with_runtime.gte", runtime.ParamLocationQuery, *params.WithRuntimeGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithRuntimeLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "with_runtime.lte", runtime.ParamLocationQuery, *params.WithRuntimeLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithWatchMonetizationTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "with_watch_monetization_types", runtime.ParamLocationQuery, *params.WithWatchMonetizationTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithWatchProviders != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "with_watch_providers", runtime.ParamLocationQuery, *params.WithWatchProviders); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithoutCompanies != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "without_companies", runtime.ParamLocationQuery, *params.WithoutCompanies); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithoutGenres != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "without_genres", runtime.ParamLocationQuery, *params.WithoutGenres); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithoutKeywords != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "without_keywords", runtime.ParamLocationQuery, *params.WithoutKeywords); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithoutWatchProviders != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "without_watch_providers", runtime.ParamLocationQuery, *params.WithoutWatchProviders); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Year != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "year", runtime.ParamLocationQuery, *params.Year); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDiscoverTvRequest generates requests for DiscoverTv
func NewDiscoverTvRequest(server string, params *DiscoverTvParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/discover/tv")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AirDateGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "air_date.gte", runtime.ParamLocationQuery, *params.AirDateGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AirDateLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "air_date.lte", runtime.ParamLocationQuery, *params.AirDateLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FirstAirDateYear != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "first_air_date_year", runtime.ParamLocationQuery, *params.FirstAirDateYear); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FirstAirDateGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "first_air_date.gte", runtime.ParamLocationQuery, *params.FirstAirDateGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FirstAirDateLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "first_air_date.lte", runtime.ParamLocationQuery, *params.FirstAirDateLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeAdult != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_adult", runtime.ParamLocationQuery, *params.IncludeAdult); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeNullFirstAirDates != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_null_first_air_dates", runtime.ParamLocationQuery, *params.IncludeNullFirstAirDates); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Language != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, *params.Language); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ScreenedTheatrically != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "screened_theatrically", runtime.ParamLocationQuery, *params.ScreenedTheatrically); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Timezone != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timezone", runtime.ParamLocationQuery, *params.Timezone); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VoteAverageGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "vote_average.gte", runtime.ParamLocationQuery, *params.VoteAverageGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VoteAverageLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "vote_average.lte", runtime.ParamLocationQuery, *params.VoteAverageLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VoteCountGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "vote_count.gte", runtime.ParamLocationQuery, *params.VoteCountGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VoteCountLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "vote_count.lte", runtime.ParamLocationQuery, *params.VoteCountLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WatchRegion != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "watch_region", runtime.ParamLocationQuery, *params.WatchRegion); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithCompanies != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "with_companies", runtime.ParamLocationQuery, *params.WithCompanies); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithGenres != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "with_genres", runtime.ParamLocationQuery, *params.WithGenres); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithKeywords != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "with_keywords", runtime.ParamLocationQuery, *params.WithKeywords); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithNetworks != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "with_networks", runtime.ParamLocationQuery, *params.WithNetworks); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithOriginCountry != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "with_origin_country", runtime.ParamLocationQuery, *params.WithOriginCountry); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithOriginalLanguage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "with_original_language", runtime.ParamLocationQuery, *params.WithOriginalLanguage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithRuntimeGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "with_runtime.gte", runtime.ParamLocationQuery, *params.WithRuntimeGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithRuntimeLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "with_runtime.lte", runtime.ParamLocationQuery, *params.WithRuntimeLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithStatus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "with_status", runtime.ParamLocationQuery, *params.WithStatus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithWatchMonetizationTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "with_watch_monetization_types", runtime.ParamLocationQuery, *params.WithWatchMonetizationTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithWatchProviders != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "with_watch_providers", runtime.ParamLocationQuery, *params.WithWatchProviders); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithoutCompanies != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "without_companies", runtime.ParamLocationQuery, *params.WithoutCompanies); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithoutGenres != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "without_genres", runtime.ParamLocationQuery, *params.WithoutGenres); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithoutKeywords != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "without_keywords", runtime.ParamLocationQuery, *params.WithoutKeywords); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithoutWatchProviders != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "without_watch_providers", runtime.ParamLocationQuery, *params.WithoutWatchProviders); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "with_type", runtime.ParamLocationQuery, *params.WithType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindByIDRequest generates requests for FindByID
func NewFindByIDRequest(server string, externalID string, params *FindByIDParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "external_id", runtime.ParamLocationPath, externalID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/find/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "external_source", runtime.ParamLocationQuery, params.ExternalSource); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Language != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, *params.Language); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGenreMovieListRequest generates requests for GenreMovieList
func NewGenreMovieListRequest(server string, params *GenreMovieListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/genre/movie/list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Language != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, *params.Language); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGenreTvListRequest generates requests for GenreTvList
func NewGenreTvListRequest(server string, params *GenreTvListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/genre/tv/list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Language != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, *params.Language); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGuestSessionRatedMoviesRequest generates requests for GuestSessionRatedMovies
func NewGuestSessionRatedMoviesRequest(server string, guestSessionID string, params *GuestSessionRatedMoviesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "guest_session_id", runtime.ParamLocationPath, guestSessionID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/guest_session/%s/rated/movies", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Language != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, *params.Language); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGuestSessionRatedTvRequest generates requests for GuestSessionRatedTv
func NewGuestSessionRatedTvRequest(server string, guestSessionID string, params *GuestSessionRatedTvParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "guest_session_id", runtime.ParamLocationPath, guestSessionID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/guest_session/%s/rated/tv", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Language != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, *params.Language); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGuestSessionRatedTvEpisodesRequest generates requests for GuestSessionRatedTvEpisodes
func NewGuestSessionRatedTvEpisodesRequest(server string, guestSessionID string, params *GuestSessionRatedTvEpisodesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "guest_session_id", runtime.ParamLocationPath, guestSessionID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/guest_session/%s/rated/tv/episodes", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Language != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, *params.Language); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewKeywordDetailsRequest generates requests for KeywordDetails
func NewKeywordDetailsRequest(server string, keywordID int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "keyword_id", runtime.ParamLocationPath, keywordID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/keyword/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewKeywordMoviesRequest generates requests for KeywordMovies
func NewKeywordMoviesRequest(server string, keywordID string, params *KeywordMoviesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "keyword_id", runtime.ParamLocationPath, keywordID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/keyword/%s/movies", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IncludeAdult != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_adult", runtime.ParamLocationQuery, *params.IncludeAdult); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Language != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, *params.Language); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListCreateRequest calls the generic ListCreate builder with application/json body
func NewListCreateRequest(server string, params *ListCreateParams, body ListCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewListCreateRequestWithBody(server, params, "application/json", bodyReader)
}

// NewListCreateRequestWithBody generates requests for ListCreate with any type of body
func NewListCreateRequestWithBody(server string, params *ListCreateParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "session_id", runtime.ParamLocationQuery, params.SessionID); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListDeleteRequest generates requests for ListDelete
func NewListDeleteRequest(server string, listID int32, params *ListDeleteParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "list_id", runtime.ParamLocationPath, listID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/list/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "session_id", runtime.ParamLocationQuery, params.SessionID); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListDetailsRequest generates requests for ListDetails
func NewListDetailsRequest(server string, listID int32, params *ListDetailsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "list_id", runtime.ParamLocationPath, listID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/list/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Language != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, *params.Language); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAddMovieRequest calls the generic ListAddMovie builder with application/json body
func NewListAddMovieRequest(server string, listID int32, params *ListAddMovieParams, body ListAddMovieJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewListAddMovieRequestWithBody(server, listID, params, "application/json", bodyReader)
}

// NewListAddMovieRequestWithBody generates requests for ListAddMovie with any type of body
func NewListAddMovieRequestWithBody(server string, listID int32, params *ListAddMovieParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "list_id", runtime.ParamLocationPath, listID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/list/%s/add_item", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "session_id", runtime.ParamLocationQuery, params.SessionID); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListClearRequest generates requests for ListClear
func NewListClearRequest(server string, listID int32, params *ListClearParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "list_id", runtime.ParamLocationPath, listID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/list/%s/clear", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "session_id", runtime.ParamLocationQuery, params.SessionID); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "confirm", runtime.ParamLocationQuery, params.Confirm); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListCheckItemStatusRequest generates requests for ListCheckItemStatus
func NewListCheckItemStatusRequest(server string, listID int32, params *ListCheckItemStatusParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "list_id", runtime.ParamLocationPath, listID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/list/%s/item_status", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Language != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, *params.Language); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MovieID != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "movie_id", runtime.ParamLocationQuery, *params.MovieID); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListRemoveMovieRequest calls the generic ListRemoveMovie builder with application/json body
func NewListRemoveMovieRequest(server string, listID int32, params *ListRemoveMovieParams, body ListRemoveMovieJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewListRemoveMovieRequestWithBody(server, listID, params, "application/json", bodyReader)
}

// NewListRemoveMovieRequestWithBody generates requests for ListRemoveMovie with any type of body
func NewListRemoveMovieRequestWithBody(server string, listID int32, params *ListRemoveMovieParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "list_id", runtime.ParamLocationPath, listID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/list/%s/remove_item", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "session_id", runtime.ParamLocationQuery, params.SessionID); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewChangesMovieListRequest generates requests for ChangesMovieList
func NewChangesMovieListRequest(server string, params *ChangesMovieListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/movie/changes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.EndDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_date", runtime.ParamLocationQuery, *params.EndDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_date", runtime.ParamLocationQuery, *params.StartDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMovieLatestIDRequest generates requests for MovieLatestID
func NewMovieLatestIDRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/movie/latest")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMovieNowPlayingListRequest generates requests for MovieNowPlayingList
func NewMovieNowPlayingListRequest(server string, params *MovieNowPlayingListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/movie/now_playing")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Language != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, *params.Language); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Region != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "region", runtime.ParamLocationQuery, *params.Region); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMoviePopularListRequest generates requests for MoviePopularList
func NewMoviePopularListRequest(server string, params *MoviePopularListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/movie/popular")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Language != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, *params.Language); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Region != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "region", runtime.ParamLocationQuery, *params.Region); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMovieTopRatedListRequest generates requests for MovieTopRatedList
func NewMovieTopRatedListRequest(server string, params *MovieTopRatedListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/movie/top_rated")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Language != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, *params.Language); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Region != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "region", runtime.ParamLocationQuery, *params.Region); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMovieUpcomingListRequest generates requests for MovieUpcomingList
func NewMovieUpcomingListRequest(server string, params *MovieUpcomingListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/movie/upcoming")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Language != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, *params.Language); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Region != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "region", runtime.ParamLocationQuery, *params.Region); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMovieDetailsRequest generates requests for MovieDetails
func NewMovieDetailsRequest(server string, movieID int32, params *MovieDetailsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "movie_id", runtime.ParamLocationPath, movieID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/movie/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AppendToResponse != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "append_to_response", runtime.ParamLocationQuery, *params.AppendToResponse); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Language != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, *params.Language); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMovieAccountStatesRequest generates requests for MovieAccountStates
func NewMovieAccountStatesRequest(server string, movieID int32, params *MovieAccountStatesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "movie_id", runtime.ParamLocationPath, movieID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/movie/%s/account_states", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SessionID != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "session_id", runtime.ParamLocationQuery, *params.SessionID); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GuestSessionID != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "guest_session_id", runtime.ParamLocationQuery, *params.GuestSessionID); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMovieAlternativeTitlesRequest generates requests for MovieAlternativeTitles
func NewMovieAlternativeTitlesRequest(server string, movieID int32, params *MovieAlternativeTitlesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "movie_id", runtime.ParamLocationPath, movieID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/movie/%s/alternative_titles", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Country != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "country", runtime.ParamLocationQuery, *params.Country); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMovieChangesRequest generates requests for MovieChanges
func NewMovieChangesRequest(server string, movieID int32, params *MovieChangesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "movie_id", runtime.ParamLocationPath, movieID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/movie/%s/changes", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.EndDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_date", runtime.ParamLocationQuery, *params.EndDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_date", runtime.ParamLocationQuery, *params.StartDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMovieCreditsRequest generates requests for MovieCredits
func NewMovieCreditsRequest(server string, movieID int32, params *MovieCreditsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "movie_id", runtime.ParamLocationPath, movieID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/movie/%s/credits", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Language != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, *params.Language); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMovieExternalIdsRequest generates requests for MovieExternalIds
func NewMovieExternalIdsRequest(server string, movieID int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "movie_id", runtime.ParamLocationPath, movieID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/movie/%s/external_ids", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMovieImagesRequest generates requests for MovieImages
func NewMovieImagesRequest(server string, movieID int32, params *MovieImagesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "movie_id", runtime.ParamLocationPath, movieID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/movie/%s/images", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IncludeImageLanguage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_image_language", runtime.ParamLocationQuery, *params.IncludeImageLanguage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Language != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, *params.Language); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMovieKeywordsRequest generates requests for MovieKeywords
func NewMovieKeywordsRequest(server string, movieID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "movie_id", runtime.ParamLocationPath, movieID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/movie/%s/keywords", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMovieListsRequest generates requests for MovieLists
func NewMovieListsRequest(server string, movieID int32, params *MovieListsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "movie_id", runtime.ParamLocationPath, movieID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/movie/%s/lists", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Language != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, *params.Language); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMovieDeleteRatingRequest generates requests for MovieDeleteRating
func NewMovieDeleteRatingRequest(server string, movieID int32, params *MovieDeleteRatingParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "movie_id", runtime.ParamLocationPath, movieID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/movie/%s/rating", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.GuestSessionID != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "guest_session_id", runtime.ParamLocationQuery, *params.GuestSessionID); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SessionID != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "session_id", runtime.ParamLocationQuery, *params.SessionID); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.ContentType != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Content-Type", runtime.ParamLocationHeader, *params.ContentType)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Content-Type", headerParam0)
		}

	}

	return req, nil
}

// NewMovieAddRatingRequest calls the generic MovieAddRating builder with application/json body
func NewMovieAddRatingRequest(server string, movieID int32, params *MovieAddRatingParams, body MovieAddRatingJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMovieAddRatingRequestWithBody(server, movieID, params, "application/json", bodyReader)
}

// NewMovieAddRatingRequestWithBody generates requests for MovieAddRating with any type of body
func NewMovieAddRatingRequestWithBody(server string, movieID int32, params *MovieAddRatingParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "movie_id", runtime.ParamLocationPath, movieID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/movie/%s/rating", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.GuestSessionID != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "guest_session_id", runtime.ParamLocationQuery, *params.GuestSessionID); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SessionID != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "session_id", runtime.ParamLocationQuery, *params.SessionID); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Content-Type", runtime.ParamLocationHeader, params.ContentType)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Content-Type", headerParam0)

	}

	return req, nil
}

// NewMovieRecommendationsRequest generates requests for MovieRecommendations
func NewMovieRecommendationsRequest(server string, movieID int32, params *MovieRecommendationsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "movie_id", runtime.ParamLocationPath, movieID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/movie/%s/recommendations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Language != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, *params.Language); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMovieReleaseDatesRequest generates requests for MovieReleaseDates
func NewMovieReleaseDatesRequest(server string, movieID int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "movie_id", runtime.ParamLocationPath, movieID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/movie/%s/release_dates", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMovieReviewsRequest generates requests for MovieReviews
func NewMovieReviewsRequest(server string, movieID int32, params *MovieReviewsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "movie_id", runtime.ParamLocationPath, movieID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/movie/%s/reviews", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Language != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, *params.Language); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMovieSimilarRequest generates requests for MovieSimilar
func NewMovieSimilarRequest(server string, movieID int32, params *MovieSimilarParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "movie_id", runtime.ParamLocationPath, movieID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/movie/%s/similar", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Language != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, *params.Language); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMovieTranslationsRequest generates requests for MovieTranslations
func NewMovieTranslationsRequest(server string, movieID int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "movie_id", runtime.ParamLocationPath, movieID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/movie/%s/translations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMovieVideosRequest generates requests for MovieVideos
func NewMovieVideosRequest(server string, movieID int32, params *MovieVideosParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "movie_id", runtime.ParamLocationPath, movieID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/movie/%s/videos", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Language != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, *params.Language); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMovieWatchProvidersRequest generates requests for MovieWatchProviders
func NewMovieWatchProvidersRequest(server string, movieID int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "movie_id", runtime.ParamLocationPath, movieID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/movie/%s/watch/providers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNetworkDetailsRequest generates requests for NetworkDetails
func NewNetworkDetailsRequest(server string, networkID int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "network_id", runtime.ParamLocationPath, networkID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/network/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDetailsCopyRequest generates requests for DetailsCopy
func NewDetailsCopyRequest(server string, networkID int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "network_id", runtime.ParamLocationPath, networkID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/network/%s/alternative_names", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAlternativeNamesCopyRequest generates requests for AlternativeNamesCopy
func NewAlternativeNamesCopyRequest(server string, networkID int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "network_id", runtime.ParamLocationPath, networkID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/network/%s/images", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewChangesPeopleListRequest generates requests for ChangesPeopleList
func NewChangesPeopleListRequest(server string, params *ChangesPeopleListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/person/changes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.EndDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_date", runtime.ParamLocationQuery, *params.EndDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_date", runtime.ParamLocationQuery, *params.StartDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersonLatestIDRequest generates requests for PersonLatestID
func NewPersonLatestIDRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/person/latest")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersonPopularListRequest generates requests for PersonPopularList
func NewPersonPopularListRequest(server string, params *PersonPopularListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/person/popular")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Language != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, *params.Language); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersonDetailsRequest generates requests for PersonDetails
func NewPersonDetailsRequest(server string, personID int32, params *PersonDetailsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "person_id", runtime.ParamLocationPath, personID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/person/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AppendToResponse != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "append_to_response", runtime.ParamLocationQuery, *params.AppendToResponse); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Language != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, *params.Language); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersonChangesRequest generates requests for PersonChanges
func NewPersonChangesRequest(server string, personID int32, params *PersonChangesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "person_id", runtime.ParamLocationPath, personID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/person/%s/changes", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.EndDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_date", runtime.ParamLocationQuery, *params.EndDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_date", runtime.ParamLocationQuery, *params.StartDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersonCombinedCreditsRequest generates requests for PersonCombinedCredits
func NewPersonCombinedCreditsRequest(server string, personID string, params *PersonCombinedCreditsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "person_id", runtime.ParamLocationPath, personID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/person/%s/combined_credits", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Language != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, *params.Language); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersonExternalIdsRequest generates requests for PersonExternalIds
func NewPersonExternalIdsRequest(server string, personID int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "person_id", runtime.ParamLocationPath, personID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/person/%s/external_ids", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersonImagesRequest generates requests for PersonImages
func NewPersonImagesRequest(server string, personID int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "person_id", runtime.ParamLocationPath, personID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/person/%s/images", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersonMovieCreditsRequest generates requests for PersonMovieCredits
func NewPersonMovieCreditsRequest(server string, personID int32, params *PersonMovieCreditsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "person_id", runtime.ParamLocationPath, personID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/person/%s/movie_credits", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Language != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, *params.Language); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersonTaggedImagesRequest generates requests for PersonTaggedImages
func NewPersonTaggedImagesRequest(server string, personID int32, params *PersonTaggedImagesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "person_id", runtime.ParamLocationPath, personID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/person/%s/tagged_images", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTranslationsRequest generates requests for Translations
func NewTranslationsRequest(server string, personID int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "person_id", runtime.ParamLocationPath, personID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/person/%s/translations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersonTvCreditsRequest generates requests for PersonTvCredits
func NewPersonTvCreditsRequest(server string, personID int32, params *PersonTvCreditsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "person_id", runtime.ParamLocationPath, personID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/person/%s/tv_credits", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Language != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, *params.Language); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReviewDetailsRequest generates requests for ReviewDetails
func NewReviewDetailsRequest(server string, reviewID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "review_id", runtime.ParamLocationPath, reviewID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/review/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchCollectionRequest generates requests for SearchCollection
func NewSearchCollectionRequest(server string, params *SearchCollectionParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/search/collection")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "query", runtime.ParamLocationQuery, params.Query); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.IncludeAdult != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_adult", runtime.ParamLocationQuery, *params.IncludeAdult); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Language != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, *params.Language); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Region != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "region", runtime.ParamLocationQuery, *params.Region); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchCompanyRequest generates requests for SearchCompany
func NewSearchCompanyRequest(server string, params *SearchCompanyParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/search/company")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "query", runtime.ParamLocationQuery, params.Query); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchKeywordRequest generates requests for SearchKeyword
func NewSearchKeywordRequest(server string, params *SearchKeywordParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/search/keyword")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "query", runtime.ParamLocationQuery, params.Query); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchMovieRequest generates requests for SearchMovie
func NewSearchMovieRequest(server string, params *SearchMovieParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/search/movie")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "query", runtime.ParamLocationQuery, params.Query); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.IncludeAdult != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_adult", runtime.ParamLocationQuery, *params.IncludeAdult); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Language != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, *params.Language); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PrimaryReleaseYear != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "primary_release_year", runtime.ParamLocationQuery, *params.PrimaryReleaseYear); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Region != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "region", runtime.ParamLocationQuery, *params.Region); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Year != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "year", runtime.ParamLocationQuery, *params.Year); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchMultiRequest generates requests for SearchMulti
func NewSearchMultiRequest(server string, params *SearchMultiParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/search/multi")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "query", runtime.ParamLocationQuery, params.Query); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.IncludeAdult != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_adult", runtime.ParamLocationQuery, *params.IncludeAdult); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Language != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, *params.Language); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchPersonRequest generates requests for SearchPerson
func NewSearchPersonRequest(server string, params *SearchPersonParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/search/person")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "query", runtime.ParamLocationQuery, params.Query); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.IncludeAdult != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_adult", runtime.ParamLocationQuery, *params.IncludeAdult); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Language != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, *params.Language); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchTvRequest generates requests for SearchTv
func NewSearchTvRequest(server string, params *SearchTvParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/search/tv")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "query", runtime.ParamLocationQuery, params.Query); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.FirstAirDateYear != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "first_air_date_year", runtime.ParamLocationQuery, *params.FirstAirDateYear); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeAdult != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_adult", runtime.ParamLocationQuery, *params.IncludeAdult); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Language != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, *params.Language); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Year != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "year", runtime.ParamLocationQuery, *params.Year); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTrendingAllRequest generates requests for TrendingAll
func NewTrendingAllRequest(server string, timeWindow TrendingAllParamsTimeWindow, params *TrendingAllParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "time_window", runtime.ParamLocationPath, timeWindow)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/trending/all/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Language != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, *params.Language); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTrendingMoviesRequest generates requests for TrendingMovies
func NewTrendingMoviesRequest(server string, timeWindow TrendingMoviesParamsTimeWindow, params *TrendingMoviesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "time_window", runtime.ParamLocationPath, timeWindow)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/trending/movie/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Language != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, *params.Language); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTrendingPeopleRequest generates requests for TrendingPeople
func NewTrendingPeopleRequest(server string, timeWindow TrendingPeopleParamsTimeWindow, params *TrendingPeopleParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "time_window", runtime.ParamLocationPath, timeWindow)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/trending/person/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Language != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, *params.Language); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTrendingTvRequest generates requests for TrendingTv
func NewTrendingTvRequest(server string, timeWindow TrendingTvParamsTimeWindow, params *TrendingTvParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "time_window", runtime.ParamLocationPath, timeWindow)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/trending/tv/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Language != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, *params.Language); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTvSeriesAiringTodayListRequest generates requests for TvSeriesAiringTodayList
func NewTvSeriesAiringTodayListRequest(server string, params *TvSeriesAiringTodayListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/tv/airing_today")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Language != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, *params.Language); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Timezone != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timezone", runtime.ParamLocationQuery, *params.Timezone); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewChangesTvListRequest generates requests for ChangesTvList
func NewChangesTvListRequest(server string, params *ChangesTvListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/tv/changes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.EndDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_date", runtime.ParamLocationQuery, *params.EndDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_date", runtime.ParamLocationQuery, *params.StartDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTvEpisodeChangesByIDRequest generates requests for TvEpisodeChangesByID
func NewTvEpisodeChangesByIDRequest(server string, episodeID int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "episode_id", runtime.ParamLocationPath, episodeID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/tv/episode/%s/changes", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTvEpisodeGroupDetailsRequest generates requests for TvEpisodeGroupDetails
func NewTvEpisodeGroupDetailsRequest(server string, tvEpisodeGroupID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tv_episode_group_id", runtime.ParamLocationPath, tvEpisodeGroupID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/tv/episode_group/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTvSeriesLatestIDRequest generates requests for TvSeriesLatestID
func NewTvSeriesLatestIDRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/tv/latest")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTvSeriesOnTheAirListRequest generates requests for TvSeriesOnTheAirList
func NewTvSeriesOnTheAirListRequest(server string, params *TvSeriesOnTheAirListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/tv/on_the_air")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Language != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, *params.Language); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Timezone != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timezone", runtime.ParamLocationQuery, *params.Timezone); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTvSeriesPopularListRequest generates requests for TvSeriesPopularList
func NewTvSeriesPopularListRequest(server string, params *TvSeriesPopularListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/tv/popular")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Language != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, *params.Language); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTvSeasonChangesByIDRequest generates requests for TvSeasonChangesByID
func NewTvSeasonChangesByIDRequest(server string, seasonID int32, params *TvSeasonChangesByIDParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "season_id", runtime.ParamLocationPath, seasonID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/tv/season/%s/changes", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.EndDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_date", runtime.ParamLocationQuery, *params.EndDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_date", runtime.ParamLocationQuery, *params.StartDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTvSeriesTopRatedListRequest generates requests for TvSeriesTopRatedList
func NewTvSeriesTopRatedListRequest(server string, params *TvSeriesTopRatedListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/tv/top_rated")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Language != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, *params.Language); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTvSeriesDetailsRequest generates requests for TvSeriesDetails
func NewTvSeriesDetailsRequest(server string, seriesID int32, params *TvSeriesDetailsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "series_id", runtime.ParamLocationPath, seriesID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/tv/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AppendToResponse != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "append_to_response", runtime.ParamLocationQuery, *params.AppendToResponse); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Language != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, *params.Language); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTvSeriesAccountStatesRequest generates requests for TvSeriesAccountStates
func NewTvSeriesAccountStatesRequest(server string, seriesID int32, params *TvSeriesAccountStatesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "series_id", runtime.ParamLocationPath, seriesID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/tv/%s/account_states", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SessionID != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "session_id", runtime.ParamLocationQuery, *params.SessionID); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GuestSessionID != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "guest_session_id", runtime.ParamLocationQuery, *params.GuestSessionID); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTvSeriesAggregateCreditsRequest generates requests for TvSeriesAggregateCredits
func NewTvSeriesAggregateCreditsRequest(server string, seriesID int32, params *TvSeriesAggregateCreditsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "series_id", runtime.ParamLocationPath, seriesID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/tv/%s/aggregate_credits", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Language != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, *params.Language); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTvSeriesAlternativeTitlesRequest generates requests for TvSeriesAlternativeTitles
func NewTvSeriesAlternativeTitlesRequest(server string, seriesID int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "series_id", runtime.ParamLocationPath, seriesID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/tv/%s/alternative_titles", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTvSeriesChangesRequest generates requests for TvSeriesChanges
func NewTvSeriesChangesRequest(server string, seriesID int32, params *TvSeriesChangesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "series_id", runtime.ParamLocationPath, seriesID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/tv/%s/changes", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.EndDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_date", runtime.ParamLocationQuery, *params.EndDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_date", runtime.ParamLocationQuery, *params.StartDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTvSeriesContentRatingsRequest generates requests for TvSeriesContentRatings
func NewTvSeriesContentRatingsRequest(server string, seriesID int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "series_id", runtime.ParamLocationPath, seriesID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/tv/%s/content_ratings", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTvSeriesCreditsRequest generates requests for TvSeriesCredits
func NewTvSeriesCreditsRequest(server string, seriesID int32, params *TvSeriesCreditsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "series_id", runtime.ParamLocationPath, seriesID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/tv/%s/credits", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Language != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, *params.Language); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTvSeriesEpisodeGroupsRequest generates requests for TvSeriesEpisodeGroups
func NewTvSeriesEpisodeGroupsRequest(server string, seriesID int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "series_id", runtime.ParamLocationPath, seriesID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/tv/%s/episode_groups", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTvSeriesExternalIdsRequest generates requests for TvSeriesExternalIds
func NewTvSeriesExternalIdsRequest(server string, seriesID int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "series_id", runtime.ParamLocationPath, seriesID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/tv/%s/external_ids", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTvSeriesImagesRequest generates requests for TvSeriesImages
func NewTvSeriesImagesRequest(server string, seriesID int32, params *TvSeriesImagesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "series_id", runtime.ParamLocationPath, seriesID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/tv/%s/images", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IncludeImageLanguage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_image_language", runtime.ParamLocationQuery, *params.IncludeImageLanguage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Language != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, *params.Language); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTvSeriesKeywordsRequest generates requests for TvSeriesKeywords
func NewTvSeriesKeywordsRequest(server string, seriesID int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "series_id", runtime.ParamLocationPath, seriesID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/tv/%s/keywords", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListsCopyRequest generates requests for ListsCopy
func NewListsCopyRequest(server string, seriesID int32, params *ListsCopyParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "series_id", runtime.ParamLocationPath, seriesID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/tv/%s/lists", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Language != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, *params.Language); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTvSeriesDeleteRatingRequest generates requests for TvSeriesDeleteRating
func NewTvSeriesDeleteRatingRequest(server string, seriesID int32, params *TvSeriesDeleteRatingParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "series_id", runtime.ParamLocationPath, seriesID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/tv/%s/rating", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.GuestSessionID != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "guest_session_id", runtime.ParamLocationQuery, *params.GuestSessionID); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SessionID != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "session_id", runtime.ParamLocationQuery, *params.SessionID); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.ContentType != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Content-Type", runtime.ParamLocationHeader, *params.ContentType)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Content-Type", headerParam0)
		}

	}

	return req, nil
}

// NewTvSeriesAddRatingRequest calls the generic TvSeriesAddRating builder with application/json body
func NewTvSeriesAddRatingRequest(server string, seriesID int32, params *TvSeriesAddRatingParams, body TvSeriesAddRatingJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTvSeriesAddRatingRequestWithBody(server, seriesID, params, "application/json", bodyReader)
}

// NewTvSeriesAddRatingRequestWithBody generates requests for TvSeriesAddRating with any type of body
func NewTvSeriesAddRatingRequestWithBody(server string, seriesID int32, params *TvSeriesAddRatingParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "series_id", runtime.ParamLocationPath, seriesID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/tv/%s/rating", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.GuestSessionID != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "guest_session_id", runtime.ParamLocationQuery, *params.GuestSessionID); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SessionID != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "session_id", runtime.ParamLocationQuery, *params.SessionID); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Content-Type", runtime.ParamLocationHeader, params.ContentType)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Content-Type", headerParam0)

	}

	return req, nil
}

// NewTvSeriesRecommendationsRequest generates requests for TvSeriesRecommendations
func NewTvSeriesRecommendationsRequest(server string, seriesID int32, params *TvSeriesRecommendationsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "series_id", runtime.ParamLocationPath, seriesID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/tv/%s/recommendations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Language != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, *params.Language); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTvSeriesReviewsRequest generates requests for TvSeriesReviews
func NewTvSeriesReviewsRequest(server string, seriesID int32, params *TvSeriesReviewsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "series_id", runtime.ParamLocationPath, seriesID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/tv/%s/reviews", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Language != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, *params.Language); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTvSeriesScreenedTheatricallyRequest generates requests for TvSeriesScreenedTheatrically
func NewTvSeriesScreenedTheatricallyRequest(server string, seriesID int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "series_id", runtime.ParamLocationPath, seriesID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/tv/%s/screened_theatrically", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTvSeasonDetailsRequest generates requests for TvSeasonDetails
func NewTvSeasonDetailsRequest(server string, seriesID int32, seasonNumber int32, params *TvSeasonDetailsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "series_id", runtime.ParamLocationPath, seriesID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "season_number", runtime.ParamLocationPath, seasonNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/tv/%s/season/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AppendToResponse != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "append_to_response", runtime.ParamLocationQuery, *params.AppendToResponse); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Language != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, *params.Language); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTvSeasonAccountStatesRequest generates requests for TvSeasonAccountStates
func NewTvSeasonAccountStatesRequest(server string, seriesID int32, seasonNumber int32, params *TvSeasonAccountStatesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "series_id", runtime.ParamLocationPath, seriesID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "season_number", runtime.ParamLocationPath, seasonNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/tv/%s/season/%s/account_states", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SessionID != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "session_id", runtime.ParamLocationQuery, *params.SessionID); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GuestSessionID != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "guest_session_id", runtime.ParamLocationQuery, *params.GuestSessionID); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTvSeasonAggregateCreditsRequest generates requests for TvSeasonAggregateCredits
func NewTvSeasonAggregateCreditsRequest(server string, seriesID int32, seasonNumber int32, params *TvSeasonAggregateCreditsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "series_id", runtime.ParamLocationPath, seriesID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "season_number", runtime.ParamLocationPath, seasonNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/tv/%s/season/%s/aggregate_credits", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Language != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, *params.Language); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTvSeasonCreditsRequest generates requests for TvSeasonCredits
func NewTvSeasonCreditsRequest(server string, seriesID int32, seasonNumber int32, params *TvSeasonCreditsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "series_id", runtime.ParamLocationPath, seriesID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "season_number", runtime.ParamLocationPath, seasonNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/tv/%s/season/%s/credits", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Language != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, *params.Language); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTvEpisodeDetailsRequest generates requests for TvEpisodeDetails
func NewTvEpisodeDetailsRequest(server string, seriesID int32, seasonNumber int32, episodeNumber int32, params *TvEpisodeDetailsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "series_id", runtime.ParamLocationPath, seriesID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "season_number", runtime.ParamLocationPath, seasonNumber)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "episode_number", runtime.ParamLocationPath, episodeNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/tv/%s/season/%s/episode/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AppendToResponse != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "append_to_response", runtime.ParamLocationQuery, *params.AppendToResponse); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Language != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, *params.Language); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTvEpisodeAccountStatesRequest generates requests for TvEpisodeAccountStates
func NewTvEpisodeAccountStatesRequest(server string, seriesID int32, seasonNumber int32, episodeNumber int32, params *TvEpisodeAccountStatesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "series_id", runtime.ParamLocationPath, seriesID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "season_number", runtime.ParamLocationPath, seasonNumber)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "episode_number", runtime.ParamLocationPath, episodeNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/tv/%s/season/%s/episode/%s/account_states", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SessionID != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "session_id", runtime.ParamLocationQuery, *params.SessionID); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GuestSessionID != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "guest_session_id", runtime.ParamLocationQuery, *params.GuestSessionID); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTvEpisodeCreditsRequest generates requests for TvEpisodeCredits
func NewTvEpisodeCreditsRequest(server string, seriesID int32, seasonNumber int32, episodeNumber int32, params *TvEpisodeCreditsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "series_id", runtime.ParamLocationPath, seriesID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "season_number", runtime.ParamLocationPath, seasonNumber)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "episode_number", runtime.ParamLocationPath, episodeNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/tv/%s/season/%s/episode/%s/credits", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Language != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, *params.Language); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTvEpisodeExternalIdsRequest generates requests for TvEpisodeExternalIds
func NewTvEpisodeExternalIdsRequest(server string, seriesID int32, seasonNumber int32, episodeNumber string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "series_id", runtime.ParamLocationPath, seriesID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "season_number", runtime.ParamLocationPath, seasonNumber)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "episode_number", runtime.ParamLocationPath, episodeNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/tv/%s/season/%s/episode/%s/external_ids", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTvEpisodeImagesRequest generates requests for TvEpisodeImages
func NewTvEpisodeImagesRequest(server string, seriesID int32, seasonNumber int32, episodeNumber int32, params *TvEpisodeImagesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "series_id", runtime.ParamLocationPath, seriesID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "season_number", runtime.ParamLocationPath, seasonNumber)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "episode_number", runtime.ParamLocationPath, episodeNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/tv/%s/season/%s/episode/%s/images", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IncludeImageLanguage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_image_language", runtime.ParamLocationQuery, *params.IncludeImageLanguage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Language != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, *params.Language); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTvEpisodeDeleteRatingRequest generates requests for TvEpisodeDeleteRating
func NewTvEpisodeDeleteRatingRequest(server string, seriesID int32, seasonNumber int32, episodeNumber int32, params *TvEpisodeDeleteRatingParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "series_id", runtime.ParamLocationPath, seriesID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "season_number", runtime.ParamLocationPath, seasonNumber)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "episode_number", runtime.ParamLocationPath, episodeNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/tv/%s/season/%s/episode/%s/rating", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.GuestSessionID != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "guest_session_id", runtime.ParamLocationQuery, *params.GuestSessionID); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SessionID != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "session_id", runtime.ParamLocationQuery, *params.SessionID); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.ContentType != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Content-Type", runtime.ParamLocationHeader, *params.ContentType)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Content-Type", headerParam0)
		}

	}

	return req, nil
}

// NewTvEpisodeAddRatingRequest calls the generic TvEpisodeAddRating builder with application/json body
func NewTvEpisodeAddRatingRequest(server string, seriesID int32, seasonNumber int32, episodeNumber int32, params *TvEpisodeAddRatingParams, body TvEpisodeAddRatingJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTvEpisodeAddRatingRequestWithBody(server, seriesID, seasonNumber, episodeNumber, params, "application/json", bodyReader)
}

// NewTvEpisodeAddRatingRequestWithBody generates requests for TvEpisodeAddRating with any type of body
func NewTvEpisodeAddRatingRequestWithBody(server string, seriesID int32, seasonNumber int32, episodeNumber int32, params *TvEpisodeAddRatingParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "series_id", runtime.ParamLocationPath, seriesID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "season_number", runtime.ParamLocationPath, seasonNumber)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "episode_number", runtime.ParamLocationPath, episodeNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/tv/%s/season/%s/episode/%s/rating", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.GuestSessionID != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "guest_session_id", runtime.ParamLocationQuery, *params.GuestSessionID); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SessionID != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "session_id", runtime.ParamLocationQuery, *params.SessionID); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Content-Type", runtime.ParamLocationHeader, params.ContentType)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Content-Type", headerParam0)

	}

	return req, nil
}

// NewTvEpisodeTranslationsRequest generates requests for TvEpisodeTranslations
func NewTvEpisodeTranslationsRequest(server string, seriesID int32, seasonNumber int32, episodeNumber int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "series_id", runtime.ParamLocationPath, seriesID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "season_number", runtime.ParamLocationPath, seasonNumber)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "episode_number", runtime.ParamLocationPath, episodeNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/tv/%s/season/%s/episode/%s/translations", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTvEpisodeVideosRequest generates requests for TvEpisodeVideos
func NewTvEpisodeVideosRequest(server string, seriesID int32, seasonNumber int32, episodeNumber int32, params *TvEpisodeVideosParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "series_id", runtime.ParamLocationPath, seriesID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "season_number", runtime.ParamLocationPath, seasonNumber)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "episode_number", runtime.ParamLocationPath, episodeNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/tv/%s/season/%s/episode/%s/videos", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IncludeVideoLanguage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_video_language", runtime.ParamLocationQuery, *params.IncludeVideoLanguage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Language != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, *params.Language); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTvSeasonExternalIdsRequest generates requests for TvSeasonExternalIds
func NewTvSeasonExternalIdsRequest(server string, seriesID int32, seasonNumber int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "series_id", runtime.ParamLocationPath, seriesID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "season_number", runtime.ParamLocationPath, seasonNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/tv/%s/season/%s/external_ids", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTvSeasonImagesRequest generates requests for TvSeasonImages
func NewTvSeasonImagesRequest(server string, seriesID int32, seasonNumber int32, params *TvSeasonImagesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "series_id", runtime.ParamLocationPath, seriesID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "season_number", runtime.ParamLocationPath, seasonNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/tv/%s/season/%s/images", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IncludeImageLanguage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_image_language", runtime.ParamLocationQuery, *params.IncludeImageLanguage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Language != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, *params.Language); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTvSeasonTranslationsRequest generates requests for TvSeasonTranslations
func NewTvSeasonTranslationsRequest(server string, seriesID int32, seasonNumber int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "series_id", runtime.ParamLocationPath, seriesID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "season_number", runtime.ParamLocationPath, seasonNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/tv/%s/season/%s/translations", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTvSeasonVideosRequest generates requests for TvSeasonVideos
func NewTvSeasonVideosRequest(server string, seriesID int32, seasonNumber int32, params *TvSeasonVideosParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "series_id", runtime.ParamLocationPath, seriesID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "season_number", runtime.ParamLocationPath, seasonNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/tv/%s/season/%s/videos", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IncludeVideoLanguage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_video_language", runtime.ParamLocationQuery, *params.IncludeVideoLanguage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Language != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, *params.Language); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTvSeasonWatchProvidersRequest generates requests for TvSeasonWatchProviders
func NewTvSeasonWatchProvidersRequest(server string, seriesID int32, seasonNumber int32, params *TvSeasonWatchProvidersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "series_id", runtime.ParamLocationPath, seriesID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "season_number", runtime.ParamLocationPath, seasonNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/tv/%s/season/%s/watch/providers", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Language != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, *params.Language); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTvSeriesSimilarRequest generates requests for TvSeriesSimilar
func NewTvSeriesSimilarRequest(server string, seriesID string, params *TvSeriesSimilarParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "series_id", runtime.ParamLocationPath, seriesID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/tv/%s/similar", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Language != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, *params.Language); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTvSeriesTranslationsRequest generates requests for TvSeriesTranslations
func NewTvSeriesTranslationsRequest(server string, seriesID int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "series_id", runtime.ParamLocationPath, seriesID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/tv/%s/translations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTvSeriesVideosRequest generates requests for TvSeriesVideos
func NewTvSeriesVideosRequest(server string, seriesID int32, params *TvSeriesVideosParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "series_id", runtime.ParamLocationPath, seriesID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/tv/%s/videos", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IncludeVideoLanguage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_video_language", runtime.ParamLocationQuery, *params.IncludeVideoLanguage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Language != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, *params.Language); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTvSeriesWatchProvidersRequest generates requests for TvSeriesWatchProviders
func NewTvSeriesWatchProvidersRequest(server string, seriesID int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "series_id", runtime.ParamLocationPath, seriesID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/tv/%s/watch/providers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWatchProvidersMovieListRequest generates requests for WatchProvidersMovieList
func NewWatchProvidersMovieListRequest(server string, params *WatchProvidersMovieListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/watch/providers/movie")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Language != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, *params.Language); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WatchRegion != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "watch_region", runtime.ParamLocationQuery, *params.WatchRegion); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWatchProvidersAvailableRegionsRequest generates requests for WatchProvidersAvailableRegions
func NewWatchProvidersAvailableRegionsRequest(server string, params *WatchProvidersAvailableRegionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/watch/providers/regions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Language != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, *params.Language); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWatchProviderTvListRequest generates requests for WatchProviderTvList
func NewWatchProviderTvListRequest(server string, params *WatchProviderTvListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/3/watch/providers/tv")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Language != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, *params.Language); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WatchRegion != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "watch_region", runtime.ParamLocationQuery, *params.WatchRegion); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// AccountDetailsWithResponse request
	AccountDetailsWithResponse(ctx context.Context, accountID int32, params *AccountDetailsParams, reqEditors ...RequestEditorFn) (*AccountDetailsResponse, error)

	// AccountAddFavoriteWithBodyWithResponse request with any body
	AccountAddFavoriteWithBodyWithResponse(ctx context.Context, accountID int32, params *AccountAddFavoriteParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AccountAddFavoriteResponse, error)

	AccountAddFavoriteWithResponse(ctx context.Context, accountID int32, params *AccountAddFavoriteParams, body AccountAddFavoriteJSONRequestBody, reqEditors ...RequestEditorFn) (*AccountAddFavoriteResponse, error)

	// AccountGetFavoritesWithResponse request
	AccountGetFavoritesWithResponse(ctx context.Context, accountID int32, params *AccountGetFavoritesParams, reqEditors ...RequestEditorFn) (*AccountGetFavoritesResponse, error)

	// AccountFavoriteTvWithResponse request
	AccountFavoriteTvWithResponse(ctx context.Context, accountID int32, params *AccountFavoriteTvParams, reqEditors ...RequestEditorFn) (*AccountFavoriteTvResponse, error)

	// AccountListsWithResponse request
	AccountListsWithResponse(ctx context.Context, accountID int32, params *AccountListsParams, reqEditors ...RequestEditorFn) (*AccountListsResponse, error)

	// AccountRatedMoviesWithResponse request
	AccountRatedMoviesWithResponse(ctx context.Context, accountID int32, params *AccountRatedMoviesParams, reqEditors ...RequestEditorFn) (*AccountRatedMoviesResponse, error)

	// AccountRatedTvWithResponse request
	AccountRatedTvWithResponse(ctx context.Context, accountID int32, params *AccountRatedTvParams, reqEditors ...RequestEditorFn) (*AccountRatedTvResponse, error)

	// AccountRatedTvEpisodesWithResponse request
	AccountRatedTvEpisodesWithResponse(ctx context.Context, accountID int32, params *AccountRatedTvEpisodesParams, reqEditors ...RequestEditorFn) (*AccountRatedTvEpisodesResponse, error)

	// AccountAddToWatchlistWithBodyWithResponse request with any body
	AccountAddToWatchlistWithBodyWithResponse(ctx context.Context, accountID int32, params *AccountAddToWatchlistParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AccountAddToWatchlistResponse, error)

	AccountAddToWatchlistWithResponse(ctx context.Context, accountID int32, params *AccountAddToWatchlistParams, body AccountAddToWatchlistJSONRequestBody, reqEditors ...RequestEditorFn) (*AccountAddToWatchlistResponse, error)

	// AccountWatchlistMoviesWithResponse request
	AccountWatchlistMoviesWithResponse(ctx context.Context, accountID int32, params *AccountWatchlistMoviesParams, reqEditors ...RequestEditorFn) (*AccountWatchlistMoviesResponse, error)

	// AccountWatchlistTvWithResponse request
	AccountWatchlistTvWithResponse(ctx context.Context, accountID int32, params *AccountWatchlistTvParams, reqEditors ...RequestEditorFn) (*AccountWatchlistTvResponse, error)

	// AuthenticationValidateKeyWithResponse request
	AuthenticationValidateKeyWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*AuthenticationValidateKeyResponse, error)

	// AuthenticationCreateGuestSessionWithResponse request
	AuthenticationCreateGuestSessionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*AuthenticationCreateGuestSessionResponse, error)

	// AuthenticationDeleteSessionWithBodyWithResponse request with any body
	AuthenticationDeleteSessionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthenticationDeleteSessionResponse, error)

	AuthenticationDeleteSessionWithResponse(ctx context.Context, body AuthenticationDeleteSessionJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthenticationDeleteSessionResponse, error)

	// AuthenticationCreateSessionFromV4TokenWithBodyWithResponse request with any body
	AuthenticationCreateSessionFromV4TokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthenticationCreateSessionFromV4TokenResponse, error)

	AuthenticationCreateSessionFromV4TokenWithResponse(ctx context.Context, body AuthenticationCreateSessionFromV4TokenJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthenticationCreateSessionFromV4TokenResponse, error)

	// AuthenticationCreateSessionWithBodyWithResponse request with any body
	AuthenticationCreateSessionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthenticationCreateSessionResponse, error)

	AuthenticationCreateSessionWithResponse(ctx context.Context, body AuthenticationCreateSessionJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthenticationCreateSessionResponse, error)

	// AuthenticationCreateRequestTokenWithResponse request
	AuthenticationCreateRequestTokenWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*AuthenticationCreateRequestTokenResponse, error)

	// AuthenticationCreateSessionFromLoginWithBodyWithResponse request with any body
	AuthenticationCreateSessionFromLoginWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthenticationCreateSessionFromLoginResponse, error)

	AuthenticationCreateSessionFromLoginWithResponse(ctx context.Context, body AuthenticationCreateSessionFromLoginJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthenticationCreateSessionFromLoginResponse, error)

	// CertificationMovieListWithResponse request
	CertificationMovieListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CertificationMovieListResponse, error)

	// CertificationsTvListWithResponse request
	CertificationsTvListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CertificationsTvListResponse, error)

	// CollectionDetailsWithResponse request
	CollectionDetailsWithResponse(ctx context.Context, collectionID int32, params *CollectionDetailsParams, reqEditors ...RequestEditorFn) (*CollectionDetailsResponse, error)

	// CollectionImagesWithResponse request
	CollectionImagesWithResponse(ctx context.Context, collectionID int32, params *CollectionImagesParams, reqEditors ...RequestEditorFn) (*CollectionImagesResponse, error)

	// CollectionTranslationsWithResponse request
	CollectionTranslationsWithResponse(ctx context.Context, collectionID int32, reqEditors ...RequestEditorFn) (*CollectionTranslationsResponse, error)

	// CompanyDetailsWithResponse request
	CompanyDetailsWithResponse(ctx context.Context, companyID int32, reqEditors ...RequestEditorFn) (*CompanyDetailsResponse, error)

	// CompanyAlternativeNamesWithResponse request
	CompanyAlternativeNamesWithResponse(ctx context.Context, companyID int32, reqEditors ...RequestEditorFn) (*CompanyAlternativeNamesResponse, error)

	// CompanyImagesWithResponse request
	CompanyImagesWithResponse(ctx context.Context, companyID int32, reqEditors ...RequestEditorFn) (*CompanyImagesResponse, error)

	// ConfigurationDetailsWithResponse request
	ConfigurationDetailsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ConfigurationDetailsResponse, error)

	// ConfigurationCountriesWithResponse request
	ConfigurationCountriesWithResponse(ctx context.Context, params *ConfigurationCountriesParams, reqEditors ...RequestEditorFn) (*ConfigurationCountriesResponse, error)

	// ConfigurationJobsWithResponse request
	ConfigurationJobsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ConfigurationJobsResponse, error)

	// ConfigurationLanguagesWithResponse request
	ConfigurationLanguagesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ConfigurationLanguagesResponse, error)

	// ConfigurationPrimaryTranslationsWithResponse request
	ConfigurationPrimaryTranslationsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ConfigurationPrimaryTranslationsResponse, error)

	// ConfigurationTimezonesWithResponse request
	ConfigurationTimezonesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ConfigurationTimezonesResponse, error)

	// CreditDetailsWithResponse request
	CreditDetailsWithResponse(ctx context.Context, creditID string, reqEditors ...RequestEditorFn) (*CreditDetailsResponse, error)

	// DiscoverMovieWithResponse request
	DiscoverMovieWithResponse(ctx context.Context, params *DiscoverMovieParams, reqEditors ...RequestEditorFn) (*DiscoverMovieResponse, error)

	// DiscoverTvWithResponse request
	DiscoverTvWithResponse(ctx context.Context, params *DiscoverTvParams, reqEditors ...RequestEditorFn) (*DiscoverTvResponse, error)

	// FindByIDWithResponse request
	FindByIDWithResponse(ctx context.Context, externalID string, params *FindByIDParams, reqEditors ...RequestEditorFn) (*FindByIDResponse, error)

	// GenreMovieListWithResponse request
	GenreMovieListWithResponse(ctx context.Context, params *GenreMovieListParams, reqEditors ...RequestEditorFn) (*GenreMovieListResponse, error)

	// GenreTvListWithResponse request
	GenreTvListWithResponse(ctx context.Context, params *GenreTvListParams, reqEditors ...RequestEditorFn) (*GenreTvListResponse, error)

	// GuestSessionRatedMoviesWithResponse request
	GuestSessionRatedMoviesWithResponse(ctx context.Context, guestSessionID string, params *GuestSessionRatedMoviesParams, reqEditors ...RequestEditorFn) (*GuestSessionRatedMoviesResponse, error)

	// GuestSessionRatedTvWithResponse request
	GuestSessionRatedTvWithResponse(ctx context.Context, guestSessionID string, params *GuestSessionRatedTvParams, reqEditors ...RequestEditorFn) (*GuestSessionRatedTvResponse, error)

	// GuestSessionRatedTvEpisodesWithResponse request
	GuestSessionRatedTvEpisodesWithResponse(ctx context.Context, guestSessionID string, params *GuestSessionRatedTvEpisodesParams, reqEditors ...RequestEditorFn) (*GuestSessionRatedTvEpisodesResponse, error)

	// KeywordDetailsWithResponse request
	KeywordDetailsWithResponse(ctx context.Context, keywordID int32, reqEditors ...RequestEditorFn) (*KeywordDetailsResponse, error)

	// KeywordMoviesWithResponse request
	KeywordMoviesWithResponse(ctx context.Context, keywordID string, params *KeywordMoviesParams, reqEditors ...RequestEditorFn) (*KeywordMoviesResponse, error)

	// ListCreateWithBodyWithResponse request with any body
	ListCreateWithBodyWithResponse(ctx context.Context, params *ListCreateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListCreateResponse, error)

	ListCreateWithResponse(ctx context.Context, params *ListCreateParams, body ListCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ListCreateResponse, error)

	// ListDeleteWithResponse request
	ListDeleteWithResponse(ctx context.Context, listID int32, params *ListDeleteParams, reqEditors ...RequestEditorFn) (*ListDeleteResponse, error)

	// ListDetailsWithResponse request
	ListDetailsWithResponse(ctx context.Context, listID int32, params *ListDetailsParams, reqEditors ...RequestEditorFn) (*ListDetailsResponse, error)

	// ListAddMovieWithBodyWithResponse request with any body
	ListAddMovieWithBodyWithResponse(ctx context.Context, listID int32, params *ListAddMovieParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListAddMovieResponse, error)

	ListAddMovieWithResponse(ctx context.Context, listID int32, params *ListAddMovieParams, body ListAddMovieJSONRequestBody, reqEditors ...RequestEditorFn) (*ListAddMovieResponse, error)

	// ListClearWithResponse request
	ListClearWithResponse(ctx context.Context, listID int32, params *ListClearParams, reqEditors ...RequestEditorFn) (*ListClearResponse, error)

	// ListCheckItemStatusWithResponse request
	ListCheckItemStatusWithResponse(ctx context.Context, listID int32, params *ListCheckItemStatusParams, reqEditors ...RequestEditorFn) (*ListCheckItemStatusResponse, error)

	// ListRemoveMovieWithBodyWithResponse request with any body
	ListRemoveMovieWithBodyWithResponse(ctx context.Context, listID int32, params *ListRemoveMovieParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListRemoveMovieResponse, error)

	ListRemoveMovieWithResponse(ctx context.Context, listID int32, params *ListRemoveMovieParams, body ListRemoveMovieJSONRequestBody, reqEditors ...RequestEditorFn) (*ListRemoveMovieResponse, error)

	// ChangesMovieListWithResponse request
	ChangesMovieListWithResponse(ctx context.Context, params *ChangesMovieListParams, reqEditors ...RequestEditorFn) (*ChangesMovieListResponse, error)

	// MovieLatestIDWithResponse request
	MovieLatestIDWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*MovieLatestIDResponse, error)

	// MovieNowPlayingListWithResponse request
	MovieNowPlayingListWithResponse(ctx context.Context, params *MovieNowPlayingListParams, reqEditors ...RequestEditorFn) (*MovieNowPlayingListResponse, error)

	// MoviePopularListWithResponse request
	MoviePopularListWithResponse(ctx context.Context, params *MoviePopularListParams, reqEditors ...RequestEditorFn) (*MoviePopularListResponse, error)

	// MovieTopRatedListWithResponse request
	MovieTopRatedListWithResponse(ctx context.Context, params *MovieTopRatedListParams, reqEditors ...RequestEditorFn) (*MovieTopRatedListResponse, error)

	// MovieUpcomingListWithResponse request
	MovieUpcomingListWithResponse(ctx context.Context, params *MovieUpcomingListParams, reqEditors ...RequestEditorFn) (*MovieUpcomingListResponse, error)

	// MovieDetailsWithResponse request
	MovieDetailsWithResponse(ctx context.Context, movieID int32, params *MovieDetailsParams, reqEditors ...RequestEditorFn) (*MovieDetailsResponse, error)

	// MovieAccountStatesWithResponse request
	MovieAccountStatesWithResponse(ctx context.Context, movieID int32, params *MovieAccountStatesParams, reqEditors ...RequestEditorFn) (*MovieAccountStatesResponse, error)

	// MovieAlternativeTitlesWithResponse request
	MovieAlternativeTitlesWithResponse(ctx context.Context, movieID int32, params *MovieAlternativeTitlesParams, reqEditors ...RequestEditorFn) (*MovieAlternativeTitlesResponse, error)

	// MovieChangesWithResponse request
	MovieChangesWithResponse(ctx context.Context, movieID int32, params *MovieChangesParams, reqEditors ...RequestEditorFn) (*MovieChangesResponse, error)

	// MovieCreditsWithResponse request
	MovieCreditsWithResponse(ctx context.Context, movieID int32, params *MovieCreditsParams, reqEditors ...RequestEditorFn) (*MovieCreditsResponse, error)

	// MovieExternalIdsWithResponse request
	MovieExternalIdsWithResponse(ctx context.Context, movieID int32, reqEditors ...RequestEditorFn) (*MovieExternalIdsResponse, error)

	// MovieImagesWithResponse request
	MovieImagesWithResponse(ctx context.Context, movieID int32, params *MovieImagesParams, reqEditors ...RequestEditorFn) (*MovieImagesResponse, error)

	// MovieKeywordsWithResponse request
	MovieKeywordsWithResponse(ctx context.Context, movieID string, reqEditors ...RequestEditorFn) (*MovieKeywordsResponse, error)

	// MovieListsWithResponse request
	MovieListsWithResponse(ctx context.Context, movieID int32, params *MovieListsParams, reqEditors ...RequestEditorFn) (*MovieListsResponse, error)

	// MovieDeleteRatingWithResponse request
	MovieDeleteRatingWithResponse(ctx context.Context, movieID int32, params *MovieDeleteRatingParams, reqEditors ...RequestEditorFn) (*MovieDeleteRatingResponse, error)

	// MovieAddRatingWithBodyWithResponse request with any body
	MovieAddRatingWithBodyWithResponse(ctx context.Context, movieID int32, params *MovieAddRatingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MovieAddRatingResponse, error)

	MovieAddRatingWithResponse(ctx context.Context, movieID int32, params *MovieAddRatingParams, body MovieAddRatingJSONRequestBody, reqEditors ...RequestEditorFn) (*MovieAddRatingResponse, error)

	// MovieRecommendationsWithResponse request
	MovieRecommendationsWithResponse(ctx context.Context, movieID int32, params *MovieRecommendationsParams, reqEditors ...RequestEditorFn) (*MovieRecommendationsResponse, error)

	// MovieReleaseDatesWithResponse request
	MovieReleaseDatesWithResponse(ctx context.Context, movieID int32, reqEditors ...RequestEditorFn) (*MovieReleaseDatesResponse, error)

	// MovieReviewsWithResponse request
	MovieReviewsWithResponse(ctx context.Context, movieID int32, params *MovieReviewsParams, reqEditors ...RequestEditorFn) (*MovieReviewsResponse, error)

	// MovieSimilarWithResponse request
	MovieSimilarWithResponse(ctx context.Context, movieID int32, params *MovieSimilarParams, reqEditors ...RequestEditorFn) (*MovieSimilarResponse, error)

	// MovieTranslationsWithResponse request
	MovieTranslationsWithResponse(ctx context.Context, movieID int32, reqEditors ...RequestEditorFn) (*MovieTranslationsResponse, error)

	// MovieVideosWithResponse request
	MovieVideosWithResponse(ctx context.Context, movieID int32, params *MovieVideosParams, reqEditors ...RequestEditorFn) (*MovieVideosResponse, error)

	// MovieWatchProvidersWithResponse request
	MovieWatchProvidersWithResponse(ctx context.Context, movieID int32, reqEditors ...RequestEditorFn) (*MovieWatchProvidersResponse, error)

	// NetworkDetailsWithResponse request
	NetworkDetailsWithResponse(ctx context.Context, networkID int32, reqEditors ...RequestEditorFn) (*NetworkDetailsResponse, error)

	// DetailsCopyWithResponse request
	DetailsCopyWithResponse(ctx context.Context, networkID int32, reqEditors ...RequestEditorFn) (*DetailsCopyResponse, error)

	// AlternativeNamesCopyWithResponse request
	AlternativeNamesCopyWithResponse(ctx context.Context, networkID int32, reqEditors ...RequestEditorFn) (*AlternativeNamesCopyResponse, error)

	// ChangesPeopleListWithResponse request
	ChangesPeopleListWithResponse(ctx context.Context, params *ChangesPeopleListParams, reqEditors ...RequestEditorFn) (*ChangesPeopleListResponse, error)

	// PersonLatestIDWithResponse request
	PersonLatestIDWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PersonLatestIDResponse, error)

	// PersonPopularListWithResponse request
	PersonPopularListWithResponse(ctx context.Context, params *PersonPopularListParams, reqEditors ...RequestEditorFn) (*PersonPopularListResponse, error)

	// PersonDetailsWithResponse request
	PersonDetailsWithResponse(ctx context.Context, personID int32, params *PersonDetailsParams, reqEditors ...RequestEditorFn) (*PersonDetailsResponse, error)

	// PersonChangesWithResponse request
	PersonChangesWithResponse(ctx context.Context, personID int32, params *PersonChangesParams, reqEditors ...RequestEditorFn) (*PersonChangesResponse, error)

	// PersonCombinedCreditsWithResponse request
	PersonCombinedCreditsWithResponse(ctx context.Context, personID string, params *PersonCombinedCreditsParams, reqEditors ...RequestEditorFn) (*PersonCombinedCreditsResponse, error)

	// PersonExternalIdsWithResponse request
	PersonExternalIdsWithResponse(ctx context.Context, personID int32, reqEditors ...RequestEditorFn) (*PersonExternalIdsResponse, error)

	// PersonImagesWithResponse request
	PersonImagesWithResponse(ctx context.Context, personID int32, reqEditors ...RequestEditorFn) (*PersonImagesResponse, error)

	// PersonMovieCreditsWithResponse request
	PersonMovieCreditsWithResponse(ctx context.Context, personID int32, params *PersonMovieCreditsParams, reqEditors ...RequestEditorFn) (*PersonMovieCreditsResponse, error)

	// PersonTaggedImagesWithResponse request
	PersonTaggedImagesWithResponse(ctx context.Context, personID int32, params *PersonTaggedImagesParams, reqEditors ...RequestEditorFn) (*PersonTaggedImagesResponse, error)

	// TranslationsWithResponse request
	TranslationsWithResponse(ctx context.Context, personID int32, reqEditors ...RequestEditorFn) (*TranslationsResponse, error)

	// PersonTvCreditsWithResponse request
	PersonTvCreditsWithResponse(ctx context.Context, personID int32, params *PersonTvCreditsParams, reqEditors ...RequestEditorFn) (*PersonTvCreditsResponse, error)

	// ReviewDetailsWithResponse request
	ReviewDetailsWithResponse(ctx context.Context, reviewID string, reqEditors ...RequestEditorFn) (*ReviewDetailsResponse, error)

	// SearchCollectionWithResponse request
	SearchCollectionWithResponse(ctx context.Context, params *SearchCollectionParams, reqEditors ...RequestEditorFn) (*SearchCollectionResponse, error)

	// SearchCompanyWithResponse request
	SearchCompanyWithResponse(ctx context.Context, params *SearchCompanyParams, reqEditors ...RequestEditorFn) (*SearchCompanyResponse, error)

	// SearchKeywordWithResponse request
	SearchKeywordWithResponse(ctx context.Context, params *SearchKeywordParams, reqEditors ...RequestEditorFn) (*SearchKeywordResponse, error)

	// SearchMovieWithResponse request
	SearchMovieWithResponse(ctx context.Context, params *SearchMovieParams, reqEditors ...RequestEditorFn) (*SearchMovieResponse, error)

	// SearchMultiWithResponse request
	SearchMultiWithResponse(ctx context.Context, params *SearchMultiParams, reqEditors ...RequestEditorFn) (*SearchMultiResponse, error)

	// SearchPersonWithResponse request
	SearchPersonWithResponse(ctx context.Context, params *SearchPersonParams, reqEditors ...RequestEditorFn) (*SearchPersonResponse, error)

	// SearchTvWithResponse request
	SearchTvWithResponse(ctx context.Context, params *SearchTvParams, reqEditors ...RequestEditorFn) (*SearchTvResponse, error)

	// TrendingAllWithResponse request
	TrendingAllWithResponse(ctx context.Context, timeWindow TrendingAllParamsTimeWindow, params *TrendingAllParams, reqEditors ...RequestEditorFn) (*TrendingAllResponse, error)

	// TrendingMoviesWithResponse request
	TrendingMoviesWithResponse(ctx context.Context, timeWindow TrendingMoviesParamsTimeWindow, params *TrendingMoviesParams, reqEditors ...RequestEditorFn) (*TrendingMoviesResponse, error)

	// TrendingPeopleWithResponse request
	TrendingPeopleWithResponse(ctx context.Context, timeWindow TrendingPeopleParamsTimeWindow, params *TrendingPeopleParams, reqEditors ...RequestEditorFn) (*TrendingPeopleResponse, error)

	// TrendingTvWithResponse request
	TrendingTvWithResponse(ctx context.Context, timeWindow TrendingTvParamsTimeWindow, params *TrendingTvParams, reqEditors ...RequestEditorFn) (*TrendingTvResponse, error)

	// TvSeriesAiringTodayListWithResponse request
	TvSeriesAiringTodayListWithResponse(ctx context.Context, params *TvSeriesAiringTodayListParams, reqEditors ...RequestEditorFn) (*TvSeriesAiringTodayListResponse, error)

	// ChangesTvListWithResponse request
	ChangesTvListWithResponse(ctx context.Context, params *ChangesTvListParams, reqEditors ...RequestEditorFn) (*ChangesTvListResponse, error)

	// TvEpisodeChangesByIDWithResponse request
	TvEpisodeChangesByIDWithResponse(ctx context.Context, episodeID int32, reqEditors ...RequestEditorFn) (*TvEpisodeChangesByIDResponse, error)

	// TvEpisodeGroupDetailsWithResponse request
	TvEpisodeGroupDetailsWithResponse(ctx context.Context, tvEpisodeGroupID string, reqEditors ...RequestEditorFn) (*TvEpisodeGroupDetailsResponse, error)

	// TvSeriesLatestIDWithResponse request
	TvSeriesLatestIDWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*TvSeriesLatestIDResponse, error)

	// TvSeriesOnTheAirListWithResponse request
	TvSeriesOnTheAirListWithResponse(ctx context.Context, params *TvSeriesOnTheAirListParams, reqEditors ...RequestEditorFn) (*TvSeriesOnTheAirListResponse, error)

	// TvSeriesPopularListWithResponse request
	TvSeriesPopularListWithResponse(ctx context.Context, params *TvSeriesPopularListParams, reqEditors ...RequestEditorFn) (*TvSeriesPopularListResponse, error)

	// TvSeasonChangesByIDWithResponse request
	TvSeasonChangesByIDWithResponse(ctx context.Context, seasonID int32, params *TvSeasonChangesByIDParams, reqEditors ...RequestEditorFn) (*TvSeasonChangesByIDResponse, error)

	// TvSeriesTopRatedListWithResponse request
	TvSeriesTopRatedListWithResponse(ctx context.Context, params *TvSeriesTopRatedListParams, reqEditors ...RequestEditorFn) (*TvSeriesTopRatedListResponse, error)

	// TvSeriesDetailsWithResponse request
	TvSeriesDetailsWithResponse(ctx context.Context, seriesID int32, params *TvSeriesDetailsParams, reqEditors ...RequestEditorFn) (*TvSeriesDetailsResponse, error)

	// TvSeriesAccountStatesWithResponse request
	TvSeriesAccountStatesWithResponse(ctx context.Context, seriesID int32, params *TvSeriesAccountStatesParams, reqEditors ...RequestEditorFn) (*TvSeriesAccountStatesResponse, error)

	// TvSeriesAggregateCreditsWithResponse request
	TvSeriesAggregateCreditsWithResponse(ctx context.Context, seriesID int32, params *TvSeriesAggregateCreditsParams, reqEditors ...RequestEditorFn) (*TvSeriesAggregateCreditsResponse, error)

	// TvSeriesAlternativeTitlesWithResponse request
	TvSeriesAlternativeTitlesWithResponse(ctx context.Context, seriesID int32, reqEditors ...RequestEditorFn) (*TvSeriesAlternativeTitlesResponse, error)

	// TvSeriesChangesWithResponse request
	TvSeriesChangesWithResponse(ctx context.Context, seriesID int32, params *TvSeriesChangesParams, reqEditors ...RequestEditorFn) (*TvSeriesChangesResponse, error)

	// TvSeriesContentRatingsWithResponse request
	TvSeriesContentRatingsWithResponse(ctx context.Context, seriesID int32, reqEditors ...RequestEditorFn) (*TvSeriesContentRatingsResponse, error)

	// TvSeriesCreditsWithResponse request
	TvSeriesCreditsWithResponse(ctx context.Context, seriesID int32, params *TvSeriesCreditsParams, reqEditors ...RequestEditorFn) (*TvSeriesCreditsResponse, error)

	// TvSeriesEpisodeGroupsWithResponse request
	TvSeriesEpisodeGroupsWithResponse(ctx context.Context, seriesID int32, reqEditors ...RequestEditorFn) (*TvSeriesEpisodeGroupsResponse, error)

	// TvSeriesExternalIdsWithResponse request
	TvSeriesExternalIdsWithResponse(ctx context.Context, seriesID int32, reqEditors ...RequestEditorFn) (*TvSeriesExternalIdsResponse, error)

	// TvSeriesImagesWithResponse request
	TvSeriesImagesWithResponse(ctx context.Context, seriesID int32, params *TvSeriesImagesParams, reqEditors ...RequestEditorFn) (*TvSeriesImagesResponse, error)

	// TvSeriesKeywordsWithResponse request
	TvSeriesKeywordsWithResponse(ctx context.Context, seriesID int32, reqEditors ...RequestEditorFn) (*TvSeriesKeywordsResponse, error)

	// ListsCopyWithResponse request
	ListsCopyWithResponse(ctx context.Context, seriesID int32, params *ListsCopyParams, reqEditors ...RequestEditorFn) (*ListsCopyResponse, error)

	// TvSeriesDeleteRatingWithResponse request
	TvSeriesDeleteRatingWithResponse(ctx context.Context, seriesID int32, params *TvSeriesDeleteRatingParams, reqEditors ...RequestEditorFn) (*TvSeriesDeleteRatingResponse, error)

	// TvSeriesAddRatingWithBodyWithResponse request with any body
	TvSeriesAddRatingWithBodyWithResponse(ctx context.Context, seriesID int32, params *TvSeriesAddRatingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TvSeriesAddRatingResponse, error)

	TvSeriesAddRatingWithResponse(ctx context.Context, seriesID int32, params *TvSeriesAddRatingParams, body TvSeriesAddRatingJSONRequestBody, reqEditors ...RequestEditorFn) (*TvSeriesAddRatingResponse, error)

	// TvSeriesRecommendationsWithResponse request
	TvSeriesRecommendationsWithResponse(ctx context.Context, seriesID int32, params *TvSeriesRecommendationsParams, reqEditors ...RequestEditorFn) (*TvSeriesRecommendationsResponse, error)

	// TvSeriesReviewsWithResponse request
	TvSeriesReviewsWithResponse(ctx context.Context, seriesID int32, params *TvSeriesReviewsParams, reqEditors ...RequestEditorFn) (*TvSeriesReviewsResponse, error)

	// TvSeriesScreenedTheatricallyWithResponse request
	TvSeriesScreenedTheatricallyWithResponse(ctx context.Context, seriesID int32, reqEditors ...RequestEditorFn) (*TvSeriesScreenedTheatricallyResponse, error)

	// TvSeasonDetailsWithResponse request
	TvSeasonDetailsWithResponse(ctx context.Context, seriesID int32, seasonNumber int32, params *TvSeasonDetailsParams, reqEditors ...RequestEditorFn) (*TvSeasonDetailsResponse, error)

	// TvSeasonAccountStatesWithResponse request
	TvSeasonAccountStatesWithResponse(ctx context.Context, seriesID int32, seasonNumber int32, params *TvSeasonAccountStatesParams, reqEditors ...RequestEditorFn) (*TvSeasonAccountStatesResponse, error)

	// TvSeasonAggregateCreditsWithResponse request
	TvSeasonAggregateCreditsWithResponse(ctx context.Context, seriesID int32, seasonNumber int32, params *TvSeasonAggregateCreditsParams, reqEditors ...RequestEditorFn) (*TvSeasonAggregateCreditsResponse, error)

	// TvSeasonCreditsWithResponse request
	TvSeasonCreditsWithResponse(ctx context.Context, seriesID int32, seasonNumber int32, params *TvSeasonCreditsParams, reqEditors ...RequestEditorFn) (*TvSeasonCreditsResponse, error)

	// TvEpisodeDetailsWithResponse request
	TvEpisodeDetailsWithResponse(ctx context.Context, seriesID int32, seasonNumber int32, episodeNumber int32, params *TvEpisodeDetailsParams, reqEditors ...RequestEditorFn) (*TvEpisodeDetailsResponse, error)

	// TvEpisodeAccountStatesWithResponse request
	TvEpisodeAccountStatesWithResponse(ctx context.Context, seriesID int32, seasonNumber int32, episodeNumber int32, params *TvEpisodeAccountStatesParams, reqEditors ...RequestEditorFn) (*TvEpisodeAccountStatesResponse, error)

	// TvEpisodeCreditsWithResponse request
	TvEpisodeCreditsWithResponse(ctx context.Context, seriesID int32, seasonNumber int32, episodeNumber int32, params *TvEpisodeCreditsParams, reqEditors ...RequestEditorFn) (*TvEpisodeCreditsResponse, error)

	// TvEpisodeExternalIdsWithResponse request
	TvEpisodeExternalIdsWithResponse(ctx context.Context, seriesID int32, seasonNumber int32, episodeNumber string, reqEditors ...RequestEditorFn) (*TvEpisodeExternalIdsResponse, error)

	// TvEpisodeImagesWithResponse request
	TvEpisodeImagesWithResponse(ctx context.Context, seriesID int32, seasonNumber int32, episodeNumber int32, params *TvEpisodeImagesParams, reqEditors ...RequestEditorFn) (*TvEpisodeImagesResponse, error)

	// TvEpisodeDeleteRatingWithResponse request
	TvEpisodeDeleteRatingWithResponse(ctx context.Context, seriesID int32, seasonNumber int32, episodeNumber int32, params *TvEpisodeDeleteRatingParams, reqEditors ...RequestEditorFn) (*TvEpisodeDeleteRatingResponse, error)

	// TvEpisodeAddRatingWithBodyWithResponse request with any body
	TvEpisodeAddRatingWithBodyWithResponse(ctx context.Context, seriesID int32, seasonNumber int32, episodeNumber int32, params *TvEpisodeAddRatingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TvEpisodeAddRatingResponse, error)

	TvEpisodeAddRatingWithResponse(ctx context.Context, seriesID int32, seasonNumber int32, episodeNumber int32, params *TvEpisodeAddRatingParams, body TvEpisodeAddRatingJSONRequestBody, reqEditors ...RequestEditorFn) (*TvEpisodeAddRatingResponse, error)

	// TvEpisodeTranslationsWithResponse request
	TvEpisodeTranslationsWithResponse(ctx context.Context, seriesID int32, seasonNumber int32, episodeNumber int32, reqEditors ...RequestEditorFn) (*TvEpisodeTranslationsResponse, error)

	// TvEpisodeVideosWithResponse request
	TvEpisodeVideosWithResponse(ctx context.Context, seriesID int32, seasonNumber int32, episodeNumber int32, params *TvEpisodeVideosParams, reqEditors ...RequestEditorFn) (*TvEpisodeVideosResponse, error)

	// TvSeasonExternalIdsWithResponse request
	TvSeasonExternalIdsWithResponse(ctx context.Context, seriesID int32, seasonNumber int32, reqEditors ...RequestEditorFn) (*TvSeasonExternalIdsResponse, error)

	// TvSeasonImagesWithResponse request
	TvSeasonImagesWithResponse(ctx context.Context, seriesID int32, seasonNumber int32, params *TvSeasonImagesParams, reqEditors ...RequestEditorFn) (*TvSeasonImagesResponse, error)

	// TvSeasonTranslationsWithResponse request
	TvSeasonTranslationsWithResponse(ctx context.Context, seriesID int32, seasonNumber int32, reqEditors ...RequestEditorFn) (*TvSeasonTranslationsResponse, error)

	// TvSeasonVideosWithResponse request
	TvSeasonVideosWithResponse(ctx context.Context, seriesID int32, seasonNumber int32, params *TvSeasonVideosParams, reqEditors ...RequestEditorFn) (*TvSeasonVideosResponse, error)

	// TvSeasonWatchProvidersWithResponse request
	TvSeasonWatchProvidersWithResponse(ctx context.Context, seriesID int32, seasonNumber int32, params *TvSeasonWatchProvidersParams, reqEditors ...RequestEditorFn) (*TvSeasonWatchProvidersResponse, error)

	// TvSeriesSimilarWithResponse request
	TvSeriesSimilarWithResponse(ctx context.Context, seriesID string, params *TvSeriesSimilarParams, reqEditors ...RequestEditorFn) (*TvSeriesSimilarResponse, error)

	// TvSeriesTranslationsWithResponse request
	TvSeriesTranslationsWithResponse(ctx context.Context, seriesID int32, reqEditors ...RequestEditorFn) (*TvSeriesTranslationsResponse, error)

	// TvSeriesVideosWithResponse request
	TvSeriesVideosWithResponse(ctx context.Context, seriesID int32, params *TvSeriesVideosParams, reqEditors ...RequestEditorFn) (*TvSeriesVideosResponse, error)

	// TvSeriesWatchProvidersWithResponse request
	TvSeriesWatchProvidersWithResponse(ctx context.Context, seriesID int32, reqEditors ...RequestEditorFn) (*TvSeriesWatchProvidersResponse, error)

	// WatchProvidersMovieListWithResponse request
	WatchProvidersMovieListWithResponse(ctx context.Context, params *WatchProvidersMovieListParams, reqEditors ...RequestEditorFn) (*WatchProvidersMovieListResponse, error)

	// WatchProvidersAvailableRegionsWithResponse request
	WatchProvidersAvailableRegionsWithResponse(ctx context.Context, params *WatchProvidersAvailableRegionsParams, reqEditors ...RequestEditorFn) (*WatchProvidersAvailableRegionsResponse, error)

	// WatchProviderTvListWithResponse request
	WatchProviderTvListWithResponse(ctx context.Context, params *WatchProviderTvListParams, reqEditors ...RequestEditorFn) (*WatchProviderTvListResponse, error)
}

type AccountDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Avatar *struct {
			Gravatar *struct {
				Hash *string `json:"hash,omitempty"`
			} `json:"gravatar,omitempty"`
			Tmdb *struct {
				AvatarPath *string `json:"avatar_path,omitempty"`
			} `json:"tmdb,omitempty"`
		} `json:"avatar,omitempty"`
		ID           *int    `json:"id,omitempty"`
		IncludeAdult *bool   `json:"include_adult,omitempty"`
		Iso31661     *string `json:"iso_3166_1,omitempty"`
		Iso6391      *string `json:"iso_639_1,omitempty"`
		Name         *string `json:"name,omitempty"`
		Username     *string `json:"username,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r AccountDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AccountDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AccountAddFavoriteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		StatusCode    *int    `json:"status_code,omitempty"`
		StatusMessage *string `json:"status_message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r AccountAddFavoriteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AccountAddFavoriteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AccountGetFavoritesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Page    *int `json:"page,omitempty"`
		Results *[]struct {
			Adult            *bool    `json:"adult,omitempty"`
			BackdropPath     *string  `json:"backdrop_path,omitempty"`
			GenreIds         *[]int   `json:"genre_ids,omitempty"`
			ID               *int     `json:"id,omitempty"`
			OriginalLanguage *string  `json:"original_language,omitempty"`
			OriginalTitle    *string  `json:"original_title,omitempty"`
			Overview         *string  `json:"overview,omitempty"`
			Popularity       *float32 `json:"popularity,omitempty"`
			PosterPath       *string  `json:"poster_path,omitempty"`
			ReleaseDate      *string  `json:"release_date,omitempty"`
			Title            *string  `json:"title,omitempty"`
			Video            *bool    `json:"video,omitempty"`
			VoteAverage      *float32 `json:"vote_average,omitempty"`
			VoteCount        *int     `json:"vote_count,omitempty"`
		} `json:"results,omitempty"`
		TotalPages   *int `json:"total_pages,omitempty"`
		TotalResults *int `json:"total_results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r AccountGetFavoritesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AccountGetFavoritesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AccountFavoriteTvResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Page    *int `json:"page,omitempty"`
		Results *[]struct {
			Adult            *bool     `json:"adult,omitempty"`
			BackdropPath     *string   `json:"backdrop_path,omitempty"`
			FirstAirDate     *string   `json:"first_air_date,omitempty"`
			GenreIds         *[]int    `json:"genre_ids,omitempty"`
			ID               *int      `json:"id,omitempty"`
			Name             *string   `json:"name,omitempty"`
			OriginCountry    *[]string `json:"origin_country,omitempty"`
			OriginalLanguage *string   `json:"original_language,omitempty"`
			OriginalName     *string   `json:"original_name,omitempty"`
			Overview         *string   `json:"overview,omitempty"`
			Popularity       *float32  `json:"popularity,omitempty"`
			PosterPath       *string   `json:"poster_path,omitempty"`
			VoteAverage      *float32  `json:"vote_average,omitempty"`
			VoteCount        *int      `json:"vote_count,omitempty"`
		} `json:"results,omitempty"`
		TotalPages   *int `json:"total_pages,omitempty"`
		TotalResults *int `json:"total_results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r AccountFavoriteTvResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AccountFavoriteTvResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AccountListsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Page    *int `json:"page,omitempty"`
		Results *[]struct {
			Description   *string      `json:"description,omitempty"`
			FavoriteCount *int         `json:"favorite_count,omitempty"`
			ID            *int         `json:"id,omitempty"`
			Iso6391       *string      `json:"iso_639_1,omitempty"`
			ItemCount     *int         `json:"item_count,omitempty"`
			ListType      *string      `json:"list_type,omitempty"`
			Name          *string      `json:"name,omitempty"`
			PosterPath    *interface{} `json:"poster_path,omitempty"`
		} `json:"results,omitempty"`
		TotalPages   *int `json:"total_pages,omitempty"`
		TotalResults *int `json:"total_results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r AccountListsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AccountListsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AccountRatedMoviesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Page    *int `json:"page,omitempty"`
		Results *[]struct {
			Adult            *bool    `json:"adult,omitempty"`
			BackdropPath     *string  `json:"backdrop_path,omitempty"`
			GenreIds         *[]int   `json:"genre_ids,omitempty"`
			ID               *int     `json:"id,omitempty"`
			OriginalLanguage *string  `json:"original_language,omitempty"`
			OriginalTitle    *string  `json:"original_title,omitempty"`
			Overview         *string  `json:"overview,omitempty"`
			Popularity       *float32 `json:"popularity,omitempty"`
			PosterPath       *string  `json:"poster_path,omitempty"`
			Rating           *int     `json:"rating,omitempty"`
			ReleaseDate      *string  `json:"release_date,omitempty"`
			Title            *string  `json:"title,omitempty"`
			Video            *bool    `json:"video,omitempty"`
			VoteAverage      *float32 `json:"vote_average,omitempty"`
			VoteCount        *int     `json:"vote_count,omitempty"`
		} `json:"results,omitempty"`
		TotalPages   *int `json:"total_pages,omitempty"`
		TotalResults *int `json:"total_results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r AccountRatedMoviesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AccountRatedMoviesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AccountRatedTvResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Page    *int `json:"page,omitempty"`
		Results *[]struct {
			Adult            *bool     `json:"adult,omitempty"`
			BackdropPath     *string   `json:"backdrop_path,omitempty"`
			FirstAirDate     *string   `json:"first_air_date,omitempty"`
			GenreIds         *[]int    `json:"genre_ids,omitempty"`
			ID               *int      `json:"id,omitempty"`
			Name             *string   `json:"name,omitempty"`
			OriginCountry    *[]string `json:"origin_country,omitempty"`
			OriginalLanguage *string   `json:"original_language,omitempty"`
			OriginalName     *string   `json:"original_name,omitempty"`
			Overview         *string   `json:"overview,omitempty"`
			Popularity       *float32  `json:"popularity,omitempty"`
			PosterPath       *string   `json:"poster_path,omitempty"`
			Rating           *int      `json:"rating,omitempty"`
			VoteAverage      *float32  `json:"vote_average,omitempty"`
			VoteCount        *int      `json:"vote_count,omitempty"`
		} `json:"results,omitempty"`
		TotalPages   *int `json:"total_pages,omitempty"`
		TotalResults *int `json:"total_results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r AccountRatedTvResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AccountRatedTvResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AccountRatedTvEpisodesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Page    *int `json:"page,omitempty"`
		Results *[]struct {
			AirDate        *string  `json:"air_date,omitempty"`
			EpisodeNumber  *int     `json:"episode_number,omitempty"`
			ID             *int     `json:"id,omitempty"`
			Name           *string  `json:"name,omitempty"`
			Overview       *string  `json:"overview,omitempty"`
			ProductionCode *string  `json:"production_code,omitempty"`
			Rating         *int     `json:"rating,omitempty"`
			Runtime        *int     `json:"runtime,omitempty"`
			SeasonNumber   *int     `json:"season_number,omitempty"`
			ShowID         *int     `json:"show_id,omitempty"`
			StillPath      *string  `json:"still_path,omitempty"`
			VoteAverage    *float32 `json:"vote_average,omitempty"`
			VoteCount      *int     `json:"vote_count,omitempty"`
		} `json:"results,omitempty"`
		TotalPages   *int `json:"total_pages,omitempty"`
		TotalResults *int `json:"total_results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r AccountRatedTvEpisodesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AccountRatedTvEpisodesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AccountAddToWatchlistResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		StatusCode    *int    `json:"status_code,omitempty"`
		StatusMessage *string `json:"status_message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r AccountAddToWatchlistResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AccountAddToWatchlistResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AccountWatchlistMoviesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Page    *int `json:"page,omitempty"`
		Results *[]struct {
			Adult            *bool    `json:"adult,omitempty"`
			BackdropPath     *string  `json:"backdrop_path,omitempty"`
			GenreIds         *[]int   `json:"genre_ids,omitempty"`
			ID               *int     `json:"id,omitempty"`
			OriginalLanguage *string  `json:"original_language,omitempty"`
			OriginalTitle    *string  `json:"original_title,omitempty"`
			Overview         *string  `json:"overview,omitempty"`
			Popularity       *float32 `json:"popularity,omitempty"`
			PosterPath       *string  `json:"poster_path,omitempty"`
			ReleaseDate      *string  `json:"release_date,omitempty"`
			Title            *string  `json:"title,omitempty"`
			Video            *bool    `json:"video,omitempty"`
			VoteAverage      *float32 `json:"vote_average,omitempty"`
			VoteCount        *int     `json:"vote_count,omitempty"`
		} `json:"results,omitempty"`
		TotalPages   *int `json:"total_pages,omitempty"`
		TotalResults *int `json:"total_results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r AccountWatchlistMoviesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AccountWatchlistMoviesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AccountWatchlistTvResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Page    *int `json:"page,omitempty"`
		Results *[]struct {
			Adult            *bool     `json:"adult,omitempty"`
			BackdropPath     *string   `json:"backdrop_path,omitempty"`
			FirstAirDate     *string   `json:"first_air_date,omitempty"`
			GenreIds         *[]int    `json:"genre_ids,omitempty"`
			ID               *int      `json:"id,omitempty"`
			Name             *string   `json:"name,omitempty"`
			OriginCountry    *[]string `json:"origin_country,omitempty"`
			OriginalLanguage *string   `json:"original_language,omitempty"`
			OriginalName     *string   `json:"original_name,omitempty"`
			Overview         *string   `json:"overview,omitempty"`
			Popularity       *float32  `json:"popularity,omitempty"`
			PosterPath       *string   `json:"poster_path,omitempty"`
			VoteAverage      *float32  `json:"vote_average,omitempty"`
			VoteCount        *int      `json:"vote_count,omitempty"`
		} `json:"results,omitempty"`
		TotalPages   *int `json:"total_pages,omitempty"`
		TotalResults *int `json:"total_results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r AccountWatchlistTvResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AccountWatchlistTvResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AuthenticationValidateKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		StatusCode    *int    `json:"status_code,omitempty"`
		StatusMessage *string `json:"status_message,omitempty"`
		Success       *bool   `json:"success,omitempty"`
	}
	JSON401 *struct {
		StatusCode    *int    `json:"status_code,omitempty"`
		StatusMessage *string `json:"status_message,omitempty"`
		Success       *bool   `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r AuthenticationValidateKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AuthenticationValidateKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AuthenticationCreateGuestSessionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		ExpiresAt      *string `json:"expires_at,omitempty"`
		GuestSessionID *string `json:"guest_session_id,omitempty"`
		Success        *bool   `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r AuthenticationCreateGuestSessionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AuthenticationCreateGuestSessionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AuthenticationDeleteSessionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r AuthenticationDeleteSessionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AuthenticationDeleteSessionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AuthenticationCreateSessionFromV4TokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		SessionID *string `json:"session_id,omitempty"`
		Success   *bool   `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r AuthenticationCreateSessionFromV4TokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AuthenticationCreateSessionFromV4TokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AuthenticationCreateSessionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		SessionID *string `json:"session_id,omitempty"`
		Success   *bool   `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r AuthenticationCreateSessionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AuthenticationCreateSessionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AuthenticationCreateRequestTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		ExpiresAt    *string `json:"expires_at,omitempty"`
		RequestToken *string `json:"request_token,omitempty"`
		Success      *bool   `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r AuthenticationCreateRequestTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AuthenticationCreateRequestTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AuthenticationCreateSessionFromLoginResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		ExpiresAt    *string `json:"expires_at,omitempty"`
		RequestToken *string `json:"request_token,omitempty"`
		Success      *bool   `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r AuthenticationCreateSessionFromLoginResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AuthenticationCreateSessionFromLoginResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CertificationMovieListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Certifications *struct {
			AR *[]struct {
				Certification *string `json:"certification,omitempty"`
				Meaning       *string `json:"meaning,omitempty"`
				Order         *int    `json:"order,omitempty"`
			} `json:"AR,omitempty"`
			AU *[]struct {
				Certification *string `json:"certification,omitempty"`
				Meaning       *string `json:"meaning,omitempty"`
				Order         *int    `json:"order,omitempty"`
			} `json:"AU,omitempty"`
			BG *[]struct {
				Certification *string `json:"certification,omitempty"`
				Meaning       *string `json:"meaning,omitempty"`
				Order         *int    `json:"order,omitempty"`
			} `json:"BG,omitempty"`
			BR *[]struct {
				Certification *string `json:"certification,omitempty"`
				Meaning       *string `json:"meaning,omitempty"`
				Order         *int    `json:"order,omitempty"`
			} `json:"BR,omitempty"`
			CA *[]struct {
				Certification *string `json:"certification,omitempty"`
				Meaning       *string `json:"meaning,omitempty"`
				Order         *int    `json:"order,omitempty"`
			} `json:"CA,omitempty"`
			CAQC *[]struct {
				Certification *string `json:"certification,omitempty"`
				Meaning       *string `json:"meaning,omitempty"`
				Order         *int    `json:"order,omitempty"`
			} `json:"CA-QC,omitempty"`
			CH *[]struct {
				Certification *string `json:"certification,omitempty"`
				Meaning       *string `json:"meaning,omitempty"`
				Order         *int    `json:"order,omitempty"`
			} `json:"CH,omitempty"`
			DE *[]struct {
				Certification *string `json:"certification,omitempty"`
				Meaning       *string `json:"meaning,omitempty"`
				Order         *int    `json:"order,omitempty"`
			} `json:"DE,omitempty"`
			DK *[]struct {
				Certification *string `json:"certification,omitempty"`
				Meaning       *string `json:"meaning,omitempty"`
				Order         *int    `json:"order,omitempty"`
			} `json:"DK,omitempty"`
			ES *[]struct {
				Certification *string `json:"certification,omitempty"`
				Meaning       *string `json:"meaning,omitempty"`
				Order         *int    `json:"order,omitempty"`
			} `json:"ES,omitempty"`
			FI *[]struct {
				Certification *string `json:"certification,omitempty"`
				Meaning       *string `json:"meaning,omitempty"`
				Order         *int    `json:"order,omitempty"`
			} `json:"FI,omitempty"`
			FR *[]struct {
				Certification *string `json:"certification,omitempty"`
				Meaning       *string `json:"meaning,omitempty"`
				Order         *int    `json:"order,omitempty"`
			} `json:"FR,omitempty"`
			GB *[]struct {
				Certification *string `json:"certification,omitempty"`
				Meaning       *string `json:"meaning,omitempty"`
				Order         *int    `json:"order,omitempty"`
			} `json:"GB,omitempty"`
			GR *[]struct {
				Certification *string `json:"certification,omitempty"`
				Meaning       *string `json:"meaning,omitempty"`
				Order         *int    `json:"order,omitempty"`
			} `json:"GR,omitempty"`
			HK *[]struct {
				Certification *string `json:"certification,omitempty"`
				Meaning       *string `json:"meaning,omitempty"`
				Order         *int    `json:"order,omitempty"`
			} `json:"HK,omitempty"`
			HU *[]struct {
				Certification *string `json:"certification,omitempty"`
				Meaning       *string `json:"meaning,omitempty"`
				Order         *int    `json:"order,omitempty"`
			} `json:"HU,omitempty"`
			ID *[]struct {
				Certification *string `json:"certification,omitempty"`
				Meaning       *string `json:"meaning,omitempty"`
				Order         *int    `json:"order,omitempty"`
			} `json:"ID,omitempty"`
			IE *[]struct {
				Certification *string `json:"certification,omitempty"`
				Meaning       *string `json:"meaning,omitempty"`
				Order         *int    `json:"order,omitempty"`
			} `json:"IE,omitempty"`
			IL *[]struct {
				Certification *string `json:"certification,omitempty"`
				Meaning       *string `json:"meaning,omitempty"`
				Order         *int    `json:"order,omitempty"`
			} `json:"IL,omitempty"`
			IN *[]struct {
				Certification *string `json:"certification,omitempty"`
				Meaning       *string `json:"meaning,omitempty"`
				Order         *int    `json:"order,omitempty"`
			} `json:"IN,omitempty"`
			IT *[]struct {
				Certification *string `json:"certification,omitempty"`
				Meaning       *string `json:"meaning,omitempty"`
				Order         *int    `json:"order,omitempty"`
			} `json:"IT,omitempty"`
			JP *[]struct {
				Certification *string `json:"certification,omitempty"`
				Meaning       *string `json:"meaning,omitempty"`
				Order         *int    `json:"order,omitempty"`
			} `json:"JP,omitempty"`
			KR *[]struct {
				Certification *string `json:"certification,omitempty"`
				Meaning       *string `json:"meaning,omitempty"`
				Order         *int    `json:"order,omitempty"`
			} `json:"KR,omitempty"`
			LT *[]struct {
				Certification *string `json:"certification,omitempty"`
				Meaning       *string `json:"meaning,omitempty"`
				Order         *int    `json:"order,omitempty"`
			} `json:"LT,omitempty"`
			LU *[]struct {
				Certification *string `json:"certification,omitempty"`
				Meaning       *string `json:"meaning,omitempty"`
				Order         *int    `json:"order,omitempty"`
			} `json:"LU,omitempty"`
			LV *[]struct {
				Certification *string `json:"certification,omitempty"`
				Meaning       *string `json:"meaning,omitempty"`
				Order         *int    `json:"order,omitempty"`
			} `json:"LV,omitempty"`
			MO *[]struct {
				Certification *string `json:"certification,omitempty"`
				Meaning       *string `json:"meaning,omitempty"`
				Order         *int    `json:"order,omitempty"`
			} `json:"MO,omitempty"`
			MX *[]struct {
				Certification *string `json:"certification,omitempty"`
				Meaning       *string `json:"meaning,omitempty"`
				Order         *int    `json:"order,omitempty"`
			} `json:"MX,omitempty"`
			MY *[]struct {
				Certification *string `json:"certification,omitempty"`
				Meaning       *string `json:"meaning,omitempty"`
				Order         *int    `json:"order,omitempty"`
			} `json:"MY,omitempty"`
			NL *[]struct {
				Certification *string `json:"certification,omitempty"`
				Meaning       *string `json:"meaning,omitempty"`
				Order         *int    `json:"order,omitempty"`
			} `json:"NL,omitempty"`
			NO *[]struct {
				Certification *string `json:"certification,omitempty"`
				Meaning       *string `json:"meaning,omitempty"`
				Order         *int    `json:"order,omitempty"`
			} `json:"NO,omitempty"`
			NZ *[]struct {
				Certification *string `json:"certification,omitempty"`
				Meaning       *string `json:"meaning,omitempty"`
				Order         *int    `json:"order,omitempty"`
			} `json:"NZ,omitempty"`
			PH *[]struct {
				Certification *string `json:"certification,omitempty"`
				Meaning       *string `json:"meaning,omitempty"`
				Order         *int    `json:"order,omitempty"`
			} `json:"PH,omitempty"`
			PR *[]struct {
				Certification *string `json:"certification,omitempty"`
				Meaning       *string `json:"meaning,omitempty"`
				Order         *int    `json:"order,omitempty"`
			} `json:"PR,omitempty"`
			PT *[]struct {
				Certification *string `json:"certification,omitempty"`
				Meaning       *string `json:"meaning,omitempty"`
				Order         *int    `json:"order,omitempty"`
			} `json:"PT,omitempty"`
			RU *[]struct {
				Certification *string `json:"certification,omitempty"`
				Meaning       *string `json:"meaning,omitempty"`
				Order         *int    `json:"order,omitempty"`
			} `json:"RU,omitempty"`
			SE *[]struct {
				Certification *string `json:"certification,omitempty"`
				Meaning       *string `json:"meaning,omitempty"`
				Order         *int    `json:"order,omitempty"`
			} `json:"SE,omitempty"`
			SG *[]struct {
				Certification *string `json:"certification,omitempty"`
				Meaning       *string `json:"meaning,omitempty"`
				Order         *int    `json:"order,omitempty"`
			} `json:"SG,omitempty"`
			SK *[]struct {
				Certification *string `json:"certification,omitempty"`
				Meaning       *string `json:"meaning,omitempty"`
				Order         *int    `json:"order,omitempty"`
			} `json:"SK,omitempty"`
			TH *[]struct {
				Certification *string `json:"certification,omitempty"`
				Meaning       *string `json:"meaning,omitempty"`
				Order         *int    `json:"order,omitempty"`
			} `json:"TH,omitempty"`
			TR *[]struct {
				Certification *string `json:"certification,omitempty"`
				Meaning       *string `json:"meaning,omitempty"`
				Order         *int    `json:"order,omitempty"`
			} `json:"TR,omitempty"`
			TW *[]struct {
				Certification *string `json:"certification,omitempty"`
				Meaning       *string `json:"meaning,omitempty"`
				Order         *int    `json:"order,omitempty"`
			} `json:"TW,omitempty"`
			US *[]struct {
				Certification *string `json:"certification,omitempty"`
				Meaning       *string `json:"meaning,omitempty"`
				Order         *int    `json:"order,omitempty"`
			} `json:"US,omitempty"`
			VI *[]struct {
				Certification *string `json:"certification,omitempty"`
				Meaning       *string `json:"meaning,omitempty"`
				Order         *int    `json:"order,omitempty"`
			} `json:"VI,omitempty"`
			ZA *[]struct {
				Certification *string `json:"certification,omitempty"`
				Meaning       *string `json:"meaning,omitempty"`
				Order         *int    `json:"order,omitempty"`
			} `json:"ZA,omitempty"`
		} `json:"certifications,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CertificationMovieListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CertificationMovieListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CertificationsTvListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Certifications *struct {
			AR *[]struct {
				Certification *string `json:"certification,omitempty"`
				Meaning       *string `json:"meaning,omitempty"`
				Order         *int    `json:"order,omitempty"`
			} `json:"AR,omitempty"`
			AU *[]struct {
				Certification *string `json:"certification,omitempty"`
				Meaning       *string `json:"meaning,omitempty"`
				Order         *int    `json:"order,omitempty"`
			} `json:"AU,omitempty"`
			BG *[]struct {
				Certification *string `json:"certification,omitempty"`
				Meaning       *string `json:"meaning,omitempty"`
				Order         *int    `json:"order,omitempty"`
			} `json:"BG,omitempty"`
			BR *[]struct {
				Certification *string `json:"certification,omitempty"`
				Meaning       *string `json:"meaning,omitempty"`
				Order         *int    `json:"order,omitempty"`
			} `json:"BR,omitempty"`
			CA *[]struct {
				Certification *string `json:"certification,omitempty"`
				Meaning       *string `json:"meaning,omitempty"`
				Order         *int    `json:"order,omitempty"`
			} `json:"CA,omitempty"`
			CAQC *[]struct {
				Certification *string `json:"certification,omitempty"`
				Meaning       *string `json:"meaning,omitempty"`
				Order         *int    `json:"order,omitempty"`
			} `json:"CA-QC,omitempty"`
			DE *[]struct {
				Certification *string `json:"certification,omitempty"`
				Meaning       *string `json:"meaning,omitempty"`
				Order         *int    `json:"order,omitempty"`
			} `json:"DE,omitempty"`
			DK *[]struct {
				Certification *string `json:"certification,omitempty"`
				Meaning       *string `json:"meaning,omitempty"`
				Order         *int    `json:"order,omitempty"`
			} `json:"DK,omitempty"`
			ES *[]struct {
				Certification *string `json:"certification,omitempty"`
				Meaning       *string `json:"meaning,omitempty"`
				Order         *int    `json:"order,omitempty"`
			} `json:"ES,omitempty"`
			FI *[]struct {
				Certification *string `json:"certification,omitempty"`
				Meaning       *string `json:"meaning,omitempty"`
				Order         *int    `json:"order,omitempty"`
			} `json:"FI,omitempty"`
			FR *[]struct {
				Certification *string `json:"certification,omitempty"`
				Meaning       *string `json:"meaning,omitempty"`
				Order         *int    `json:"order,omitempty"`
			} `json:"FR,omitempty"`
			GB *[]struct {
				Certification *string `json:"certification,omitempty"`
				Meaning       *string `json:"meaning,omitempty"`
				Order         *int    `json:"order,omitempty"`
			} `json:"GB,omitempty"`
			GR *[]struct {
				Certification *string `json:"certification,omitempty"`
				Meaning       *string `json:"meaning,omitempty"`
				Order         *int    `json:"order,omitempty"`
			} `json:"GR,omitempty"`
			HU *[]struct {
				Certification *string `json:"certification,omitempty"`
				Meaning       *string `json:"meaning,omitempty"`
				Order         *int    `json:"order,omitempty"`
			} `json:"HU,omitempty"`
			ID *[]struct {
				Certification *string `json:"certification,omitempty"`
				Meaning       *string `json:"meaning,omitempty"`
				Order         *int    `json:"order,omitempty"`
			} `json:"ID,omitempty"`
			IL *[]struct {
				Certification *string `json:"certification,omitempty"`
				Meaning       *string `json:"meaning,omitempty"`
				Order         *int    `json:"order,omitempty"`
			} `json:"IL,omitempty"`
			IN *[]struct {
				Certification *string `json:"certification,omitempty"`
				Meaning       *string `json:"meaning,omitempty"`
				Order         *int    `json:"order,omitempty"`
			} `json:"IN,omitempty"`
			IT *[]struct {
				Certification *string `json:"certification,omitempty"`
				Meaning       *string `json:"meaning,omitempty"`
				Order         *int    `json:"order,omitempty"`
			} `json:"IT,omitempty"`
			KR *[]struct {
				Certification *string `json:"certification,omitempty"`
				Meaning       *string `json:"meaning,omitempty"`
				Order         *int    `json:"order,omitempty"`
			} `json:"KR,omitempty"`
			LT *[]struct {
				Certification *string `json:"certification,omitempty"`
				Meaning       *string `json:"meaning,omitempty"`
				Order         *int    `json:"order,omitempty"`
			} `json:"LT,omitempty"`
			MA *[]struct {
				Certification *string `json:"certification,omitempty"`
				Meaning       *string `json:"meaning,omitempty"`
				Order         *int    `json:"order,omitempty"`
			} `json:"MA,omitempty"`
			MX *[]struct {
				Certification *string `json:"certification,omitempty"`
				Meaning       *string `json:"meaning,omitempty"`
				Order         *int    `json:"order,omitempty"`
			} `json:"MX,omitempty"`
			MY *[]struct {
				Certification *string `json:"certification,omitempty"`
				Meaning       *string `json:"meaning,omitempty"`
				Order         *int    `json:"order,omitempty"`
			} `json:"MY,omitempty"`
			NL *[]struct {
				Certification *string `json:"certification,omitempty"`
				Meaning       *string `json:"meaning,omitempty"`
				Order         *int    `json:"order,omitempty"`
			} `json:"NL,omitempty"`
			NO *[]struct {
				Certification *string `json:"certification,omitempty"`
				Meaning       *string `json:"meaning,omitempty"`
				Order         *int    `json:"order,omitempty"`
			} `json:"NO,omitempty"`
			NZ *[]struct {
				Certification *string `json:"certification,omitempty"`
				Meaning       *string `json:"meaning,omitempty"`
				Order         *int    `json:"order,omitempty"`
			} `json:"NZ,omitempty"`
			PH *[]struct {
				Certification *string `json:"certification,omitempty"`
				Meaning       *string `json:"meaning,omitempty"`
				Order         *int    `json:"order,omitempty"`
			} `json:"PH,omitempty"`
			PL *[]struct {
				Certification *string `json:"certification,omitempty"`
				Meaning       *string `json:"meaning,omitempty"`
				Order         *int    `json:"order,omitempty"`
			} `json:"PL,omitempty"`
			PR *[]struct {
				Certification *string `json:"certification,omitempty"`
				Meaning       *string `json:"meaning,omitempty"`
				Order         *int    `json:"order,omitempty"`
			} `json:"PR,omitempty"`
			PT *[]struct {
				Certification *string `json:"certification,omitempty"`
				Meaning       *string `json:"meaning,omitempty"`
				Order         *int    `json:"order,omitempty"`
			} `json:"PT,omitempty"`
			RU *[]struct {
				Certification *string `json:"certification,omitempty"`
				Meaning       *string `json:"meaning,omitempty"`
				Order         *int    `json:"order,omitempty"`
			} `json:"RU,omitempty"`
			SE *[]struct {
				Certification *string `json:"certification,omitempty"`
				Meaning       *string `json:"meaning,omitempty"`
				Order         *int    `json:"order,omitempty"`
			} `json:"SE,omitempty"`
			SG *[]struct {
				Certification *string `json:"certification,omitempty"`
				Meaning       *string `json:"meaning,omitempty"`
				Order         *int    `json:"order,omitempty"`
			} `json:"SG,omitempty"`
			SK *[]struct {
				Certification *string `json:"certification,omitempty"`
				Meaning       *string `json:"meaning,omitempty"`
				Order         *int    `json:"order,omitempty"`
			} `json:"SK,omitempty"`
			TH *[]struct {
				Certification *string `json:"certification,omitempty"`
				Meaning       *string `json:"meaning,omitempty"`
				Order         *int    `json:"order,omitempty"`
			} `json:"TH,omitempty"`
			TR *[]struct {
				Certification *string `json:"certification,omitempty"`
				Meaning       *string `json:"meaning,omitempty"`
				Order         *int    `json:"order,omitempty"`
			} `json:"TR,omitempty"`
			TW *[]struct {
				Certification *string `json:"certification,omitempty"`
				Meaning       *string `json:"meaning,omitempty"`
				Order         *int    `json:"order,omitempty"`
			} `json:"TW,omitempty"`
			US *[]struct {
				Certification *string `json:"certification,omitempty"`
				Meaning       *string `json:"meaning,omitempty"`
				Order         *int    `json:"order,omitempty"`
			} `json:"US,omitempty"`
			VI *[]struct {
				Certification *string `json:"certification,omitempty"`
				Meaning       *string `json:"meaning,omitempty"`
				Order         *int    `json:"order,omitempty"`
			} `json:"VI,omitempty"`
			ZA *[]struct {
				Certification *string `json:"certification,omitempty"`
				Meaning       *string `json:"meaning,omitempty"`
				Order         *int    `json:"order,omitempty"`
			} `json:"ZA,omitempty"`
		} `json:"certifications,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CertificationsTvListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CertificationsTvListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CollectionDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		BackdropPath *string `json:"backdrop_path,omitempty"`
		ID           *int    `json:"id,omitempty"`
		Name         *string `json:"name,omitempty"`
		Overview     *string `json:"overview,omitempty"`
		Parts        *[]struct {
			Adult            *bool    `json:"adult,omitempty"`
			BackdropPath     *string  `json:"backdrop_path,omitempty"`
			GenreIds         *[]int   `json:"genre_ids,omitempty"`
			ID               *int     `json:"id,omitempty"`
			MediaType        *string  `json:"media_type,omitempty"`
			OriginalLanguage *string  `json:"original_language,omitempty"`
			OriginalTitle    *string  `json:"original_title,omitempty"`
			Overview         *string  `json:"overview,omitempty"`
			Popularity       *float32 `json:"popularity,omitempty"`
			PosterPath       *string  `json:"poster_path,omitempty"`
			ReleaseDate      *string  `json:"release_date,omitempty"`
			Title            *string  `json:"title,omitempty"`
			Video            *bool    `json:"video,omitempty"`
			VoteAverage      *float32 `json:"vote_average,omitempty"`
			VoteCount        *int     `json:"vote_count,omitempty"`
		} `json:"parts,omitempty"`
		PosterPath *string `json:"poster_path,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CollectionDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CollectionDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CollectionImagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Backdrops *[]struct {
			AspectRatio *float32     `json:"aspect_ratio,omitempty"`
			FilePath    *string      `json:"file_path,omitempty"`
			Height      *int         `json:"height,omitempty"`
			Iso6391     *interface{} `json:"iso_639_1,omitempty"`
			VoteAverage *float32     `json:"vote_average,omitempty"`
			VoteCount   *int         `json:"vote_count,omitempty"`
			Width       *int         `json:"width,omitempty"`
		} `json:"backdrops,omitempty"`
		ID      *int `json:"id,omitempty"`
		Posters *[]struct {
			AspectRatio *float32 `json:"aspect_ratio,omitempty"`
			FilePath    *string  `json:"file_path,omitempty"`
			Height      *int     `json:"height,omitempty"`
			Iso6391     *string  `json:"iso_639_1,omitempty"`
			VoteAverage *float32 `json:"vote_average,omitempty"`
			VoteCount   *int     `json:"vote_count,omitempty"`
			Width       *int     `json:"width,omitempty"`
		} `json:"posters,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CollectionImagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CollectionImagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CollectionTranslationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		ID           *int `json:"id,omitempty"`
		Translations *[]struct {
			Data *struct {
				Homepage *string `json:"homepage,omitempty"`
				Overview *string `json:"overview,omitempty"`
				Title    *string `json:"title,omitempty"`
			} `json:"data,omitempty"`
			EnglishName *string `json:"english_name,omitempty"`
			Iso31661    *string `json:"iso_3166_1,omitempty"`
			Iso6391     *string `json:"iso_639_1,omitempty"`
			Name        *string `json:"name,omitempty"`
		} `json:"translations,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CollectionTranslationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CollectionTranslationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CompanyDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Description   *string      `json:"description,omitempty"`
		Headquarters  *string      `json:"headquarters,omitempty"`
		Homepage      *string      `json:"homepage,omitempty"`
		ID            *int         `json:"id,omitempty"`
		LogoPath      *string      `json:"logo_path,omitempty"`
		Name          *string      `json:"name,omitempty"`
		OriginCountry *string      `json:"origin_country,omitempty"`
		ParentCompany *interface{} `json:"parent_company,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CompanyDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CompanyDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CompanyAlternativeNamesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		ID      *int `json:"id,omitempty"`
		Results *[]struct {
			Name *string `json:"name,omitempty"`
			Type *string `json:"type,omitempty"`
		} `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CompanyAlternativeNamesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CompanyAlternativeNamesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CompanyImagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		ID    *int `json:"id,omitempty"`
		Logos *[]struct {
			AspectRatio *float32 `json:"aspect_ratio,omitempty"`
			FilePath    *string  `json:"file_path,omitempty"`
			FileType    *string  `json:"file_type,omitempty"`
			Height      *int     `json:"height,omitempty"`
			ID          *string  `json:"id,omitempty"`
			VoteAverage *float32 `json:"vote_average,omitempty"`
			VoteCount   *int     `json:"vote_count,omitempty"`
			Width       *int     `json:"width,omitempty"`
		} `json:"logos,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CompanyImagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CompanyImagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ConfigurationDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		ChangeKeys *[]string `json:"change_keys,omitempty"`
		Images     *struct {
			BackdropSizes *[]string `json:"backdrop_sizes,omitempty"`
			BaseURL       *string   `json:"base_url,omitempty"`
			LogoSizes     *[]string `json:"logo_sizes,omitempty"`
			PosterSizes   *[]string `json:"poster_sizes,omitempty"`
			ProfileSizes  *[]string `json:"profile_sizes,omitempty"`
			SecureBaseURL *string   `json:"secure_base_url,omitempty"`
			StillSizes    *[]string `json:"still_sizes,omitempty"`
		} `json:"images,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ConfigurationDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ConfigurationDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ConfigurationCountriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		EnglishName *string `json:"english_name,omitempty"`
		Iso31661    *string `json:"iso_3166_1,omitempty"`
		NativeName  *string `json:"native_name,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ConfigurationCountriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ConfigurationCountriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ConfigurationJobsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		Department *string   `json:"department,omitempty"`
		Jobs       *[]string `json:"jobs,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ConfigurationJobsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ConfigurationJobsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ConfigurationLanguagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		EnglishName *string `json:"english_name,omitempty"`
		Iso6391     *string `json:"iso_639_1,omitempty"`
		Name        *string `json:"name,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ConfigurationLanguagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ConfigurationLanguagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ConfigurationPrimaryTranslationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r ConfigurationPrimaryTranslationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ConfigurationPrimaryTranslationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ConfigurationTimezonesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		Iso31661 *string   `json:"iso_3166_1,omitempty"`
		Zones    *[]string `json:"zones,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ConfigurationTimezonesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ConfigurationTimezonesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreditDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		CreditType *string `json:"credit_type,omitempty"`
		Department *string `json:"department,omitempty"`
		ID         *string `json:"id,omitempty"`
		Job        *string `json:"job,omitempty"`
		Media      *struct {
			Adult            *bool          `json:"adult,omitempty"`
			BackdropPath     *string        `json:"backdrop_path,omitempty"`
			Character        *string        `json:"character,omitempty"`
			Episodes         *[]interface{} `json:"episodes,omitempty"`
			FirstAirDate     *string        `json:"first_air_date,omitempty"`
			GenreIds         *[]int         `json:"genre_ids,omitempty"`
			ID               *int           `json:"id,omitempty"`
			MediaType        *string        `json:"media_type,omitempty"`
			Name             *string        `json:"name,omitempty"`
			OriginCountry    *[]string      `json:"origin_country,omitempty"`
			OriginalLanguage *string        `json:"original_language,omitempty"`
			OriginalName     *string        `json:"original_name,omitempty"`
			Overview         *string        `json:"overview,omitempty"`
			Popularity       *float32       `json:"popularity,omitempty"`
			PosterPath       *string        `json:"poster_path,omitempty"`
			Seasons          *[]struct {
				AirDate      *string `json:"air_date,omitempty"`
				EpisodeCount *int    `json:"episode_count,omitempty"`
				ID           *int    `json:"id,omitempty"`
				Name         *string `json:"name,omitempty"`
				Overview     *string `json:"overview,omitempty"`
				PosterPath   *string `json:"poster_path,omitempty"`
				SeasonNumber *int    `json:"season_number,omitempty"`
				ShowID       *int    `json:"show_id,omitempty"`
			} `json:"seasons,omitempty"`
			VoteAverage *float32 `json:"vote_average,omitempty"`
			VoteCount   *int     `json:"vote_count,omitempty"`
		} `json:"media,omitempty"`
		MediaType *string `json:"media_type,omitempty"`
		Person    *struct {
			Adult              *bool    `json:"adult,omitempty"`
			Gender             *int     `json:"gender,omitempty"`
			ID                 *int     `json:"id,omitempty"`
			KnownForDepartment *string  `json:"known_for_department,omitempty"`
			MediaType          *string  `json:"media_type,omitempty"`
			Name               *string  `json:"name,omitempty"`
			OriginalName       *string  `json:"original_name,omitempty"`
			Popularity         *float32 `json:"popularity,omitempty"`
			ProfilePath        *string  `json:"profile_path,omitempty"`
		} `json:"person,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CreditDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreditDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DiscoverMovieResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Page    *int `json:"page,omitempty"`
		Results *[]struct {
			Adult            *bool    `json:"adult,omitempty"`
			BackdropPath     *string  `json:"backdrop_path,omitempty"`
			GenreIds         *[]int   `json:"genre_ids,omitempty"`
			ID               *int     `json:"id,omitempty"`
			OriginalLanguage *string  `json:"original_language,omitempty"`
			OriginalTitle    *string  `json:"original_title,omitempty"`
			Overview         *string  `json:"overview,omitempty"`
			Popularity       *float32 `json:"popularity,omitempty"`
			PosterPath       *string  `json:"poster_path,omitempty"`
			ReleaseDate      *string  `json:"release_date,omitempty"`
			Title            *string  `json:"title,omitempty"`
			Video            *bool    `json:"video,omitempty"`
			VoteAverage      *float32 `json:"vote_average,omitempty"`
			VoteCount        *int     `json:"vote_count,omitempty"`
		} `json:"results,omitempty"`
		TotalPages   *int `json:"total_pages,omitempty"`
		TotalResults *int `json:"total_results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DiscoverMovieResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DiscoverMovieResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DiscoverTvResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Page    *int `json:"page,omitempty"`
		Results *[]struct {
			BackdropPath     *string   `json:"backdrop_path,omitempty"`
			FirstAirDate     *string   `json:"first_air_date,omitempty"`
			GenreIds         *[]int    `json:"genre_ids,omitempty"`
			ID               *int      `json:"id,omitempty"`
			Name             *string   `json:"name,omitempty"`
			OriginCountry    *[]string `json:"origin_country,omitempty"`
			OriginalLanguage *string   `json:"original_language,omitempty"`
			OriginalName     *string   `json:"original_name,omitempty"`
			Overview         *string   `json:"overview,omitempty"`
			Popularity       *float32  `json:"popularity,omitempty"`
			PosterPath       *string   `json:"poster_path,omitempty"`
			VoteAverage      *int      `json:"vote_average,omitempty"`
			VoteCount        *int      `json:"vote_count,omitempty"`
		} `json:"results,omitempty"`
		TotalPages   *int `json:"total_pages,omitempty"`
		TotalResults *int `json:"total_results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DiscoverTvResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DiscoverTvResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindByIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		MovieResults *[]struct {
			Adult            *bool    `json:"adult,omitempty"`
			BackdropPath     *string  `json:"backdrop_path,omitempty"`
			GenreIds         *[]int   `json:"genre_ids,omitempty"`
			ID               *int     `json:"id,omitempty"`
			MediaType        *string  `json:"media_type,omitempty"`
			OriginalLanguage *string  `json:"original_language,omitempty"`
			OriginalTitle    *string  `json:"original_title,omitempty"`
			Overview         *string  `json:"overview,omitempty"`
			Popularity       *float32 `json:"popularity,omitempty"`
			PosterPath       *string  `json:"poster_path,omitempty"`
			ReleaseDate      *string  `json:"release_date,omitempty"`
			Title            *string  `json:"title,omitempty"`
			Video            *bool    `json:"video,omitempty"`
			VoteAverage      *float32 `json:"vote_average,omitempty"`
			VoteCount        *int     `json:"vote_count,omitempty"`
		} `json:"movie_results,omitempty"`
		PersonResults    *[]interface{} `json:"person_results,omitempty"`
		TvEpisodeResults *[]interface{} `json:"tv_episode_results,omitempty"`
		TvResults        *[]interface{} `json:"tv_results,omitempty"`
		TvSeasonResults  *[]interface{} `json:"tv_season_results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r FindByIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindByIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GenreMovieListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Genres *[]struct {
			ID   *int    `json:"id,omitempty"`
			Name *string `json:"name,omitempty"`
		} `json:"genres,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GenreMovieListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GenreMovieListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GenreTvListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Genres *[]struct {
			ID   *int    `json:"id,omitempty"`
			Name *string `json:"name,omitempty"`
		} `json:"genres,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GenreTvListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GenreTvListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GuestSessionRatedMoviesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Page    *int `json:"page,omitempty"`
		Results *[]struct {
			Adult            *bool    `json:"adult,omitempty"`
			BackdropPath     *string  `json:"backdrop_path,omitempty"`
			GenreIds         *[]int   `json:"genre_ids,omitempty"`
			ID               *int     `json:"id,omitempty"`
			OriginalLanguage *string  `json:"original_language,omitempty"`
			OriginalTitle    *string  `json:"original_title,omitempty"`
			Overview         *string  `json:"overview,omitempty"`
			Popularity       *float32 `json:"popularity,omitempty"`
			PosterPath       *string  `json:"poster_path,omitempty"`
			Rating           *float32 `json:"rating,omitempty"`
			ReleaseDate      *string  `json:"release_date,omitempty"`
			Title            *string  `json:"title,omitempty"`
			Video            *bool    `json:"video,omitempty"`
			VoteAverage      *float32 `json:"vote_average,omitempty"`
			VoteCount        *int     `json:"vote_count,omitempty"`
		} `json:"results,omitempty"`
		TotalPages   *int `json:"total_pages,omitempty"`
		TotalResults *int `json:"total_results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GuestSessionRatedMoviesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GuestSessionRatedMoviesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GuestSessionRatedTvResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Page    *int `json:"page,omitempty"`
		Results *[]struct {
			Adult            *bool     `json:"adult,omitempty"`
			BackdropPath     *string   `json:"backdrop_path,omitempty"`
			FirstAirDate     *string   `json:"first_air_date,omitempty"`
			GenreIds         *[]int    `json:"genre_ids,omitempty"`
			ID               *int      `json:"id,omitempty"`
			Name             *string   `json:"name,omitempty"`
			OriginCountry    *[]string `json:"origin_country,omitempty"`
			OriginalLanguage *string   `json:"original_language,omitempty"`
			OriginalName     *string   `json:"original_name,omitempty"`
			Overview         *string   `json:"overview,omitempty"`
			Popularity       *float32  `json:"popularity,omitempty"`
			PosterPath       *string   `json:"poster_path,omitempty"`
			Rating           *float32  `json:"rating,omitempty"`
			VoteAverage      *float32  `json:"vote_average,omitempty"`
			VoteCount        *int      `json:"vote_count,omitempty"`
		} `json:"results,omitempty"`
		TotalPages   *int `json:"total_pages,omitempty"`
		TotalResults *int `json:"total_results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GuestSessionRatedTvResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GuestSessionRatedTvResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GuestSessionRatedTvEpisodesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Page    *int `json:"page,omitempty"`
		Results *[]struct {
			AirDate        *string  `json:"air_date,omitempty"`
			EpisodeNumber  *int     `json:"episode_number,omitempty"`
			ID             *int     `json:"id,omitempty"`
			Name           *string  `json:"name,omitempty"`
			Overview       *string  `json:"overview,omitempty"`
			ProductionCode *string  `json:"production_code,omitempty"`
			Rating         *float32 `json:"rating,omitempty"`
			Runtime        *int     `json:"runtime,omitempty"`
			SeasonNumber   *int     `json:"season_number,omitempty"`
			ShowID         *int     `json:"show_id,omitempty"`
			StillPath      *string  `json:"still_path,omitempty"`
			VoteAverage    *float32 `json:"vote_average,omitempty"`
			VoteCount      *int     `json:"vote_count,omitempty"`
		} `json:"results,omitempty"`
		TotalPages   *int `json:"total_pages,omitempty"`
		TotalResults *int `json:"total_results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GuestSessionRatedTvEpisodesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GuestSessionRatedTvEpisodesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type KeywordDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		ID   *int    `json:"id,omitempty"`
		Name *string `json:"name,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r KeywordDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r KeywordDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type KeywordMoviesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		ID      *int `json:"id,omitempty"`
		Page    *int `json:"page,omitempty"`
		Results *[]struct {
			Adult            *bool    `json:"adult,omitempty"`
			BackdropPath     *string  `json:"backdrop_path,omitempty"`
			GenreIds         *[]int   `json:"genre_ids,omitempty"`
			ID               *int     `json:"id,omitempty"`
			OriginalLanguage *string  `json:"original_language,omitempty"`
			OriginalTitle    *string  `json:"original_title,omitempty"`
			Overview         *string  `json:"overview,omitempty"`
			Popularity       *float32 `json:"popularity,omitempty"`
			PosterPath       *string  `json:"poster_path,omitempty"`
			ReleaseDate      *string  `json:"release_date,omitempty"`
			Title            *string  `json:"title,omitempty"`
			Video            *bool    `json:"video,omitempty"`
			VoteAverage      *float32 `json:"vote_average,omitempty"`
			VoteCount        *int     `json:"vote_count,omitempty"`
		} `json:"results,omitempty"`
		TotalPages   *int `json:"total_pages,omitempty"`
		TotalResults *int `json:"total_results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r KeywordMoviesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r KeywordMoviesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		ListID        *int    `json:"list_id,omitempty"`
		StatusCode    *int    `json:"status_code,omitempty"`
		StatusMessage *string `json:"status_message,omitempty"`
		Success       *bool   `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		StatusCode    *int    `json:"status_code,omitempty"`
		StatusMessage *string `json:"status_message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		CreatedBy     *string `json:"created_by,omitempty"`
		Description   *string `json:"description,omitempty"`
		FavoriteCount *int    `json:"favorite_count,omitempty"`
		ID            *string `json:"id,omitempty"`
		Iso6391       *string `json:"iso_639_1,omitempty"`
		ItemCount     *int    `json:"item_count,omitempty"`
		Items         *[]struct {
			Adult            *bool    `json:"adult,omitempty"`
			BackdropPath     *string  `json:"backdrop_path,omitempty"`
			GenreIds         *[]int   `json:"genre_ids,omitempty"`
			ID               *int     `json:"id,omitempty"`
			MediaType        *string  `json:"media_type,omitempty"`
			OriginalLanguage *string  `json:"original_language,omitempty"`
			OriginalTitle    *string  `json:"original_title,omitempty"`
			Overview         *string  `json:"overview,omitempty"`
			Popularity       *float32 `json:"popularity,omitempty"`
			PosterPath       *string  `json:"poster_path,omitempty"`
			ReleaseDate      *string  `json:"release_date,omitempty"`
			Title            *string  `json:"title,omitempty"`
			Video            *bool    `json:"video,omitempty"`
			VoteAverage      *int     `json:"vote_average,omitempty"`
			VoteCount        *int     `json:"vote_count,omitempty"`
		} `json:"items,omitempty"`
		Name       *string `json:"name,omitempty"`
		PosterPath *string `json:"poster_path,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAddMovieResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		StatusCode    *int    `json:"status_code,omitempty"`
		StatusMessage *string `json:"status_message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListAddMovieResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAddMovieResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListClearResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		StatusCode    *int    `json:"status_code,omitempty"`
		StatusMessage *string `json:"status_message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListClearResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListClearResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListCheckItemStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		ID          *int  `json:"id,omitempty"`
		ItemPresent *bool `json:"item_present,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListCheckItemStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListCheckItemStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListRemoveMovieResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		StatusCode    *int    `json:"status_code,omitempty"`
		StatusMessage *string `json:"status_message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListRemoveMovieResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListRemoveMovieResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ChangesMovieListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Page    *int `json:"page,omitempty"`
		Results *[]struct {
			Adult *bool `json:"adult,omitempty"`
			ID    *int  `json:"id,omitempty"`
		} `json:"results,omitempty"`
		TotalPages   *int `json:"total_pages,omitempty"`
		TotalResults *int `json:"total_results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ChangesMovieListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ChangesMovieListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MovieLatestIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Adult               *bool          `json:"adult,omitempty"`
		BackdropPath        *interface{}   `json:"backdrop_path,omitempty"`
		BelongsToCollection *interface{}   `json:"belongs_to_collection,omitempty"`
		Budget              *int           `json:"budget,omitempty"`
		Genres              *[]interface{} `json:"genres,omitempty"`
		Homepage            *string        `json:"homepage,omitempty"`
		ID                  *int           `json:"id,omitempty"`
		ImdbID              *interface{}   `json:"imdb_id,omitempty"`
		OriginalLanguage    *string        `json:"original_language,omitempty"`
		OriginalTitle       *string        `json:"original_title,omitempty"`
		Overview            *string        `json:"overview,omitempty"`
		Popularity          *int           `json:"popularity,omitempty"`
		PosterPath          *interface{}   `json:"poster_path,omitempty"`
		ProductionCompanies *[]interface{} `json:"production_companies,omitempty"`
		ProductionCountries *[]interface{} `json:"production_countries,omitempty"`
		ReleaseDate         *string        `json:"release_date,omitempty"`
		Revenue             *int           `json:"revenue,omitempty"`
		Runtime             *int           `json:"runtime,omitempty"`
		SpokenLanguages     *[]interface{} `json:"spoken_languages,omitempty"`
		Status              *string        `json:"status,omitempty"`
		Tagline             *string        `json:"tagline,omitempty"`
		Title               *string        `json:"title,omitempty"`
		Video               *bool          `json:"video,omitempty"`
		VoteAverage         *int           `json:"vote_average,omitempty"`
		VoteCount           *int           `json:"vote_count,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r MovieLatestIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MovieLatestIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MovieNowPlayingListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Dates *struct {
			Maximum *string `json:"maximum,omitempty"`
			Minimum *string `json:"minimum,omitempty"`
		} `json:"dates,omitempty"`
		Page    *int `json:"page,omitempty"`
		Results *[]struct {
			Adult            *bool    `json:"adult,omitempty"`
			BackdropPath     *string  `json:"backdrop_path,omitempty"`
			GenreIds         *[]int   `json:"genre_ids,omitempty"`
			ID               *int     `json:"id,omitempty"`
			OriginalLanguage *string  `json:"original_language,omitempty"`
			OriginalTitle    *string  `json:"original_title,omitempty"`
			Overview         *string  `json:"overview,omitempty"`
			Popularity       *float32 `json:"popularity,omitempty"`
			PosterPath       *string  `json:"poster_path,omitempty"`
			ReleaseDate      *string  `json:"release_date,omitempty"`
			Title            *string  `json:"title,omitempty"`
			Video            *bool    `json:"video,omitempty"`
			VoteAverage      *float32 `json:"vote_average,omitempty"`
			VoteCount        *int     `json:"vote_count,omitempty"`
		} `json:"results,omitempty"`
		TotalPages   *int `json:"total_pages,omitempty"`
		TotalResults *int `json:"total_results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r MovieNowPlayingListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MovieNowPlayingListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MoviePopularListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Page    *int `json:"page,omitempty"`
		Results *[]struct {
			Adult            *bool    `json:"adult,omitempty"`
			BackdropPath     *string  `json:"backdrop_path,omitempty"`
			GenreIds         *[]int   `json:"genre_ids,omitempty"`
			ID               *int     `json:"id,omitempty"`
			OriginalLanguage *string  `json:"original_language,omitempty"`
			OriginalTitle    *string  `json:"original_title,omitempty"`
			Overview         *string  `json:"overview,omitempty"`
			Popularity       *float32 `json:"popularity,omitempty"`
			PosterPath       *string  `json:"poster_path,omitempty"`
			ReleaseDate      *string  `json:"release_date,omitempty"`
			Title            *string  `json:"title,omitempty"`
			Video            *bool    `json:"video,omitempty"`
			VoteAverage      *float32 `json:"vote_average,omitempty"`
			VoteCount        *int     `json:"vote_count,omitempty"`
		} `json:"results,omitempty"`
		TotalPages   *int `json:"total_pages,omitempty"`
		TotalResults *int `json:"total_results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r MoviePopularListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MoviePopularListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MovieTopRatedListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Page    *int `json:"page,omitempty"`
		Results *[]struct {
			Adult            *bool    `json:"adult,omitempty"`
			BackdropPath     *string  `json:"backdrop_path,omitempty"`
			GenreIds         *[]int   `json:"genre_ids,omitempty"`
			ID               *int     `json:"id,omitempty"`
			OriginalLanguage *string  `json:"original_language,omitempty"`
			OriginalTitle    *string  `json:"original_title,omitempty"`
			Overview         *string  `json:"overview,omitempty"`
			Popularity       *float32 `json:"popularity,omitempty"`
			PosterPath       *string  `json:"poster_path,omitempty"`
			ReleaseDate      *string  `json:"release_date,omitempty"`
			Title            *string  `json:"title,omitempty"`
			Video            *bool    `json:"video,omitempty"`
			VoteAverage      *float32 `json:"vote_average,omitempty"`
			VoteCount        *int     `json:"vote_count,omitempty"`
		} `json:"results,omitempty"`
		TotalPages   *int `json:"total_pages,omitempty"`
		TotalResults *int `json:"total_results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r MovieTopRatedListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MovieTopRatedListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MovieUpcomingListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Dates *struct {
			Maximum *string `json:"maximum,omitempty"`
			Minimum *string `json:"minimum,omitempty"`
		} `json:"dates,omitempty"`
		Page    *int `json:"page,omitempty"`
		Results *[]struct {
			Adult            *bool    `json:"adult,omitempty"`
			BackdropPath     *string  `json:"backdrop_path,omitempty"`
			GenreIds         *[]int   `json:"genre_ids,omitempty"`
			ID               *int     `json:"id,omitempty"`
			OriginalLanguage *string  `json:"original_language,omitempty"`
			OriginalTitle    *string  `json:"original_title,omitempty"`
			Overview         *string  `json:"overview,omitempty"`
			Popularity       *float32 `json:"popularity,omitempty"`
			PosterPath       *string  `json:"poster_path,omitempty"`
			ReleaseDate      *string  `json:"release_date,omitempty"`
			Title            *string  `json:"title,omitempty"`
			Video            *bool    `json:"video,omitempty"`
			VoteAverage      *int     `json:"vote_average,omitempty"`
			VoteCount        *int     `json:"vote_count,omitempty"`
		} `json:"results,omitempty"`
		TotalPages   *int `json:"total_pages,omitempty"`
		TotalResults *int `json:"total_results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r MovieUpcomingListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MovieUpcomingListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MovieDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Adult               *bool        `json:"adult,omitempty"`
		BackdropPath        *string      `json:"backdrop_path,omitempty"`
		BelongsToCollection *interface{} `json:"belongs_to_collection,omitempty"`
		Budget              *int         `json:"budget,omitempty"`
		Genres              *[]struct {
			ID   *int    `json:"id,omitempty"`
			Name *string `json:"name,omitempty"`
		} `json:"genres,omitempty"`
		Homepage            *string  `json:"homepage,omitempty"`
		ID                  *int     `json:"id,omitempty"`
		ImdbID              *string  `json:"imdb_id,omitempty"`
		OriginalLanguage    *string  `json:"original_language,omitempty"`
		OriginalTitle       *string  `json:"original_title,omitempty"`
		Overview            *string  `json:"overview,omitempty"`
		Popularity          *float32 `json:"popularity,omitempty"`
		PosterPath          *string  `json:"poster_path,omitempty"`
		ProductionCompanies *[]struct {
			ID            *int    `json:"id,omitempty"`
			LogoPath      *string `json:"logo_path,omitempty"`
			Name          *string `json:"name,omitempty"`
			OriginCountry *string `json:"origin_country,omitempty"`
		} `json:"production_companies,omitempty"`
		ProductionCountries *[]struct {
			Iso31661 *string `json:"iso_3166_1,omitempty"`
			Name     *string `json:"name,omitempty"`
		} `json:"production_countries,omitempty"`
		ReleaseDate     *string `json:"release_date,omitempty"`
		Revenue         *int    `json:"revenue,omitempty"`
		Runtime         *int    `json:"runtime,omitempty"`
		SpokenLanguages *[]struct {
			EnglishName *string `json:"english_name,omitempty"`
			Iso6391     *string `json:"iso_639_1,omitempty"`
			Name        *string `json:"name,omitempty"`
		} `json:"spoken_languages,omitempty"`
		Status      *string  `json:"status,omitempty"`
		Tagline     *string  `json:"tagline,omitempty"`
		Title       *string  `json:"title,omitempty"`
		Video       *bool    `json:"video,omitempty"`
		VoteAverage *float32 `json:"vote_average,omitempty"`
		VoteCount   *int     `json:"vote_count,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r MovieDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MovieDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MovieAccountStatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Favorite *bool `json:"favorite,omitempty"`
		ID       *int  `json:"id,omitempty"`
		Rated    *struct {
			Value *int `json:"value,omitempty"`
		} `json:"rated,omitempty"`
		Watchlist *bool `json:"watchlist,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r MovieAccountStatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MovieAccountStatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MovieAlternativeTitlesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		ID     *int `json:"id,omitempty"`
		Titles *[]struct {
			Iso31661 *string `json:"iso_3166_1,omitempty"`
			Title    *string `json:"title,omitempty"`
			Type     *string `json:"type,omitempty"`
		} `json:"titles,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r MovieAlternativeTitlesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MovieAlternativeTitlesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MovieChangesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Changes *[]struct {
			Items *[]struct {
				Action   *string `json:"action,omitempty"`
				ID       *string `json:"id,omitempty"`
				Iso31661 *string `json:"iso_3166_1,omitempty"`
				Iso6391  *string `json:"iso_639_1,omitempty"`
				Time     *string `json:"time,omitempty"`
				Value    *struct {
					Poster *struct {
						FilePath *string `json:"file_path,omitempty"`
					} `json:"poster,omitempty"`
				} `json:"value,omitempty"`
			} `json:"items,omitempty"`
			Key *string `json:"key,omitempty"`
		} `json:"changes,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r MovieChangesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MovieChangesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MovieCreditsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Cast *[]struct {
			Adult              *bool    `json:"adult,omitempty"`
			CastID             *int     `json:"cast_id,omitempty"`
			Character          *string  `json:"character,omitempty"`
			CreditID           *string  `json:"credit_id,omitempty"`
			Gender             *int     `json:"gender,omitempty"`
			ID                 *int     `json:"id,omitempty"`
			KnownForDepartment *string  `json:"known_for_department,omitempty"`
			Name               *string  `json:"name,omitempty"`
			Order              *int     `json:"order,omitempty"`
			OriginalName       *string  `json:"original_name,omitempty"`
			Popularity         *float32 `json:"popularity,omitempty"`
			ProfilePath        *string  `json:"profile_path,omitempty"`
		} `json:"cast,omitempty"`
		Crew *[]struct {
			Adult              *bool    `json:"adult,omitempty"`
			CreditID           *string  `json:"credit_id,omitempty"`
			Department         *string  `json:"department,omitempty"`
			Gender             *int     `json:"gender,omitempty"`
			ID                 *int     `json:"id,omitempty"`
			Job                *string  `json:"job,omitempty"`
			KnownForDepartment *string  `json:"known_for_department,omitempty"`
			Name               *string  `json:"name,omitempty"`
			OriginalName       *string  `json:"original_name,omitempty"`
			Popularity         *float32 `json:"popularity,omitempty"`
			ProfilePath        *string  `json:"profile_path,omitempty"`
		} `json:"crew,omitempty"`
		ID *int `json:"id,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r MovieCreditsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MovieCreditsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MovieExternalIdsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		FacebookID  *string      `json:"facebook_id,omitempty"`
		ID          *int         `json:"id,omitempty"`
		ImdbID      *string      `json:"imdb_id,omitempty"`
		InstagramID *interface{} `json:"instagram_id,omitempty"`
		TwitterID   *interface{} `json:"twitter_id,omitempty"`
		WikidataID  *interface{} `json:"wikidata_id,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r MovieExternalIdsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MovieExternalIdsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MovieImagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Backdrops *[]struct {
			AspectRatio *float32     `json:"aspect_ratio,omitempty"`
			FilePath    *string      `json:"file_path,omitempty"`
			Height      *int         `json:"height,omitempty"`
			Iso6391     *interface{} `json:"iso_639_1,omitempty"`
			VoteAverage *float32     `json:"vote_average,omitempty"`
			VoteCount   *int         `json:"vote_count,omitempty"`
			Width       *int         `json:"width,omitempty"`
		} `json:"backdrops,omitempty"`
		ID    *int `json:"id,omitempty"`
		Logos *[]struct {
			AspectRatio *float32 `json:"aspect_ratio,omitempty"`
			FilePath    *string  `json:"file_path,omitempty"`
			Height      *int     `json:"height,omitempty"`
			Iso6391     *string  `json:"iso_639_1,omitempty"`
			VoteAverage *float32 `json:"vote_average,omitempty"`
			VoteCount   *int     `json:"vote_count,omitempty"`
			Width       *int     `json:"width,omitempty"`
		} `json:"logos,omitempty"`
		Posters *[]struct {
			AspectRatio *float32 `json:"aspect_ratio,omitempty"`
			FilePath    *string  `json:"file_path,omitempty"`
			Height      *int     `json:"height,omitempty"`
			Iso6391     *string  `json:"iso_639_1,omitempty"`
			VoteAverage *float32 `json:"vote_average,omitempty"`
			VoteCount   *int     `json:"vote_count,omitempty"`
			Width       *int     `json:"width,omitempty"`
		} `json:"posters,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r MovieImagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MovieImagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MovieKeywordsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		ID       *int `json:"id,omitempty"`
		Keywords *[]struct {
			ID   *int    `json:"id,omitempty"`
			Name *string `json:"name,omitempty"`
		} `json:"keywords,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r MovieKeywordsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MovieKeywordsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MovieListsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		ID      *int `json:"id,omitempty"`
		Page    *int `json:"page,omitempty"`
		Results *[]struct {
			Description   *string      `json:"description,omitempty"`
			FavoriteCount *int         `json:"favorite_count,omitempty"`
			ID            *int         `json:"id,omitempty"`
			Iso6391       *string      `json:"iso_639_1,omitempty"`
			ItemCount     *int         `json:"item_count,omitempty"`
			ListType      *string      `json:"list_type,omitempty"`
			Name          *string      `json:"name,omitempty"`
			PosterPath    *interface{} `json:"poster_path,omitempty"`
		} `json:"results,omitempty"`
		TotalPages   *int `json:"total_pages,omitempty"`
		TotalResults *int `json:"total_results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r MovieListsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MovieListsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MovieDeleteRatingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		StatusCode    *int    `json:"status_code,omitempty"`
		StatusMessage *string `json:"status_message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r MovieDeleteRatingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MovieDeleteRatingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MovieAddRatingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		StatusCode    *int    `json:"status_code,omitempty"`
		StatusMessage *string `json:"status_message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r MovieAddRatingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MovieAddRatingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MovieRecommendationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]interface{}
}

// Status returns HTTPResponse.Status
func (r MovieRecommendationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MovieRecommendationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MovieReleaseDatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		ID      *int `json:"id,omitempty"`
		Results *[]struct {
			Iso31661     *string `json:"iso_3166_1,omitempty"`
			ReleaseDates *[]struct {
				Certification *string        `json:"certification,omitempty"`
				Descriptors   *[]interface{} `json:"descriptors,omitempty"`
				Iso6391       *string        `json:"iso_639_1,omitempty"`
				Note          *string        `json:"note,omitempty"`
				ReleaseDate   *string        `json:"release_date,omitempty"`
				Type          *int           `json:"type,omitempty"`
			} `json:"release_dates,omitempty"`
		} `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r MovieReleaseDatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MovieReleaseDatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MovieReviewsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		ID      *int `json:"id,omitempty"`
		Page    *int `json:"page,omitempty"`
		Results *[]struct {
			Author        *string `json:"author,omitempty"`
			AuthorDetails *struct {
				AvatarPath *string      `json:"avatar_path,omitempty"`
				Name       *string      `json:"name,omitempty"`
				Rating     *interface{} `json:"rating,omitempty"`
				Username   *string      `json:"username,omitempty"`
			} `json:"author_details,omitempty"`
			Content   *string `json:"content,omitempty"`
			CreatedAt *string `json:"created_at,omitempty"`
			ID        *string `json:"id,omitempty"`
			UpdatedAt *string `json:"updated_at,omitempty"`
			URL       *string `json:"url,omitempty"`
		} `json:"results,omitempty"`
		TotalPages   *int `json:"total_pages,omitempty"`
		TotalResults *int `json:"total_results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r MovieReviewsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MovieReviewsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MovieSimilarResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Page    *int `json:"page,omitempty"`
		Results *[]struct {
			Adult            *bool    `json:"adult,omitempty"`
			BackdropPath     *string  `json:"backdrop_path,omitempty"`
			GenreIds         *[]int   `json:"genre_ids,omitempty"`
			ID               *int     `json:"id,omitempty"`
			OriginalLanguage *string  `json:"original_language,omitempty"`
			OriginalTitle    *string  `json:"original_title,omitempty"`
			Overview         *string  `json:"overview,omitempty"`
			Popularity       *float32 `json:"popularity,omitempty"`
			PosterPath       *string  `json:"poster_path,omitempty"`
			ReleaseDate      *string  `json:"release_date,omitempty"`
			Title            *string  `json:"title,omitempty"`
			Video            *bool    `json:"video,omitempty"`
			VoteAverage      *float32 `json:"vote_average,omitempty"`
			VoteCount        *int     `json:"vote_count,omitempty"`
		} `json:"results,omitempty"`
		TotalPages   *int `json:"total_pages,omitempty"`
		TotalResults *int `json:"total_results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r MovieSimilarResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MovieSimilarResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MovieTranslationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		ID           *int `json:"id,omitempty"`
		Translations *[]struct {
			Data *struct {
				Homepage *string `json:"homepage,omitempty"`
				Overview *string `json:"overview,omitempty"`
				Runtime  *int    `json:"runtime,omitempty"`
				Tagline  *string `json:"tagline,omitempty"`
				Title    *string `json:"title,omitempty"`
			} `json:"data,omitempty"`
			EnglishName *string `json:"english_name,omitempty"`
			Iso31661    *string `json:"iso_3166_1,omitempty"`
			Iso6391     *string `json:"iso_639_1,omitempty"`
			Name        *string `json:"name,omitempty"`
		} `json:"translations,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r MovieTranslationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MovieTranslationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MovieVideosResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		ID      *int `json:"id,omitempty"`
		Results *[]struct {
			ID          *string `json:"id,omitempty"`
			Iso31661    *string `json:"iso_3166_1,omitempty"`
			Iso6391     *string `json:"iso_639_1,omitempty"`
			Key         *string `json:"key,omitempty"`
			Name        *string `json:"name,omitempty"`
			Official    *bool   `json:"official,omitempty"`
			PublishedAt *string `json:"published_at,omitempty"`
			Site        *string `json:"site,omitempty"`
			Size        *int    `json:"size,omitempty"`
			Type        *string `json:"type,omitempty"`
		} `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r MovieVideosResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MovieVideosResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MovieWatchProvidersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		ID      *int `json:"id,omitempty"`
		Results *struct {
			AE *struct {
				Buy *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"buy,omitempty"`
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
				Rent *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"rent,omitempty"`
			} `json:"AE,omitempty"`
			AL *struct {
				Buy *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"buy,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"AL,omitempty"`
			AR *struct {
				Buy *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"buy,omitempty"`
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
				Rent *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"rent,omitempty"`
			} `json:"AR,omitempty"`
			AT *struct {
				Buy *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"buy,omitempty"`
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
				Rent *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"rent,omitempty"`
			} `json:"AT,omitempty"`
			AU *struct {
				Buy *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"buy,omitempty"`
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"AU,omitempty"`
			BA *struct {
				Buy *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"buy,omitempty"`
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"BA,omitempty"`
			BB *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"BB,omitempty"`
			BE *struct {
				Buy *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"buy,omitempty"`
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
				Rent *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"rent,omitempty"`
			} `json:"BE,omitempty"`
			BG *struct {
				Buy *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"buy,omitempty"`
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
				Rent *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"rent,omitempty"`
			} `json:"BG,omitempty"`
			BH *struct {
				Buy *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"buy,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"BH,omitempty"`
			BO *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"BO,omitempty"`
			BR *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"BR,omitempty"`
			BS *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"BS,omitempty"`
			CA *struct {
				Buy *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"buy,omitempty"`
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
				Rent *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"rent,omitempty"`
			} `json:"CA,omitempty"`
			CH *struct {
				Buy *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"buy,omitempty"`
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
				Rent *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"rent,omitempty"`
			} `json:"CH,omitempty"`
			CL *struct {
				Buy *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"buy,omitempty"`
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
				Rent *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"rent,omitempty"`
			} `json:"CL,omitempty"`
			CO *struct {
				Buy *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"buy,omitempty"`
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
				Rent *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"rent,omitempty"`
			} `json:"CO,omitempty"`
			CR *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"CR,omitempty"`
			CV *struct {
				Buy *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"buy,omitempty"`
				Link *string `json:"link,omitempty"`
				Rent *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"rent,omitempty"`
			} `json:"CV,omitempty"`
			CZ *struct {
				Buy *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"buy,omitempty"`
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
				Rent *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"rent,omitempty"`
			} `json:"CZ,omitempty"`
			DE *struct {
				Buy *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"buy,omitempty"`
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
				Rent *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"rent,omitempty"`
			} `json:"DE,omitempty"`
			DK *struct {
				Buy *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"buy,omitempty"`
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
				Rent *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"rent,omitempty"`
			} `json:"DK,omitempty"`
			DO *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"DO,omitempty"`
			EC *struct {
				Buy *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"buy,omitempty"`
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
				Rent *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"rent,omitempty"`
			} `json:"EC,omitempty"`
			EE *struct {
				Buy *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"buy,omitempty"`
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
				Rent *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"rent,omitempty"`
			} `json:"EE,omitempty"`
			EG *struct {
				Buy *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"buy,omitempty"`
				Link *string `json:"link,omitempty"`
				Rent *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"rent,omitempty"`
			} `json:"EG,omitempty"`
			ES *struct {
				Ads *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"ads,omitempty"`
				Buy *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"buy,omitempty"`
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
				Rent *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"rent,omitempty"`
			} `json:"ES,omitempty"`
			FI *struct {
				Buy *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"buy,omitempty"`
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
				Rent *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"rent,omitempty"`
			} `json:"FI,omitempty"`
			FJ *struct {
				Buy *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"buy,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"FJ,omitempty"`
			FR *struct {
				Buy *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"buy,omitempty"`
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
				Rent *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"rent,omitempty"`
			} `json:"FR,omitempty"`
			GB *struct {
				Buy *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"buy,omitempty"`
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
				Rent *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"rent,omitempty"`
			} `json:"GB,omitempty"`
			GF *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"GF,omitempty"`
			GI *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"GI,omitempty"`
			GR *struct {
				Buy *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"buy,omitempty"`
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
				Rent *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"rent,omitempty"`
			} `json:"GR,omitempty"`
			GT *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"GT,omitempty"`
			HK *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"HK,omitempty"`
			HN *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"HN,omitempty"`
			HR *struct {
				Ads *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"ads,omitempty"`
				Buy *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"buy,omitempty"`
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"HR,omitempty"`
			HU *struct {
				Buy *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"buy,omitempty"`
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
				Rent *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"rent,omitempty"`
			} `json:"HU,omitempty"`
			ID *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"ID,omitempty"`
			IE *struct {
				Buy *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"buy,omitempty"`
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
				Rent *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"rent,omitempty"`
			} `json:"IE,omitempty"`
			IL *struct {
				Buy *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"buy,omitempty"`
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"IL,omitempty"`
			IN *struct {
				Buy *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"buy,omitempty"`
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
				Rent *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"rent,omitempty"`
			} `json:"IN,omitempty"`
			IQ *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"IQ,omitempty"`
			IS *struct {
				Buy *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"buy,omitempty"`
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"IS,omitempty"`
			IT *struct {
				Buy *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"buy,omitempty"`
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
				Rent *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"rent,omitempty"`
			} `json:"IT,omitempty"`
			JM *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"JM,omitempty"`
			JO *struct {
				Buy *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"buy,omitempty"`
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"JO,omitempty"`
			JP *struct {
				Buy *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"buy,omitempty"`
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
				Rent *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"rent,omitempty"`
			} `json:"JP,omitempty"`
			KR *struct {
				Buy *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"buy,omitempty"`
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"KR,omitempty"`
			KW *struct {
				Buy *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"buy,omitempty"`
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"KW,omitempty"`
			LB *struct {
				Buy *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"buy,omitempty"`
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"LB,omitempty"`
			LI *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"LI,omitempty"`
			LT *struct {
				Buy *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"buy,omitempty"`
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
				Rent *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"rent,omitempty"`
			} `json:"LT,omitempty"`
			LV *struct {
				Buy *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"buy,omitempty"`
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"LV,omitempty"`
			MD *struct {
				Buy *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"buy,omitempty"`
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"MD,omitempty"`
			MK *struct {
				Buy *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"buy,omitempty"`
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"MK,omitempty"`
			MT *struct {
				Buy *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"buy,omitempty"`
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
				Rent *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"rent,omitempty"`
			} `json:"MT,omitempty"`
			MU *struct {
				Buy *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"buy,omitempty"`
				Link *string `json:"link,omitempty"`
				Rent *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"rent,omitempty"`
			} `json:"MU,omitempty"`
			MX *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"MX,omitempty"`
			MY *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"MY,omitempty"`
			MZ *struct {
				Buy *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"buy,omitempty"`
				Link *string `json:"link,omitempty"`
				Rent *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"rent,omitempty"`
			} `json:"MZ,omitempty"`
			NL *struct {
				Buy *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"buy,omitempty"`
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
				Rent *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"rent,omitempty"`
			} `json:"NL,omitempty"`
			NO *struct {
				Buy *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"buy,omitempty"`
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
				Rent *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"rent,omitempty"`
			} `json:"NO,omitempty"`
			NZ *struct {
				Buy *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"buy,omitempty"`
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"NZ,omitempty"`
			OM *struct {
				Buy *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"buy,omitempty"`
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
				Rent *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"rent,omitempty"`
			} `json:"OM,omitempty"`
			PA *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"PA,omitempty"`
			PE *struct {
				Buy *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"buy,omitempty"`
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
				Rent *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"rent,omitempty"`
			} `json:"PE,omitempty"`
			PH *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"PH,omitempty"`
			PK *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"PK,omitempty"`
			PL *struct {
				Buy *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"buy,omitempty"`
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
				Rent *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"rent,omitempty"`
			} `json:"PL,omitempty"`
			PS *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"PS,omitempty"`
			PT *struct {
				Buy *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"buy,omitempty"`
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
				Rent *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"rent,omitempty"`
			} `json:"PT,omitempty"`
			PY *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"PY,omitempty"`
			QA *struct {
				Buy *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"buy,omitempty"`
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"QA,omitempty"`
			RO *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"RO,omitempty"`
			RS *struct {
				Buy *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"buy,omitempty"`
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"RS,omitempty"`
			RU *struct {
				Buy *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"buy,omitempty"`
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
				Rent *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"rent,omitempty"`
			} `json:"RU,omitempty"`
			SA *struct {
				Buy *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"buy,omitempty"`
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
				Rent *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"rent,omitempty"`
			} `json:"SA,omitempty"`
			SE *struct {
				Buy *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"buy,omitempty"`
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
				Rent *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"rent,omitempty"`
			} `json:"SE,omitempty"`
			SG *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"SG,omitempty"`
			SI *struct {
				Buy *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"buy,omitempty"`
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"SI,omitempty"`
			SK *struct {
				Buy *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"buy,omitempty"`
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
				Rent *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"rent,omitempty"`
			} `json:"SK,omitempty"`
			SM *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"SM,omitempty"`
			SV *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"SV,omitempty"`
			TH *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"TH,omitempty"`
			TR *struct {
				Buy *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"buy,omitempty"`
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
				Rent *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"rent,omitempty"`
			} `json:"TR,omitempty"`
			TT *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"TT,omitempty"`
			TW *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"TW,omitempty"`
			UG *struct {
				Buy *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"buy,omitempty"`
				Link *string `json:"link,omitempty"`
				Rent *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"rent,omitempty"`
			} `json:"UG,omitempty"`
			US *struct {
				Buy *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"buy,omitempty"`
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
				Rent *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"rent,omitempty"`
			} `json:"US,omitempty"`
			UY *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"UY,omitempty"`
			VE *struct {
				Buy *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"buy,omitempty"`
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
				Rent *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"rent,omitempty"`
			} `json:"VE,omitempty"`
			YE *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"YE,omitempty"`
			ZA *struct {
				Buy *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"buy,omitempty"`
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
				Rent *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"rent,omitempty"`
			} `json:"ZA,omitempty"`
		} `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r MovieWatchProvidersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MovieWatchProvidersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NetworkDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Headquarters  *string `json:"headquarters,omitempty"`
		Homepage      *string `json:"homepage,omitempty"`
		ID            *int    `json:"id,omitempty"`
		LogoPath      *string `json:"logo_path,omitempty"`
		Name          *string `json:"name,omitempty"`
		OriginCountry *string `json:"origin_country,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r NetworkDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NetworkDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DetailsCopyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		ID      *int `json:"id,omitempty"`
		Results *[]struct {
			Name *string `json:"name,omitempty"`
			Type *string `json:"type,omitempty"`
		} `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DetailsCopyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DetailsCopyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AlternativeNamesCopyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		ID    *int `json:"id,omitempty"`
		Logos *[]struct {
			AspectRatio *float32 `json:"aspect_ratio,omitempty"`
			FilePath    *string  `json:"file_path,omitempty"`
			FileType    *string  `json:"file_type,omitempty"`
			Height      *int     `json:"height,omitempty"`
			ID          *string  `json:"id,omitempty"`
			VoteAverage *float32 `json:"vote_average,omitempty"`
			VoteCount   *int     `json:"vote_count,omitempty"`
			Width       *int     `json:"width,omitempty"`
		} `json:"logos,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r AlternativeNamesCopyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AlternativeNamesCopyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ChangesPeopleListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Page    *int `json:"page,omitempty"`
		Results *[]struct {
			Adult *bool `json:"adult,omitempty"`
			ID    *int  `json:"id,omitempty"`
		} `json:"results,omitempty"`
		TotalPages   *int `json:"total_pages,omitempty"`
		TotalResults *int `json:"total_results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ChangesPeopleListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ChangesPeopleListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersonLatestIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Adult              *bool          `json:"adult,omitempty"`
		AlsoKnownAs        *[]interface{} `json:"also_known_as,omitempty"`
		Biography          *string        `json:"biography,omitempty"`
		Birthday           *interface{}   `json:"birthday,omitempty"`
		Deathday           *interface{}   `json:"deathday,omitempty"`
		Gender             *int           `json:"gender,omitempty"`
		Homepage           *interface{}   `json:"homepage,omitempty"`
		ID                 *int           `json:"id,omitempty"`
		ImdbID             *interface{}   `json:"imdb_id,omitempty"`
		KnownForDepartment *interface{}   `json:"known_for_department,omitempty"`
		Name               *string        `json:"name,omitempty"`
		PlaceOfBirth       *interface{}   `json:"place_of_birth,omitempty"`
		Popularity         *int           `json:"popularity,omitempty"`
		ProfilePath        *interface{}   `json:"profile_path,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r PersonLatestIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersonLatestIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersonPopularListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Page    *int `json:"page,omitempty"`
		Results *[]struct {
			Adult    *bool `json:"adult,omitempty"`
			Gender   *int  `json:"gender,omitempty"`
			ID       *int  `json:"id,omitempty"`
			KnownFor *[]struct {
				Adult            *bool    `json:"adult,omitempty"`
				BackdropPath     *string  `json:"backdrop_path,omitempty"`
				GenreIds         *[]int   `json:"genre_ids,omitempty"`
				ID               *int     `json:"id,omitempty"`
				MediaType        *string  `json:"media_type,omitempty"`
				OriginalLanguage *string  `json:"original_language,omitempty"`
				OriginalTitle    *string  `json:"original_title,omitempty"`
				Overview         *string  `json:"overview,omitempty"`
				PosterPath       *string  `json:"poster_path,omitempty"`
				ReleaseDate      *string  `json:"release_date,omitempty"`
				Title            *string  `json:"title,omitempty"`
				Video            *bool    `json:"video,omitempty"`
				VoteAverage      *float32 `json:"vote_average,omitempty"`
				VoteCount        *int     `json:"vote_count,omitempty"`
			} `json:"known_for,omitempty"`
			KnownForDepartment *string  `json:"known_for_department,omitempty"`
			Name               *string  `json:"name,omitempty"`
			Popularity         *float32 `json:"popularity,omitempty"`
			ProfilePath        *string  `json:"profile_path,omitempty"`
		} `json:"results,omitempty"`
		TotalPages   *int `json:"total_pages,omitempty"`
		TotalResults *int `json:"total_results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r PersonPopularListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersonPopularListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersonDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Adult              *bool        `json:"adult,omitempty"`
		AlsoKnownAs        *[]string    `json:"also_known_as,omitempty"`
		Biography          *string      `json:"biography,omitempty"`
		Birthday           *string      `json:"birthday,omitempty"`
		Deathday           *interface{} `json:"deathday,omitempty"`
		Gender             *int         `json:"gender,omitempty"`
		Homepage           *interface{} `json:"homepage,omitempty"`
		ID                 *int         `json:"id,omitempty"`
		ImdbID             *string      `json:"imdb_id,omitempty"`
		KnownForDepartment *string      `json:"known_for_department,omitempty"`
		Name               *string      `json:"name,omitempty"`
		PlaceOfBirth       *string      `json:"place_of_birth,omitempty"`
		Popularity         *float32     `json:"popularity,omitempty"`
		ProfilePath        *string      `json:"profile_path,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r PersonDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersonDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersonChangesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Changes *[]struct {
			Items *[]struct {
				Action   *string `json:"action,omitempty"`
				ID       *string `json:"id,omitempty"`
				Iso31661 *string `json:"iso_3166_1,omitempty"`
				Iso6391  *string `json:"iso_639_1,omitempty"`
				Time     *string `json:"time,omitempty"`
				Value    *string `json:"value,omitempty"`
			} `json:"items,omitempty"`
			Key *string `json:"key,omitempty"`
		} `json:"changes,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r PersonChangesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersonChangesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersonCombinedCreditsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Cast *[]struct {
			Adult            *bool    `json:"adult,omitempty"`
			BackdropPath     *string  `json:"backdrop_path,omitempty"`
			Character        *string  `json:"character,omitempty"`
			CreditID         *string  `json:"credit_id,omitempty"`
			GenreIds         *[]int   `json:"genre_ids,omitempty"`
			ID               *int     `json:"id,omitempty"`
			MediaType        *string  `json:"media_type,omitempty"`
			Order            *int     `json:"order,omitempty"`
			OriginalLanguage *string  `json:"original_language,omitempty"`
			OriginalTitle    *string  `json:"original_title,omitempty"`
			Overview         *string  `json:"overview,omitempty"`
			Popularity       *float32 `json:"popularity,omitempty"`
			PosterPath       *string  `json:"poster_path,omitempty"`
			ReleaseDate      *string  `json:"release_date,omitempty"`
			Title            *string  `json:"title,omitempty"`
			Video            *bool    `json:"video,omitempty"`
			VoteAverage      *float32 `json:"vote_average,omitempty"`
			VoteCount        *int     `json:"vote_count,omitempty"`
		} `json:"cast,omitempty"`
		Crew *[]struct {
			Adult            *bool    `json:"adult,omitempty"`
			BackdropPath     *string  `json:"backdrop_path,omitempty"`
			CreditID         *string  `json:"credit_id,omitempty"`
			Department       *string  `json:"department,omitempty"`
			GenreIds         *[]int   `json:"genre_ids,omitempty"`
			ID               *int     `json:"id,omitempty"`
			Job              *string  `json:"job,omitempty"`
			MediaType        *string  `json:"media_type,omitempty"`
			OriginalLanguage *string  `json:"original_language,omitempty"`
			OriginalTitle    *string  `json:"original_title,omitempty"`
			Overview         *string  `json:"overview,omitempty"`
			Popularity       *float32 `json:"popularity,omitempty"`
			PosterPath       *string  `json:"poster_path,omitempty"`
			ReleaseDate      *string  `json:"release_date,omitempty"`
			Title            *string  `json:"title,omitempty"`
			Video            *bool    `json:"video,omitempty"`
			VoteAverage      *float32 `json:"vote_average,omitempty"`
			VoteCount        *int     `json:"vote_count,omitempty"`
		} `json:"crew,omitempty"`
		ID *int `json:"id,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r PersonCombinedCreditsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersonCombinedCreditsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersonExternalIdsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		FacebookID  *string      `json:"facebook_id,omitempty"`
		FreebaseID  *string      `json:"freebase_id,omitempty"`
		FreebaseMid *string      `json:"freebase_mid,omitempty"`
		ID          *int         `json:"id,omitempty"`
		ImdbID      *string      `json:"imdb_id,omitempty"`
		InstagramID *string      `json:"instagram_id,omitempty"`
		TiktokID    *string      `json:"tiktok_id,omitempty"`
		TvrageID    *int         `json:"tvrage_id,omitempty"`
		TwitterID   *string      `json:"twitter_id,omitempty"`
		WikidataID  *string      `json:"wikidata_id,omitempty"`
		YoutubeID   *interface{} `json:"youtube_id,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r PersonExternalIdsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersonExternalIdsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersonImagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		ID       *int `json:"id,omitempty"`
		Profiles *[]struct {
			AspectRatio *float32     `json:"aspect_ratio,omitempty"`
			FilePath    *string      `json:"file_path,omitempty"`
			Height      *int         `json:"height,omitempty"`
			Iso6391     *interface{} `json:"iso_639_1,omitempty"`
			VoteAverage *float32     `json:"vote_average,omitempty"`
			VoteCount   *int         `json:"vote_count,omitempty"`
			Width       *int         `json:"width,omitempty"`
		} `json:"profiles,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r PersonImagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersonImagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersonMovieCreditsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Cast *[]struct {
			Adult            *bool    `json:"adult,omitempty"`
			BackdropPath     *string  `json:"backdrop_path,omitempty"`
			Character        *string  `json:"character,omitempty"`
			CreditID         *string  `json:"credit_id,omitempty"`
			GenreIds         *[]int   `json:"genre_ids,omitempty"`
			ID               *int     `json:"id,omitempty"`
			Order            *int     `json:"order,omitempty"`
			OriginalLanguage *string  `json:"original_language,omitempty"`
			OriginalTitle    *string  `json:"original_title,omitempty"`
			Overview         *string  `json:"overview,omitempty"`
			Popularity       *float32 `json:"popularity,omitempty"`
			PosterPath       *string  `json:"poster_path,omitempty"`
			ReleaseDate      *string  `json:"release_date,omitempty"`
			Title            *string  `json:"title,omitempty"`
			Video            *bool    `json:"video,omitempty"`
			VoteAverage      *float32 `json:"vote_average,omitempty"`
			VoteCount        *int     `json:"vote_count,omitempty"`
		} `json:"cast,omitempty"`
		Crew *[]struct {
			Adult            *bool    `json:"adult,omitempty"`
			BackdropPath     *string  `json:"backdrop_path,omitempty"`
			CreditID         *string  `json:"credit_id,omitempty"`
			Department       *string  `json:"department,omitempty"`
			GenreIds         *[]int   `json:"genre_ids,omitempty"`
			ID               *int     `json:"id,omitempty"`
			Job              *string  `json:"job,omitempty"`
			OriginalLanguage *string  `json:"original_language,omitempty"`
			OriginalTitle    *string  `json:"original_title,omitempty"`
			Overview         *string  `json:"overview,omitempty"`
			Popularity       *float32 `json:"popularity,omitempty"`
			PosterPath       *string  `json:"poster_path,omitempty"`
			ReleaseDate      *string  `json:"release_date,omitempty"`
			Title            *string  `json:"title,omitempty"`
			Video            *bool    `json:"video,omitempty"`
			VoteAverage      *float32 `json:"vote_average,omitempty"`
			VoteCount        *int     `json:"vote_count,omitempty"`
		} `json:"crew,omitempty"`
		ID *int `json:"id,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r PersonMovieCreditsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersonMovieCreditsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersonTaggedImagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		ID      *int `json:"id,omitempty"`
		Page    *int `json:"page,omitempty"`
		Results *[]struct {
			AspectRatio *float32 `json:"aspect_ratio,omitempty"`
			FilePath    *string  `json:"file_path,omitempty"`
			Height      *int     `json:"height,omitempty"`
			ID          *string  `json:"id,omitempty"`
			ImageType   *string  `json:"image_type,omitempty"`
			Iso6391     *string  `json:"iso_639_1,omitempty"`
			Media       *struct {
				Adult            *bool    `json:"adult,omitempty"`
				BackdropPath     *string  `json:"backdrop_path,omitempty"`
				GenreIds         *[]int   `json:"genre_ids,omitempty"`
				ID               *int     `json:"id,omitempty"`
				MediaType        *string  `json:"media_type,omitempty"`
				OriginalLanguage *string  `json:"original_language,omitempty"`
				OriginalTitle    *string  `json:"original_title,omitempty"`
				Overview         *string  `json:"overview,omitempty"`
				Popularity       *float32 `json:"popularity,omitempty"`
				PosterPath       *string  `json:"poster_path,omitempty"`
				ReleaseDate      *string  `json:"release_date,omitempty"`
				Title            *string  `json:"title,omitempty"`
				Video            *bool    `json:"video,omitempty"`
				VoteAverage      *float32 `json:"vote_average,omitempty"`
				VoteCount        *int     `json:"vote_count,omitempty"`
			} `json:"media,omitempty"`
			MediaType   *string  `json:"media_type,omitempty"`
			VoteAverage *float32 `json:"vote_average,omitempty"`
			VoteCount   *int     `json:"vote_count,omitempty"`
			Width       *int     `json:"width,omitempty"`
		} `json:"results,omitempty"`
		TotalPages   *int `json:"total_pages,omitempty"`
		TotalResults *int `json:"total_results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r PersonTaggedImagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersonTaggedImagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TranslationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		ID           *int `json:"id,omitempty"`
		Translations *[]struct {
			Data *struct {
				Biography *string `json:"biography,omitempty"`
			} `json:"data,omitempty"`
			EnglishName *string `json:"english_name,omitempty"`
			Iso31661    *string `json:"iso_3166_1,omitempty"`
			Iso6391     *string `json:"iso_639_1,omitempty"`
			Name        *string `json:"name,omitempty"`
		} `json:"translations,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r TranslationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TranslationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersonTvCreditsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Cast *[]struct {
			Adult            *bool     `json:"adult,omitempty"`
			BackdropPath     *string   `json:"backdrop_path,omitempty"`
			Character        *string   `json:"character,omitempty"`
			CreditID         *string   `json:"credit_id,omitempty"`
			EpisodeCount     *int      `json:"episode_count,omitempty"`
			FirstAirDate     *string   `json:"first_air_date,omitempty"`
			GenreIds         *[]int    `json:"genre_ids,omitempty"`
			ID               *int      `json:"id,omitempty"`
			Name             *string   `json:"name,omitempty"`
			OriginCountry    *[]string `json:"origin_country,omitempty"`
			OriginalLanguage *string   `json:"original_language,omitempty"`
			OriginalName     *string   `json:"original_name,omitempty"`
			Overview         *string   `json:"overview,omitempty"`
			Popularity       *float32  `json:"popularity,omitempty"`
			PosterPath       *string   `json:"poster_path,omitempty"`
			VoteAverage      *float32  `json:"vote_average,omitempty"`
			VoteCount        *int      `json:"vote_count,omitempty"`
		} `json:"cast,omitempty"`
		Crew *[]struct {
			Adult            *bool     `json:"adult,omitempty"`
			BackdropPath     *string   `json:"backdrop_path,omitempty"`
			CreditID         *string   `json:"credit_id,omitempty"`
			Department       *string   `json:"department,omitempty"`
			EpisodeCount     *int      `json:"episode_count,omitempty"`
			FirstAirDate     *string   `json:"first_air_date,omitempty"`
			GenreIds         *[]int    `json:"genre_ids,omitempty"`
			ID               *int      `json:"id,omitempty"`
			Job              *string   `json:"job,omitempty"`
			Name             *string   `json:"name,omitempty"`
			OriginCountry    *[]string `json:"origin_country,omitempty"`
			OriginalLanguage *string   `json:"original_language,omitempty"`
			OriginalName     *string   `json:"original_name,omitempty"`
			Overview         *string   `json:"overview,omitempty"`
			Popularity       *float32  `json:"popularity,omitempty"`
			PosterPath       *string   `json:"poster_path,omitempty"`
			VoteAverage      *float32  `json:"vote_average,omitempty"`
			VoteCount        *int      `json:"vote_count,omitempty"`
		} `json:"crew,omitempty"`
		ID *int `json:"id,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r PersonTvCreditsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersonTvCreditsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReviewDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Author        *string `json:"author,omitempty"`
		AuthorDetails *struct {
			AvatarPath *string `json:"avatar_path,omitempty"`
			Name       *string `json:"name,omitempty"`
			Rating     *int    `json:"rating,omitempty"`
			Username   *string `json:"username,omitempty"`
		} `json:"author_details,omitempty"`
		Content    *string `json:"content,omitempty"`
		CreatedAt  *string `json:"created_at,omitempty"`
		ID         *string `json:"id,omitempty"`
		Iso6391    *string `json:"iso_639_1,omitempty"`
		MediaID    *int    `json:"media_id,omitempty"`
		MediaTitle *string `json:"media_title,omitempty"`
		MediaType  *string `json:"media_type,omitempty"`
		UpdatedAt  *string `json:"updated_at,omitempty"`
		URL        *string `json:"url,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ReviewDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReviewDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchCollectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Page    *int `json:"page,omitempty"`
		Results *[]struct {
			Adult            *bool   `json:"adult,omitempty"`
			BackdropPath     *string `json:"backdrop_path,omitempty"`
			ID               *int    `json:"id,omitempty"`
			Name             *string `json:"name,omitempty"`
			OriginalLanguage *string `json:"original_language,omitempty"`
			OriginalName     *string `json:"original_name,omitempty"`
			Overview         *string `json:"overview,omitempty"`
			PosterPath       *string `json:"poster_path,omitempty"`
		} `json:"results,omitempty"`
		TotalPages   *int `json:"total_pages,omitempty"`
		TotalResults *int `json:"total_results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SearchCollectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchCollectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchCompanyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Page    *int `json:"page,omitempty"`
		Results *[]struct {
			ID            *int    `json:"id,omitempty"`
			LogoPath      *string `json:"logo_path,omitempty"`
			Name          *string `json:"name,omitempty"`
			OriginCountry *string `json:"origin_country,omitempty"`
		} `json:"results,omitempty"`
		TotalPages   *int `json:"total_pages,omitempty"`
		TotalResults *int `json:"total_results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SearchCompanyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchCompanyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchKeywordResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Page    *int `json:"page,omitempty"`
		Results *[]struct {
			ID   *int    `json:"id,omitempty"`
			Name *string `json:"name,omitempty"`
		} `json:"results,omitempty"`
		TotalPages   *int `json:"total_pages,omitempty"`
		TotalResults *int `json:"total_results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SearchKeywordResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchKeywordResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchMovieResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Page    *int `json:"page,omitempty"`
		Results *[]struct {
			Adult            *bool    `json:"adult,omitempty"`
			BackdropPath     *string  `json:"backdrop_path,omitempty"`
			GenreIds         *[]int   `json:"genre_ids,omitempty"`
			ID               *int     `json:"id,omitempty"`
			OriginalLanguage *string  `json:"original_language,omitempty"`
			OriginalTitle    *string  `json:"original_title,omitempty"`
			Overview         *string  `json:"overview,omitempty"`
			Popularity       *float32 `json:"popularity,omitempty"`
			PosterPath       *string  `json:"poster_path,omitempty"`
			ReleaseDate      *string  `json:"release_date,omitempty"`
			Title            *string  `json:"title,omitempty"`
			Video            *bool    `json:"video,omitempty"`
			VoteAverage      *float32 `json:"vote_average,omitempty"`
			VoteCount        *int     `json:"vote_count,omitempty"`
		} `json:"results,omitempty"`
		TotalPages   *int `json:"total_pages,omitempty"`
		TotalResults *int `json:"total_results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SearchMovieResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchMovieResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchMultiResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Page    *int `json:"page,omitempty"`
		Results *[]struct {
			Adult            *bool    `json:"adult,omitempty"`
			BackdropPath     *string  `json:"backdrop_path,omitempty"`
			GenreIds         *[]int   `json:"genre_ids,omitempty"`
			ID               *int     `json:"id,omitempty"`
			MediaType        *string  `json:"media_type,omitempty"`
			OriginalLanguage *string  `json:"original_language,omitempty"`
			OriginalTitle    *string  `json:"original_title,omitempty"`
			Overview         *string  `json:"overview,omitempty"`
			Popularity       *float32 `json:"popularity,omitempty"`
			PosterPath       *string  `json:"poster_path,omitempty"`
			ReleaseDate      *string  `json:"release_date,omitempty"`
			Title            *string  `json:"title,omitempty"`
			Video            *bool    `json:"video,omitempty"`
			VoteAverage      *float32 `json:"vote_average,omitempty"`
			VoteCount        *int     `json:"vote_count,omitempty"`
		} `json:"results,omitempty"`
		TotalPages   *int `json:"total_pages,omitempty"`
		TotalResults *int `json:"total_results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SearchMultiResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchMultiResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchPersonResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Page    *int `json:"page,omitempty"`
		Results *[]struct {
			Adult    *bool `json:"adult,omitempty"`
			Gender   *int  `json:"gender,omitempty"`
			ID       *int  `json:"id,omitempty"`
			KnownFor *[]struct {
				Adult            *bool    `json:"adult,omitempty"`
				BackdropPath     *string  `json:"backdrop_path,omitempty"`
				GenreIds         *[]int   `json:"genre_ids,omitempty"`
				ID               *int     `json:"id,omitempty"`
				MediaType        *string  `json:"media_type,omitempty"`
				OriginalLanguage *string  `json:"original_language,omitempty"`
				OriginalTitle    *string  `json:"original_title,omitempty"`
				Overview         *string  `json:"overview,omitempty"`
				Popularity       *float32 `json:"popularity,omitempty"`
				PosterPath       *string  `json:"poster_path,omitempty"`
				ReleaseDate      *string  `json:"release_date,omitempty"`
				Title            *string  `json:"title,omitempty"`
				Video            *bool    `json:"video,omitempty"`
				VoteAverage      *float32 `json:"vote_average,omitempty"`
				VoteCount        *int     `json:"vote_count,omitempty"`
			} `json:"known_for,omitempty"`
			KnownForDepartment *string  `json:"known_for_department,omitempty"`
			Name               *string  `json:"name,omitempty"`
			OriginalName       *string  `json:"original_name,omitempty"`
			Popularity         *float32 `json:"popularity,omitempty"`
			ProfilePath        *string  `json:"profile_path,omitempty"`
		} `json:"results,omitempty"`
		TotalPages   *int `json:"total_pages,omitempty"`
		TotalResults *int `json:"total_results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SearchPersonResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchPersonResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchTvResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Page    *int `json:"page,omitempty"`
		Results *[]struct {
			Adult            *bool     `json:"adult,omitempty"`
			BackdropPath     *string   `json:"backdrop_path,omitempty"`
			FirstAirDate     *string   `json:"first_air_date,omitempty"`
			GenreIds         *[]int    `json:"genre_ids,omitempty"`
			ID               *int      `json:"id,omitempty"`
			Name             *string   `json:"name,omitempty"`
			OriginCountry    *[]string `json:"origin_country,omitempty"`
			OriginalLanguage *string   `json:"original_language,omitempty"`
			OriginalName     *string   `json:"original_name,omitempty"`
			Overview         *string   `json:"overview,omitempty"`
			Popularity       *float32  `json:"popularity,omitempty"`
			PosterPath       *string   `json:"poster_path,omitempty"`
			VoteAverage      *float32  `json:"vote_average,omitempty"`
			VoteCount        *int      `json:"vote_count,omitempty"`
		} `json:"results,omitempty"`
		TotalPages   *int `json:"total_pages,omitempty"`
		TotalResults *int `json:"total_results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SearchTvResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchTvResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TrendingAllResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Page    *int `json:"page,omitempty"`
		Results *[]struct {
			Adult            *bool    `json:"adult,omitempty"`
			BackdropPath     *string  `json:"backdrop_path,omitempty"`
			GenreIds         *[]int   `json:"genre_ids,omitempty"`
			ID               *int     `json:"id,omitempty"`
			MediaType        *string  `json:"media_type,omitempty"`
			OriginalLanguage *string  `json:"original_language,omitempty"`
			OriginalTitle    *string  `json:"original_title,omitempty"`
			Overview         *string  `json:"overview,omitempty"`
			Popularity       *float32 `json:"popularity,omitempty"`
			PosterPath       *string  `json:"poster_path,omitempty"`
			ReleaseDate      *string  `json:"release_date,omitempty"`
			Title            *string  `json:"title,omitempty"`
			Video            *bool    `json:"video,omitempty"`
			VoteAverage      *float32 `json:"vote_average,omitempty"`
			VoteCount        *int     `json:"vote_count,omitempty"`
		} `json:"results,omitempty"`
		TotalPages   *int `json:"total_pages,omitempty"`
		TotalResults *int `json:"total_results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r TrendingAllResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TrendingAllResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TrendingMoviesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Page    *int `json:"page,omitempty"`
		Results *[]struct {
			Adult            *bool    `json:"adult,omitempty"`
			BackdropPath     *string  `json:"backdrop_path,omitempty"`
			GenreIds         *[]int   `json:"genre_ids,omitempty"`
			ID               *int     `json:"id,omitempty"`
			MediaType        *string  `json:"media_type,omitempty"`
			OriginalLanguage *string  `json:"original_language,omitempty"`
			OriginalTitle    *string  `json:"original_title,omitempty"`
			Overview         *string  `json:"overview,omitempty"`
			Popularity       *float32 `json:"popularity,omitempty"`
			PosterPath       *string  `json:"poster_path,omitempty"`
			ReleaseDate      *string  `json:"release_date,omitempty"`
			Title            *string  `json:"title,omitempty"`
			Video            *bool    `json:"video,omitempty"`
			VoteAverage      *float32 `json:"vote_average,omitempty"`
			VoteCount        *int     `json:"vote_count,omitempty"`
		} `json:"results,omitempty"`
		TotalPages   *int `json:"total_pages,omitempty"`
		TotalResults *int `json:"total_results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r TrendingMoviesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TrendingMoviesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TrendingPeopleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Page    *int `json:"page,omitempty"`
		Results *[]struct {
			Adult    *bool `json:"adult,omitempty"`
			Gender   *int  `json:"gender,omitempty"`
			ID       *int  `json:"id,omitempty"`
			KnownFor *[]struct {
				Adult            *bool    `json:"adult,omitempty"`
				BackdropPath     *string  `json:"backdrop_path,omitempty"`
				GenreIds         *[]int   `json:"genre_ids,omitempty"`
				ID               *int     `json:"id,omitempty"`
				MediaType        *string  `json:"media_type,omitempty"`
				OriginalLanguage *string  `json:"original_language,omitempty"`
				OriginalTitle    *string  `json:"original_title,omitempty"`
				Overview         *string  `json:"overview,omitempty"`
				Popularity       *float32 `json:"popularity,omitempty"`
				PosterPath       *string  `json:"poster_path,omitempty"`
				ReleaseDate      *string  `json:"release_date,omitempty"`
				Title            *string  `json:"title,omitempty"`
				Video            *bool    `json:"video,omitempty"`
				VoteAverage      *float32 `json:"vote_average,omitempty"`
				VoteCount        *int     `json:"vote_count,omitempty"`
			} `json:"known_for,omitempty"`
			KnownForDepartment *string  `json:"known_for_department,omitempty"`
			MediaType          *string  `json:"media_type,omitempty"`
			Name               *string  `json:"name,omitempty"`
			OriginalName       *string  `json:"original_name,omitempty"`
			Popularity         *float32 `json:"popularity,omitempty"`
			ProfilePath        *string  `json:"profile_path,omitempty"`
		} `json:"results,omitempty"`
		TotalPages   *int `json:"total_pages,omitempty"`
		TotalResults *int `json:"total_results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r TrendingPeopleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TrendingPeopleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TrendingTvResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Page    *int `json:"page,omitempty"`
		Results *[]struct {
			Adult            *bool     `json:"adult,omitempty"`
			BackdropPath     *string   `json:"backdrop_path,omitempty"`
			FirstAirDate     *string   `json:"first_air_date,omitempty"`
			GenreIds         *[]int    `json:"genre_ids,omitempty"`
			ID               *int      `json:"id,omitempty"`
			MediaType        *string   `json:"media_type,omitempty"`
			Name             *string   `json:"name,omitempty"`
			OriginCountry    *[]string `json:"origin_country,omitempty"`
			OriginalLanguage *string   `json:"original_language,omitempty"`
			OriginalName     *string   `json:"original_name,omitempty"`
			Overview         *string   `json:"overview,omitempty"`
			Popularity       *float32  `json:"popularity,omitempty"`
			PosterPath       *string   `json:"poster_path,omitempty"`
			VoteAverage      *float32  `json:"vote_average,omitempty"`
			VoteCount        *int      `json:"vote_count,omitempty"`
		} `json:"results,omitempty"`
		TotalPages   *int `json:"total_pages,omitempty"`
		TotalResults *int `json:"total_results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r TrendingTvResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TrendingTvResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TvSeriesAiringTodayListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Page    *int `json:"page,omitempty"`
		Results *[]struct {
			BackdropPath     *string   `json:"backdrop_path,omitempty"`
			FirstAirDate     *string   `json:"first_air_date,omitempty"`
			GenreIds         *[]int    `json:"genre_ids,omitempty"`
			ID               *int      `json:"id,omitempty"`
			Name             *string   `json:"name,omitempty"`
			OriginCountry    *[]string `json:"origin_country,omitempty"`
			OriginalLanguage *string   `json:"original_language,omitempty"`
			OriginalName     *string   `json:"original_name,omitempty"`
			Overview         *string   `json:"overview,omitempty"`
			Popularity       *float32  `json:"popularity,omitempty"`
			PosterPath       *string   `json:"poster_path,omitempty"`
			VoteAverage      *int      `json:"vote_average,omitempty"`
			VoteCount        *int      `json:"vote_count,omitempty"`
		} `json:"results,omitempty"`
		TotalPages   *int `json:"total_pages,omitempty"`
		TotalResults *int `json:"total_results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r TvSeriesAiringTodayListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TvSeriesAiringTodayListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ChangesTvListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Page    *int `json:"page,omitempty"`
		Results *[]struct {
			Adult *bool `json:"adult,omitempty"`
			ID    *int  `json:"id,omitempty"`
		} `json:"results,omitempty"`
		TotalPages   *int `json:"total_pages,omitempty"`
		TotalResults *int `json:"total_results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ChangesTvListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ChangesTvListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TvEpisodeChangesByIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Changes *[]struct {
			Items *[]struct {
				Action *string `json:"action,omitempty"`
				ID     *string `json:"id,omitempty"`
				Time   *string `json:"time,omitempty"`
				Value  *string `json:"value,omitempty"`
			} `json:"items,omitempty"`
			Key *string `json:"key,omitempty"`
		} `json:"changes,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r TvEpisodeChangesByIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TvEpisodeChangesByIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TvEpisodeGroupDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Description  *string `json:"description,omitempty"`
		EpisodeCount *int    `json:"episode_count,omitempty"`
		GroupCount   *int    `json:"group_count,omitempty"`
		Groups       *[]struct {
			Episodes *[]struct {
				AirDate        *string      `json:"air_date,omitempty"`
				EpisodeNumber  *int         `json:"episode_number,omitempty"`
				ID             *int         `json:"id,omitempty"`
				Name           *string      `json:"name,omitempty"`
				Order          *int         `json:"order,omitempty"`
				Overview       *string      `json:"overview,omitempty"`
				ProductionCode *string      `json:"production_code,omitempty"`
				Runtime        *interface{} `json:"runtime,omitempty"`
				SeasonNumber   *int         `json:"season_number,omitempty"`
				ShowID         *int         `json:"show_id,omitempty"`
				StillPath      *string      `json:"still_path,omitempty"`
				VoteAverage    *float32     `json:"vote_average,omitempty"`
				VoteCount      *int         `json:"vote_count,omitempty"`
			} `json:"episodes,omitempty"`
			ID     *string `json:"id,omitempty"`
			Locked *bool   `json:"locked,omitempty"`
			Name   *string `json:"name,omitempty"`
			Order  *int    `json:"order,omitempty"`
		} `json:"groups,omitempty"`
		ID      *string `json:"id,omitempty"`
		Name    *string `json:"name,omitempty"`
		Network *struct {
			ID            *int    `json:"id,omitempty"`
			LogoPath      *string `json:"logo_path,omitempty"`
			Name          *string `json:"name,omitempty"`
			OriginCountry *string `json:"origin_country,omitempty"`
		} `json:"network,omitempty"`
		Type *int `json:"type,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r TvEpisodeGroupDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TvEpisodeGroupDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TvSeriesLatestIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Adult            *bool          `json:"adult,omitempty"`
		BackdropPath     *interface{}   `json:"backdrop_path,omitempty"`
		CreatedBy        *[]interface{} `json:"created_by,omitempty"`
		EpisodeRunTime   *[]interface{} `json:"episode_run_time,omitempty"`
		FirstAirDate     *string        `json:"first_air_date,omitempty"`
		Genres           *[]interface{} `json:"genres,omitempty"`
		Homepage         *string        `json:"homepage,omitempty"`
		ID               *int           `json:"id,omitempty"`
		InProduction     *bool          `json:"in_production,omitempty"`
		Languages        *[]interface{} `json:"languages,omitempty"`
		LastAirDate      *string        `json:"last_air_date,omitempty"`
		LastEpisodeToAir *struct {
			AirDate        *string      `json:"air_date,omitempty"`
			EpisodeNumber  *int         `json:"episode_number,omitempty"`
			ID             *int         `json:"id,omitempty"`
			Name           *string      `json:"name,omitempty"`
			Overview       *string      `json:"overview,omitempty"`
			ProductionCode *string      `json:"production_code,omitempty"`
			Runtime        *interface{} `json:"runtime,omitempty"`
			SeasonNumber   *int         `json:"season_number,omitempty"`
			ShowID         *int         `json:"show_id,omitempty"`
			StillPath      *interface{} `json:"still_path,omitempty"`
			VoteAverage    *int         `json:"vote_average,omitempty"`
			VoteCount      *int         `json:"vote_count,omitempty"`
		} `json:"last_episode_to_air,omitempty"`
		Name                *string        `json:"name,omitempty"`
		Networks            *[]interface{} `json:"networks,omitempty"`
		NextEpisodeToAir    *interface{}   `json:"next_episode_to_air,omitempty"`
		NumberOfEpisodes    *int           `json:"number_of_episodes,omitempty"`
		NumberOfSeasons     *int           `json:"number_of_seasons,omitempty"`
		OriginCountry       *[]string      `json:"origin_country,omitempty"`
		OriginalLanguage    *string        `json:"original_language,omitempty"`
		OriginalName        *string        `json:"original_name,omitempty"`
		Overview            *string        `json:"overview,omitempty"`
		Popularity          *int           `json:"popularity,omitempty"`
		PosterPath          *interface{}   `json:"poster_path,omitempty"`
		ProductionCompanies *[]interface{} `json:"production_companies,omitempty"`
		ProductionCountries *[]interface{} `json:"production_countries,omitempty"`
		Seasons             *[]struct {
			AirDate      *interface{} `json:"air_date,omitempty"`
			EpisodeCount *int         `json:"episode_count,omitempty"`
			ID           *int         `json:"id,omitempty"`
			Name         *string      `json:"name,omitempty"`
			Overview     *string      `json:"overview,omitempty"`
			PosterPath   *interface{} `json:"poster_path,omitempty"`
			SeasonNumber *int         `json:"season_number,omitempty"`
		} `json:"seasons,omitempty"`
		SpokenLanguages *[]interface{} `json:"spoken_languages,omitempty"`
		Status          *string        `json:"status,omitempty"`
		Tagline         *string        `json:"tagline,omitempty"`
		Type            *string        `json:"type,omitempty"`
		VoteAverage     *int           `json:"vote_average,omitempty"`
		VoteCount       *int           `json:"vote_count,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r TvSeriesLatestIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TvSeriesLatestIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TvSeriesOnTheAirListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Page    *int `json:"page,omitempty"`
		Results *[]struct {
			BackdropPath     *string   `json:"backdrop_path,omitempty"`
			FirstAirDate     *string   `json:"first_air_date,omitempty"`
			GenreIds         *[]int    `json:"genre_ids,omitempty"`
			ID               *int      `json:"id,omitempty"`
			Name             *string   `json:"name,omitempty"`
			OriginCountry    *[]string `json:"origin_country,omitempty"`
			OriginalLanguage *string   `json:"original_language,omitempty"`
			OriginalName     *string   `json:"original_name,omitempty"`
			Overview         *string   `json:"overview,omitempty"`
			Popularity       *float32  `json:"popularity,omitempty"`
			PosterPath       *string   `json:"poster_path,omitempty"`
			VoteAverage      *int      `json:"vote_average,omitempty"`
			VoteCount        *int      `json:"vote_count,omitempty"`
		} `json:"results,omitempty"`
		TotalPages   *int `json:"total_pages,omitempty"`
		TotalResults *int `json:"total_results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r TvSeriesOnTheAirListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TvSeriesOnTheAirListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TvSeriesPopularListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Page    *int `json:"page,omitempty"`
		Results *[]struct {
			BackdropPath     *string   `json:"backdrop_path,omitempty"`
			FirstAirDate     *string   `json:"first_air_date,omitempty"`
			GenreIds         *[]int    `json:"genre_ids,omitempty"`
			ID               *int      `json:"id,omitempty"`
			Name             *string   `json:"name,omitempty"`
			OriginCountry    *[]string `json:"origin_country,omitempty"`
			OriginalLanguage *string   `json:"original_language,omitempty"`
			OriginalName     *string   `json:"original_name,omitempty"`
			Overview         *string   `json:"overview,omitempty"`
			Popularity       *float32  `json:"popularity,omitempty"`
			PosterPath       *string   `json:"poster_path,omitempty"`
			VoteAverage      *int      `json:"vote_average,omitempty"`
			VoteCount        *int      `json:"vote_count,omitempty"`
		} `json:"results,omitempty"`
		TotalPages   *int `json:"total_pages,omitempty"`
		TotalResults *int `json:"total_results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r TvSeriesPopularListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TvSeriesPopularListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TvSeasonChangesByIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Changes *[]struct {
			Items *[]struct {
				Action *string `json:"action,omitempty"`
				ID     *string `json:"id,omitempty"`
				Time   *string `json:"time,omitempty"`
				Value  *struct {
					EpisodeID     *int `json:"episode_id,omitempty"`
					EpisodeNumber *int `json:"episode_number,omitempty"`
				} `json:"value,omitempty"`
			} `json:"items,omitempty"`
			Key *string `json:"key,omitempty"`
		} `json:"changes,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r TvSeasonChangesByIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TvSeasonChangesByIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TvSeriesTopRatedListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Page    *int `json:"page,omitempty"`
		Results *[]struct {
			BackdropPath     *string   `json:"backdrop_path,omitempty"`
			FirstAirDate     *string   `json:"first_air_date,omitempty"`
			GenreIds         *[]int    `json:"genre_ids,omitempty"`
			ID               *int      `json:"id,omitempty"`
			Name             *string   `json:"name,omitempty"`
			OriginCountry    *[]string `json:"origin_country,omitempty"`
			OriginalLanguage *string   `json:"original_language,omitempty"`
			OriginalName     *string   `json:"original_name,omitempty"`
			Overview         *string   `json:"overview,omitempty"`
			Popularity       *float32  `json:"popularity,omitempty"`
			PosterPath       *string   `json:"poster_path,omitempty"`
			VoteAverage      *float32  `json:"vote_average,omitempty"`
			VoteCount        *int      `json:"vote_count,omitempty"`
		} `json:"results,omitempty"`
		TotalPages   *int `json:"total_pages,omitempty"`
		TotalResults *int `json:"total_results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r TvSeriesTopRatedListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TvSeriesTopRatedListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TvSeriesDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Adult        *bool   `json:"adult,omitempty"`
		BackdropPath *string `json:"backdrop_path,omitempty"`
		CreatedBy    *[]struct {
			CreditID    *string `json:"credit_id,omitempty"`
			Gender      *int    `json:"gender,omitempty"`
			ID          *int    `json:"id,omitempty"`
			Name        *string `json:"name,omitempty"`
			ProfilePath *string `json:"profile_path,omitempty"`
		} `json:"created_by,omitempty"`
		EpisodeRunTime *[]int  `json:"episode_run_time,omitempty"`
		FirstAirDate   *string `json:"first_air_date,omitempty"`
		Genres         *[]struct {
			ID   *int    `json:"id,omitempty"`
			Name *string `json:"name,omitempty"`
		} `json:"genres,omitempty"`
		Homepage         *string   `json:"homepage,omitempty"`
		ID               *int      `json:"id,omitempty"`
		InProduction     *bool     `json:"in_production,omitempty"`
		Languages        *[]string `json:"languages,omitempty"`
		LastAirDate      *string   `json:"last_air_date,omitempty"`
		LastEpisodeToAir *struct {
			AirDate        *string  `json:"air_date,omitempty"`
			EpisodeNumber  *int     `json:"episode_number,omitempty"`
			ID             *int     `json:"id,omitempty"`
			Name           *string  `json:"name,omitempty"`
			Overview       *string  `json:"overview,omitempty"`
			ProductionCode *string  `json:"production_code,omitempty"`
			Runtime        *int     `json:"runtime,omitempty"`
			SeasonNumber   *int     `json:"season_number,omitempty"`
			ShowID         *int     `json:"show_id,omitempty"`
			StillPath      *string  `json:"still_path,omitempty"`
			VoteAverage    *float32 `json:"vote_average,omitempty"`
			VoteCount      *int     `json:"vote_count,omitempty"`
		} `json:"last_episode_to_air,omitempty"`
		Name     *string `json:"name,omitempty"`
		Networks *[]struct {
			ID            *int    `json:"id,omitempty"`
			LogoPath      *string `json:"logo_path,omitempty"`
			Name          *string `json:"name,omitempty"`
			OriginCountry *string `json:"origin_country,omitempty"`
		} `json:"networks,omitempty"`
		NextEpisodeToAir    *interface{} `json:"next_episode_to_air,omitempty"`
		NumberOfEpisodes    *int         `json:"number_of_episodes,omitempty"`
		NumberOfSeasons     *int         `json:"number_of_seasons,omitempty"`
		OriginCountry       *[]string    `json:"origin_country,omitempty"`
		OriginalLanguage    *string      `json:"original_language,omitempty"`
		OriginalName        *string      `json:"original_name,omitempty"`
		Overview            *string      `json:"overview,omitempty"`
		Popularity          *float32     `json:"popularity,omitempty"`
		PosterPath          *string      `json:"poster_path,omitempty"`
		ProductionCompanies *[]struct {
			ID            *int    `json:"id,omitempty"`
			LogoPath      *string `json:"logo_path,omitempty"`
			Name          *string `json:"name,omitempty"`
			OriginCountry *string `json:"origin_country,omitempty"`
		} `json:"production_companies,omitempty"`
		ProductionCountries *[]struct {
			Iso31661 *string `json:"iso_3166_1,omitempty"`
			Name     *string `json:"name,omitempty"`
		} `json:"production_countries,omitempty"`
		Seasons *[]struct {
			AirDate      *string `json:"air_date,omitempty"`
			EpisodeCount *int    `json:"episode_count,omitempty"`
			ID           *int    `json:"id,omitempty"`
			Name         *string `json:"name,omitempty"`
			Overview     *string `json:"overview,omitempty"`
			PosterPath   *string `json:"poster_path,omitempty"`
			SeasonNumber *int    `json:"season_number,omitempty"`
			VoteAverage  *int    `json:"vote_average,omitempty"`
		} `json:"seasons,omitempty"`
		SpokenLanguages *[]struct {
			EnglishName *string `json:"english_name,omitempty"`
			Iso6391     *string `json:"iso_639_1,omitempty"`
			Name        *string `json:"name,omitempty"`
		} `json:"spoken_languages,omitempty"`
		Status      *string  `json:"status,omitempty"`
		Tagline     *string  `json:"tagline,omitempty"`
		Type        *string  `json:"type,omitempty"`
		VoteAverage *float32 `json:"vote_average,omitempty"`
		VoteCount   *int     `json:"vote_count,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r TvSeriesDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TvSeriesDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TvSeriesAccountStatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Favorite *bool `json:"favorite,omitempty"`
		ID       *int  `json:"id,omitempty"`
		Rated    *struct {
			Value *int `json:"value,omitempty"`
		} `json:"rated,omitempty"`
		Watchlist *bool `json:"watchlist,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r TvSeriesAccountStatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TvSeriesAccountStatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TvSeriesAggregateCreditsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Cast *[]struct {
			Adult              *bool    `json:"adult,omitempty"`
			Gender             *int     `json:"gender,omitempty"`
			ID                 *int     `json:"id,omitempty"`
			KnownForDepartment *string  `json:"known_for_department,omitempty"`
			Name               *string  `json:"name,omitempty"`
			Order              *int     `json:"order,omitempty"`
			OriginalName       *string  `json:"original_name,omitempty"`
			Popularity         *float32 `json:"popularity,omitempty"`
			ProfilePath        *string  `json:"profile_path,omitempty"`
			Roles              *[]struct {
				Character    *string `json:"character,omitempty"`
				CreditID     *string `json:"credit_id,omitempty"`
				EpisodeCount *int    `json:"episode_count,omitempty"`
			} `json:"roles,omitempty"`
			TotalEpisodeCount *int `json:"total_episode_count,omitempty"`
		} `json:"cast,omitempty"`
		Crew *[]struct {
			Adult      *bool   `json:"adult,omitempty"`
			Department *string `json:"department,omitempty"`
			Gender     *int    `json:"gender,omitempty"`
			ID         *int    `json:"id,omitempty"`
			Jobs       *[]struct {
				CreditID     *string `json:"credit_id,omitempty"`
				EpisodeCount *int    `json:"episode_count,omitempty"`
				Job          *string `json:"job,omitempty"`
			} `json:"jobs,omitempty"`
			KnownForDepartment *string  `json:"known_for_department,omitempty"`
			Name               *string  `json:"name,omitempty"`
			OriginalName       *string  `json:"original_name,omitempty"`
			Popularity         *float32 `json:"popularity,omitempty"`
			ProfilePath        *string  `json:"profile_path,omitempty"`
			TotalEpisodeCount  *int     `json:"total_episode_count,omitempty"`
		} `json:"crew,omitempty"`
		ID *int `json:"id,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r TvSeriesAggregateCreditsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TvSeriesAggregateCreditsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TvSeriesAlternativeTitlesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		ID      *int `json:"id,omitempty"`
		Results *[]struct {
			Iso31661 *string `json:"iso_3166_1,omitempty"`
			Title    *string `json:"title,omitempty"`
			Type     *string `json:"type,omitempty"`
		} `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r TvSeriesAlternativeTitlesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TvSeriesAlternativeTitlesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TvSeriesChangesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Changes *[]struct {
			Items *[]struct {
				Action        *string `json:"action,omitempty"`
				ID            *string `json:"id,omitempty"`
				Iso31661      *string `json:"iso_3166_1,omitempty"`
				Iso6391       *string `json:"iso_639_1,omitempty"`
				OriginalValue *struct {
					Poster *struct {
						FilePath *string `json:"file_path,omitempty"`
						Iso6391  *string `json:"iso_639_1,omitempty"`
					} `json:"poster,omitempty"`
				} `json:"original_value,omitempty"`
				Time  *string `json:"time,omitempty"`
				Value *struct {
					Poster *struct {
						FilePath *string `json:"file_path,omitempty"`
						Iso6391  *string `json:"iso_639_1,omitempty"`
					} `json:"poster,omitempty"`
				} `json:"value,omitempty"`
			} `json:"items,omitempty"`
			Key *string `json:"key,omitempty"`
		} `json:"changes,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r TvSeriesChangesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TvSeriesChangesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TvSeriesContentRatingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		ID      *int `json:"id,omitempty"`
		Results *[]struct {
			Descriptors *[]interface{} `json:"descriptors,omitempty"`
			Iso31661    *string        `json:"iso_3166_1,omitempty"`
			Rating      *string        `json:"rating,omitempty"`
		} `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r TvSeriesContentRatingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TvSeriesContentRatingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TvSeriesCreditsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Cast *[]struct {
			Adult              *bool    `json:"adult,omitempty"`
			Character          *string  `json:"character,omitempty"`
			CreditID           *string  `json:"credit_id,omitempty"`
			Gender             *int     `json:"gender,omitempty"`
			ID                 *int     `json:"id,omitempty"`
			KnownForDepartment *string  `json:"known_for_department,omitempty"`
			Name               *string  `json:"name,omitempty"`
			Order              *int     `json:"order,omitempty"`
			OriginalName       *string  `json:"original_name,omitempty"`
			Popularity         *float32 `json:"popularity,omitempty"`
			ProfilePath        *string  `json:"profile_path,omitempty"`
		} `json:"cast,omitempty"`
		Crew *[]struct {
			Adult              *bool    `json:"adult,omitempty"`
			CreditID           *string  `json:"credit_id,omitempty"`
			Department         *string  `json:"department,omitempty"`
			Gender             *int     `json:"gender,omitempty"`
			ID                 *int     `json:"id,omitempty"`
			Job                *string  `json:"job,omitempty"`
			KnownForDepartment *string  `json:"known_for_department,omitempty"`
			Name               *string  `json:"name,omitempty"`
			OriginalName       *string  `json:"original_name,omitempty"`
			Popularity         *float32 `json:"popularity,omitempty"`
			ProfilePath        *string  `json:"profile_path,omitempty"`
		} `json:"crew,omitempty"`
		ID *int `json:"id,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r TvSeriesCreditsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TvSeriesCreditsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TvSeriesEpisodeGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		ID      *int `json:"id,omitempty"`
		Results *[]struct {
			Description  *string `json:"description,omitempty"`
			EpisodeCount *int    `json:"episode_count,omitempty"`
			GroupCount   *int    `json:"group_count,omitempty"`
			ID           *string `json:"id,omitempty"`
			Name         *string `json:"name,omitempty"`
			Network      *struct {
				ID            *int    `json:"id,omitempty"`
				LogoPath      *string `json:"logo_path,omitempty"`
				Name          *string `json:"name,omitempty"`
				OriginCountry *string `json:"origin_country,omitempty"`
			} `json:"network,omitempty"`
			Type *int `json:"type,omitempty"`
		} `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r TvSeriesEpisodeGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TvSeriesEpisodeGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TvSeriesExternalIdsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		FacebookID  *string `json:"facebook_id,omitempty"`
		FreebaseID  *string `json:"freebase_id,omitempty"`
		FreebaseMid *string `json:"freebase_mid,omitempty"`
		ID          *int    `json:"id,omitempty"`
		ImdbID      *string `json:"imdb_id,omitempty"`
		InstagramID *string `json:"instagram_id,omitempty"`
		TvdbID      *int    `json:"tvdb_id,omitempty"`
		TvrageID    *int    `json:"tvrage_id,omitempty"`
		TwitterID   *string `json:"twitter_id,omitempty"`
		WikidataID  *string `json:"wikidata_id,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r TvSeriesExternalIdsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TvSeriesExternalIdsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TvSeriesImagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Backdrops *[]struct {
			AspectRatio *float32     `json:"aspect_ratio,omitempty"`
			FilePath    *string      `json:"file_path,omitempty"`
			Height      *int         `json:"height,omitempty"`
			Iso6391     *interface{} `json:"iso_639_1,omitempty"`
			VoteAverage *float32     `json:"vote_average,omitempty"`
			VoteCount   *int         `json:"vote_count,omitempty"`
			Width       *int         `json:"width,omitempty"`
		} `json:"backdrops,omitempty"`
		ID    *int `json:"id,omitempty"`
		Logos *[]struct {
			AspectRatio *float32 `json:"aspect_ratio,omitempty"`
			FilePath    *string  `json:"file_path,omitempty"`
			Height      *int     `json:"height,omitempty"`
			Iso6391     *string  `json:"iso_639_1,omitempty"`
			VoteAverage *float32 `json:"vote_average,omitempty"`
			VoteCount   *int     `json:"vote_count,omitempty"`
			Width       *int     `json:"width,omitempty"`
		} `json:"logos,omitempty"`
		Posters *[]struct {
			AspectRatio *float32 `json:"aspect_ratio,omitempty"`
			FilePath    *string  `json:"file_path,omitempty"`
			Height      *int     `json:"height,omitempty"`
			Iso6391     *string  `json:"iso_639_1,omitempty"`
			VoteAverage *float32 `json:"vote_average,omitempty"`
			VoteCount   *int     `json:"vote_count,omitempty"`
			Width       *int     `json:"width,omitempty"`
		} `json:"posters,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r TvSeriesImagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TvSeriesImagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TvSeriesKeywordsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		ID      *int `json:"id,omitempty"`
		Results *[]struct {
			ID   *int    `json:"id,omitempty"`
			Name *string `json:"name,omitempty"`
		} `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r TvSeriesKeywordsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TvSeriesKeywordsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListsCopyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		ID      *int `json:"id,omitempty"`
		Page    *int `json:"page,omitempty"`
		Results *[]struct {
			Description   *string      `json:"description,omitempty"`
			FavoriteCount *int         `json:"favorite_count,omitempty"`
			ID            *int         `json:"id,omitempty"`
			Iso31661      *string      `json:"iso_3166_1,omitempty"`
			Iso6391       *string      `json:"iso_639_1,omitempty"`
			ItemCount     *int         `json:"item_count,omitempty"`
			Name          *string      `json:"name,omitempty"`
			PosterPath    *interface{} `json:"poster_path,omitempty"`
		} `json:"results,omitempty"`
		TotalPages   *int `json:"total_pages,omitempty"`
		TotalResults *int `json:"total_results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListsCopyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListsCopyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TvSeriesDeleteRatingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		StatusCode    *int    `json:"status_code,omitempty"`
		StatusMessage *string `json:"status_message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r TvSeriesDeleteRatingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TvSeriesDeleteRatingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TvSeriesAddRatingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		StatusCode    *int    `json:"status_code,omitempty"`
		StatusMessage *string `json:"status_message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r TvSeriesAddRatingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TvSeriesAddRatingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TvSeriesRecommendationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Page    *int `json:"page,omitempty"`
		Results *[]struct {
			Adult            *bool     `json:"adult,omitempty"`
			BackdropPath     *string   `json:"backdrop_path,omitempty"`
			FirstAirDate     *string   `json:"first_air_date,omitempty"`
			GenreIds         *[]int    `json:"genre_ids,omitempty"`
			ID               *int      `json:"id,omitempty"`
			MediaType        *string   `json:"media_type,omitempty"`
			Name             *string   `json:"name,omitempty"`
			OriginCountry    *[]string `json:"origin_country,omitempty"`
			OriginalLanguage *string   `json:"original_language,omitempty"`
			OriginalName     *string   `json:"original_name,omitempty"`
			Overview         *string   `json:"overview,omitempty"`
			Popularity       *float32  `json:"popularity,omitempty"`
			PosterPath       *string   `json:"poster_path,omitempty"`
			VoteAverage      *float32  `json:"vote_average,omitempty"`
			VoteCount        *int      `json:"vote_count,omitempty"`
		} `json:"results,omitempty"`
		TotalPages   *int `json:"total_pages,omitempty"`
		TotalResults *int `json:"total_results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r TvSeriesRecommendationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TvSeriesRecommendationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TvSeriesReviewsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		ID      *int `json:"id,omitempty"`
		Page    *int `json:"page,omitempty"`
		Results *[]struct {
			Author        *string `json:"author,omitempty"`
			AuthorDetails *struct {
				AvatarPath *string `json:"avatar_path,omitempty"`
				Name       *string `json:"name,omitempty"`
				Rating     *int    `json:"rating,omitempty"`
				Username   *string `json:"username,omitempty"`
			} `json:"author_details,omitempty"`
			Content   *string `json:"content,omitempty"`
			CreatedAt *string `json:"created_at,omitempty"`
			ID        *string `json:"id,omitempty"`
			UpdatedAt *string `json:"updated_at,omitempty"`
			URL       *string `json:"url,omitempty"`
		} `json:"results,omitempty"`
		TotalPages   *int `json:"total_pages,omitempty"`
		TotalResults *int `json:"total_results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r TvSeriesReviewsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TvSeriesReviewsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TvSeriesScreenedTheatricallyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		ID      *int `json:"id,omitempty"`
		Results *[]struct {
			EpisodeNumber *int `json:"episode_number,omitempty"`
			ID            *int `json:"id,omitempty"`
			SeasonNumber  *int `json:"season_number,omitempty"`
		} `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r TvSeriesScreenedTheatricallyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TvSeriesScreenedTheatricallyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TvSeasonDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Identifier *string `json:"_id,omitempty"`
		AirDate    *string `json:"air_date,omitempty"`
		Episodes   *[]struct {
			AirDate *string `json:"air_date,omitempty"`
			Crew    *[]struct {
				Adult              *bool    `json:"adult,omitempty"`
				CreditID           *string  `json:"credit_id,omitempty"`
				Department         *string  `json:"department,omitempty"`
				Gender             *int     `json:"gender,omitempty"`
				ID                 *int     `json:"id,omitempty"`
				Job                *string  `json:"job,omitempty"`
				KnownForDepartment *string  `json:"known_for_department,omitempty"`
				Name               *string  `json:"name,omitempty"`
				OriginalName       *string  `json:"original_name,omitempty"`
				Popularity         *float32 `json:"popularity,omitempty"`
				ProfilePath        *string  `json:"profile_path,omitempty"`
			} `json:"crew,omitempty"`
			EpisodeNumber *int `json:"episode_number,omitempty"`
			GuestStars    *[]struct {
				Adult              *bool    `json:"adult,omitempty"`
				Character          *string  `json:"character,omitempty"`
				CreditID           *string  `json:"credit_id,omitempty"`
				Gender             *int     `json:"gender,omitempty"`
				ID                 *int     `json:"id,omitempty"`
				KnownForDepartment *string  `json:"known_for_department,omitempty"`
				Name               *string  `json:"name,omitempty"`
				Order              *int     `json:"order,omitempty"`
				OriginalName       *string  `json:"original_name,omitempty"`
				Popularity         *float32 `json:"popularity,omitempty"`
				ProfilePath        *string  `json:"profile_path,omitempty"`
			} `json:"guest_stars,omitempty"`
			ID             *int     `json:"id,omitempty"`
			Name           *string  `json:"name,omitempty"`
			Overview       *string  `json:"overview,omitempty"`
			ProductionCode *string  `json:"production_code,omitempty"`
			Runtime        *int     `json:"runtime,omitempty"`
			SeasonNumber   *int     `json:"season_number,omitempty"`
			ShowID         *int     `json:"show_id,omitempty"`
			StillPath      *string  `json:"still_path,omitempty"`
			VoteAverage    *float32 `json:"vote_average,omitempty"`
			VoteCount      *int     `json:"vote_count,omitempty"`
		} `json:"episodes,omitempty"`
		ID           *int     `json:"id,omitempty"`
		Name         *string  `json:"name,omitempty"`
		Overview     *string  `json:"overview,omitempty"`
		PosterPath   *string  `json:"poster_path,omitempty"`
		SeasonNumber *int     `json:"season_number,omitempty"`
		VoteAverage  *float32 `json:"vote_average,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r TvSeasonDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TvSeasonDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TvSeasonAccountStatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		ID      *int `json:"id,omitempty"`
		Results *[]struct {
			EpisodeNumber *int `json:"episode_number,omitempty"`
			ID            *int `json:"id,omitempty"`
			Rated         *struct {
				Value *int `json:"value,omitempty"`
			} `json:"rated,omitempty"`
		} `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r TvSeasonAccountStatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TvSeasonAccountStatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TvSeasonAggregateCreditsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Cast *[]struct {
			Adult              *bool    `json:"adult,omitempty"`
			Gender             *int     `json:"gender,omitempty"`
			ID                 *int     `json:"id,omitempty"`
			KnownForDepartment *string  `json:"known_for_department,omitempty"`
			Name               *string  `json:"name,omitempty"`
			Order              *int     `json:"order,omitempty"`
			OriginalName       *string  `json:"original_name,omitempty"`
			Popularity         *float32 `json:"popularity,omitempty"`
			ProfilePath        *string  `json:"profile_path,omitempty"`
			Roles              *[]struct {
				Character    *string `json:"character,omitempty"`
				CreditID     *string `json:"credit_id,omitempty"`
				EpisodeCount *int    `json:"episode_count,omitempty"`
			} `json:"roles,omitempty"`
			TotalEpisodeCount *int `json:"total_episode_count,omitempty"`
		} `json:"cast,omitempty"`
		Crew *[]struct {
			Adult      *bool   `json:"adult,omitempty"`
			Department *string `json:"department,omitempty"`
			Gender     *int    `json:"gender,omitempty"`
			ID         *int    `json:"id,omitempty"`
			Jobs       *[]struct {
				CreditID     *string `json:"credit_id,omitempty"`
				EpisodeCount *int    `json:"episode_count,omitempty"`
				Job          *string `json:"job,omitempty"`
			} `json:"jobs,omitempty"`
			KnownForDepartment *string      `json:"known_for_department,omitempty"`
			Name               *string      `json:"name,omitempty"`
			OriginalName       *string      `json:"original_name,omitempty"`
			Popularity         *float32     `json:"popularity,omitempty"`
			ProfilePath        *interface{} `json:"profile_path,omitempty"`
			TotalEpisodeCount  *int         `json:"total_episode_count,omitempty"`
		} `json:"crew,omitempty"`
		ID *int `json:"id,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r TvSeasonAggregateCreditsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TvSeasonAggregateCreditsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TvSeasonCreditsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Cast *[]struct {
			Adult              *bool    `json:"adult,omitempty"`
			Character          *string  `json:"character,omitempty"`
			CreditID           *string  `json:"credit_id,omitempty"`
			Gender             *int     `json:"gender,omitempty"`
			ID                 *int     `json:"id,omitempty"`
			KnownForDepartment *string  `json:"known_for_department,omitempty"`
			Name               *string  `json:"name,omitempty"`
			Order              *int     `json:"order,omitempty"`
			OriginalName       *string  `json:"original_name,omitempty"`
			Popularity         *float32 `json:"popularity,omitempty"`
			ProfilePath        *string  `json:"profile_path,omitempty"`
		} `json:"cast,omitempty"`
		Crew *[]struct {
			Adult              *bool        `json:"adult,omitempty"`
			CreditID           *string      `json:"credit_id,omitempty"`
			Department         *string      `json:"department,omitempty"`
			Gender             *int         `json:"gender,omitempty"`
			ID                 *int         `json:"id,omitempty"`
			Job                *string      `json:"job,omitempty"`
			KnownForDepartment *string      `json:"known_for_department,omitempty"`
			Name               *string      `json:"name,omitempty"`
			OriginalName       *string      `json:"original_name,omitempty"`
			Popularity         *float32     `json:"popularity,omitempty"`
			ProfilePath        *interface{} `json:"profile_path,omitempty"`
		} `json:"crew,omitempty"`
		ID *int `json:"id,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r TvSeasonCreditsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TvSeasonCreditsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TvEpisodeDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AirDate *string `json:"air_date,omitempty"`
		Crew    *[]struct {
			Adult              *bool    `json:"adult,omitempty"`
			CreditID           *string  `json:"credit_id,omitempty"`
			Department         *string  `json:"department,omitempty"`
			Gender             *int     `json:"gender,omitempty"`
			ID                 *int     `json:"id,omitempty"`
			Job                *string  `json:"job,omitempty"`
			KnownForDepartment *string  `json:"known_for_department,omitempty"`
			Name               *string  `json:"name,omitempty"`
			OriginalName       *string  `json:"original_name,omitempty"`
			Popularity         *float32 `json:"popularity,omitempty"`
			ProfilePath        *string  `json:"profile_path,omitempty"`
		} `json:"crew,omitempty"`
		EpisodeNumber *int `json:"episode_number,omitempty"`
		GuestStars    *[]struct {
			Adult              *bool    `json:"adult,omitempty"`
			Character          *string  `json:"character,omitempty"`
			CreditID           *string  `json:"credit_id,omitempty"`
			Gender             *int     `json:"gender,omitempty"`
			ID                 *int     `json:"id,omitempty"`
			KnownForDepartment *string  `json:"known_for_department,omitempty"`
			Name               *string  `json:"name,omitempty"`
			Order              *int     `json:"order,omitempty"`
			OriginalName       *string  `json:"original_name,omitempty"`
			Popularity         *float32 `json:"popularity,omitempty"`
			ProfilePath        *string  `json:"profile_path,omitempty"`
		} `json:"guest_stars,omitempty"`
		ID             *int     `json:"id,omitempty"`
		Name           *string  `json:"name,omitempty"`
		Overview       *string  `json:"overview,omitempty"`
		ProductionCode *string  `json:"production_code,omitempty"`
		Runtime        *int     `json:"runtime,omitempty"`
		SeasonNumber   *int     `json:"season_number,omitempty"`
		StillPath      *string  `json:"still_path,omitempty"`
		VoteAverage    *float32 `json:"vote_average,omitempty"`
		VoteCount      *int     `json:"vote_count,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r TvEpisodeDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TvEpisodeDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TvEpisodeAccountStatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Favorite *bool `json:"favorite,omitempty"`
		ID       *int  `json:"id,omitempty"`
		Rated    *struct {
			Value *int `json:"value,omitempty"`
		} `json:"rated,omitempty"`
		Watchlist *bool `json:"watchlist,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r TvEpisodeAccountStatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TvEpisodeAccountStatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TvEpisodeCreditsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Cast *[]struct {
			Adult              *bool    `json:"adult,omitempty"`
			Character          *string  `json:"character,omitempty"`
			CreditID           *string  `json:"credit_id,omitempty"`
			Gender             *int     `json:"gender,omitempty"`
			ID                 *int     `json:"id,omitempty"`
			KnownForDepartment *string  `json:"known_for_department,omitempty"`
			Name               *string  `json:"name,omitempty"`
			Order              *int     `json:"order,omitempty"`
			OriginalName       *string  `json:"original_name,omitempty"`
			Popularity         *float32 `json:"popularity,omitempty"`
			ProfilePath        *string  `json:"profile_path,omitempty"`
		} `json:"cast,omitempty"`
		Crew *[]struct {
			Adult              *bool    `json:"adult,omitempty"`
			CreditID           *string  `json:"credit_id,omitempty"`
			Department         *string  `json:"department,omitempty"`
			Gender             *int     `json:"gender,omitempty"`
			ID                 *int     `json:"id,omitempty"`
			Job                *string  `json:"job,omitempty"`
			KnownForDepartment *string  `json:"known_for_department,omitempty"`
			Name               *string  `json:"name,omitempty"`
			OriginalName       *string  `json:"original_name,omitempty"`
			Popularity         *float32 `json:"popularity,omitempty"`
			ProfilePath        *string  `json:"profile_path,omitempty"`
		} `json:"crew,omitempty"`
		GuestStars *[]struct {
			Adult              *bool    `json:"adult,omitempty"`
			Character          *string  `json:"character,omitempty"`
			CreditID           *string  `json:"credit_id,omitempty"`
			Gender             *int     `json:"gender,omitempty"`
			ID                 *int     `json:"id,omitempty"`
			KnownForDepartment *string  `json:"known_for_department,omitempty"`
			Name               *string  `json:"name,omitempty"`
			Order              *int     `json:"order,omitempty"`
			OriginalName       *string  `json:"original_name,omitempty"`
			Popularity         *float32 `json:"popularity,omitempty"`
			ProfilePath        *string  `json:"profile_path,omitempty"`
		} `json:"guest_stars,omitempty"`
		ID *int `json:"id,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r TvEpisodeCreditsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TvEpisodeCreditsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TvEpisodeExternalIdsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		FreebaseID  *string `json:"freebase_id,omitempty"`
		FreebaseMid *string `json:"freebase_mid,omitempty"`
		ID          *int    `json:"id,omitempty"`
		ImdbID      *string `json:"imdb_id,omitempty"`
		TvdbID      *int    `json:"tvdb_id,omitempty"`
		TvrageID    *int    `json:"tvrage_id,omitempty"`
		WikidataID  *string `json:"wikidata_id,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r TvEpisodeExternalIdsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TvEpisodeExternalIdsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TvEpisodeImagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		ID     *int `json:"id,omitempty"`
		Stills *[]struct {
			AspectRatio *float32     `json:"aspect_ratio,omitempty"`
			FilePath    *string      `json:"file_path,omitempty"`
			Height      *int         `json:"height,omitempty"`
			Iso6391     *interface{} `json:"iso_639_1,omitempty"`
			VoteAverage *float32     `json:"vote_average,omitempty"`
			VoteCount   *int         `json:"vote_count,omitempty"`
			Width       *int         `json:"width,omitempty"`
		} `json:"stills,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r TvEpisodeImagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TvEpisodeImagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TvEpisodeDeleteRatingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		StatusCode    *int    `json:"status_code,omitempty"`
		StatusMessage *string `json:"status_message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r TvEpisodeDeleteRatingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TvEpisodeDeleteRatingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TvEpisodeAddRatingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		StatusCode    *int    `json:"status_code,omitempty"`
		StatusMessage *string `json:"status_message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r TvEpisodeAddRatingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TvEpisodeAddRatingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TvEpisodeTranslationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		ID           *int `json:"id,omitempty"`
		Translations *[]struct {
			Data *struct {
				Name     *string `json:"name,omitempty"`
				Overview *string `json:"overview,omitempty"`
			} `json:"data,omitempty"`
			EnglishName *string `json:"english_name,omitempty"`
			Iso31661    *string `json:"iso_3166_1,omitempty"`
			Iso6391     *string `json:"iso_639_1,omitempty"`
			Name        *string `json:"name,omitempty"`
		} `json:"translations,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r TvEpisodeTranslationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TvEpisodeTranslationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TvEpisodeVideosResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		ID      *int `json:"id,omitempty"`
		Results *[]struct {
			ID          *string `json:"id,omitempty"`
			Iso31661    *string `json:"iso_3166_1,omitempty"`
			Iso6391     *string `json:"iso_639_1,omitempty"`
			Key         *string `json:"key,omitempty"`
			Name        *string `json:"name,omitempty"`
			Official    *bool   `json:"official,omitempty"`
			PublishedAt *string `json:"published_at,omitempty"`
			Site        *string `json:"site,omitempty"`
			Size        *int    `json:"size,omitempty"`
			Type        *string `json:"type,omitempty"`
		} `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r TvEpisodeVideosResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TvEpisodeVideosResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TvSeasonExternalIdsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		FreebaseID  *string      `json:"freebase_id,omitempty"`
		FreebaseMid *string      `json:"freebase_mid,omitempty"`
		ID          *int         `json:"id,omitempty"`
		TvdbID      *int         `json:"tvdb_id,omitempty"`
		TvrageID    *interface{} `json:"tvrage_id,omitempty"`
		WikidataID  *string      `json:"wikidata_id,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r TvSeasonExternalIdsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TvSeasonExternalIdsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TvSeasonImagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		ID      *int `json:"id,omitempty"`
		Posters *[]struct {
			AspectRatio *float32 `json:"aspect_ratio,omitempty"`
			FilePath    *string  `json:"file_path,omitempty"`
			Height      *int     `json:"height,omitempty"`
			Iso6391     *string  `json:"iso_639_1,omitempty"`
			VoteAverage *float32 `json:"vote_average,omitempty"`
			VoteCount   *int     `json:"vote_count,omitempty"`
			Width       *int     `json:"width,omitempty"`
		} `json:"posters,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r TvSeasonImagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TvSeasonImagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TvSeasonTranslationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		ID           *int `json:"id,omitempty"`
		Translations *[]struct {
			Data *struct {
				Name     *string `json:"name,omitempty"`
				Overview *string `json:"overview,omitempty"`
			} `json:"data,omitempty"`
			EnglishName *string `json:"english_name,omitempty"`
			Iso31661    *string `json:"iso_3166_1,omitempty"`
			Iso6391     *string `json:"iso_639_1,omitempty"`
			Name        *string `json:"name,omitempty"`
		} `json:"translations,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r TvSeasonTranslationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TvSeasonTranslationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TvSeasonVideosResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		ID      *int `json:"id,omitempty"`
		Results *[]struct {
			ID          *string `json:"id,omitempty"`
			Iso31661    *string `json:"iso_3166_1,omitempty"`
			Iso6391     *string `json:"iso_639_1,omitempty"`
			Key         *string `json:"key,omitempty"`
			Name        *string `json:"name,omitempty"`
			Official    *bool   `json:"official,omitempty"`
			PublishedAt *string `json:"published_at,omitempty"`
			Site        *string `json:"site,omitempty"`
			Size        *int    `json:"size,omitempty"`
			Type        *string `json:"type,omitempty"`
		} `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r TvSeasonVideosResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TvSeasonVideosResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TvSeasonWatchProvidersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		ID      *int `json:"id,omitempty"`
		Results *struct {
			AE *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"AE,omitempty"`
			AR *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"AR,omitempty"`
			AT *struct {
				Buy *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"buy,omitempty"`
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"AT,omitempty"`
			AU *struct {
				Buy *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"buy,omitempty"`
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"AU,omitempty"`
			BA *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"BA,omitempty"`
			BB *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"BB,omitempty"`
			BE *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"BE,omitempty"`
			BG *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"BG,omitempty"`
			BO *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"BO,omitempty"`
			BR *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"BR,omitempty"`
			BS *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"BS,omitempty"`
			CA *struct {
				Buy *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"buy,omitempty"`
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"CA,omitempty"`
			CH *struct {
				Buy *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"buy,omitempty"`
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"CH,omitempty"`
			CI *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"CI,omitempty"`
			CL *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"CL,omitempty"`
			CO *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"CO,omitempty"`
			CR *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"CR,omitempty"`
			CZ *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"CZ,omitempty"`
			DE *struct {
				Buy *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"buy,omitempty"`
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"DE,omitempty"`
			DK *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"DK,omitempty"`
			DO *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"DO,omitempty"`
			DZ *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"DZ,omitempty"`
			EC *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"EC,omitempty"`
			EG *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"EG,omitempty"`
			ES *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"ES,omitempty"`
			FI *struct {
				Buy *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"buy,omitempty"`
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"FI,omitempty"`
			FR *struct {
				Buy *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"buy,omitempty"`
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"FR,omitempty"`
			GB *struct {
				Buy *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"buy,omitempty"`
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"GB,omitempty"`
			GF *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"GF,omitempty"`
			GH *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"GH,omitempty"`
			GQ *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"GQ,omitempty"`
			GT *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"GT,omitempty"`
			HK *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"HK,omitempty"`
			HN *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"HN,omitempty"`
			HR *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"HR,omitempty"`
			HU *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"HU,omitempty"`
			ID *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"ID,omitempty"`
			IE *struct {
				Buy *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"buy,omitempty"`
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"IE,omitempty"`
			IL *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"IL,omitempty"`
			IQ *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"IQ,omitempty"`
			IT *struct {
				Buy *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"buy,omitempty"`
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"IT,omitempty"`
			JM *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"JM,omitempty"`
			JP *struct {
				Buy *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"buy,omitempty"`
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
				Rent *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"rent,omitempty"`
			} `json:"JP,omitempty"`
			KE *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"KE,omitempty"`
			KR *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"KR,omitempty"`
			LB *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"LB,omitempty"`
			LY *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"LY,omitempty"`
			MD *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"MD,omitempty"`
			MK *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"MK,omitempty"`
			MU *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"MU,omitempty"`
			MX *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"MX,omitempty"`
			MY *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"MY,omitempty"`
			MZ *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"MZ,omitempty"`
			NE *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"NE,omitempty"`
			NG *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"NG,omitempty"`
			NL *struct {
				Buy *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"buy,omitempty"`
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"NL,omitempty"`
			NO *struct {
				Buy *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"buy,omitempty"`
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"NO,omitempty"`
			NZ *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"NZ,omitempty"`
			PA *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"PA,omitempty"`
			PE *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"PE,omitempty"`
			PH *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"PH,omitempty"`
			PL *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
				Rent *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"rent,omitempty"`
			} `json:"PL,omitempty"`
			PS *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"PS,omitempty"`
			PT *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"PT,omitempty"`
			PY *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"PY,omitempty"`
			RO *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"RO,omitempty"`
			RS *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"RS,omitempty"`
			RU *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"RU,omitempty"`
			SA *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"SA,omitempty"`
			SC *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"SC,omitempty"`
			SE *struct {
				Buy *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"buy,omitempty"`
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"SE,omitempty"`
			SG *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"SG,omitempty"`
			SI *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"SI,omitempty"`
			SK *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"SK,omitempty"`
			SN *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"SN,omitempty"`
			SV *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"SV,omitempty"`
			TH *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"TH,omitempty"`
			TR *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"TR,omitempty"`
			TT *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"TT,omitempty"`
			TW *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"TW,omitempty"`
			TZ *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"TZ,omitempty"`
			UG *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"UG,omitempty"`
			US *struct {
				Buy *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"buy,omitempty"`
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Free *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"free,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"US,omitempty"`
			UY *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"UY,omitempty"`
			VE *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"VE,omitempty"`
			ZA *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"ZA,omitempty"`
			ZM *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"ZM,omitempty"`
		} `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r TvSeasonWatchProvidersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TvSeasonWatchProvidersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TvSeriesSimilarResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Page    *int `json:"page,omitempty"`
		Results *[]struct {
			Adult            *bool     `json:"adult,omitempty"`
			BackdropPath     *string   `json:"backdrop_path,omitempty"`
			FirstAirDate     *string   `json:"first_air_date,omitempty"`
			GenreIds         *[]int    `json:"genre_ids,omitempty"`
			ID               *int      `json:"id,omitempty"`
			Name             *string   `json:"name,omitempty"`
			OriginCountry    *[]string `json:"origin_country,omitempty"`
			OriginalLanguage *string   `json:"original_language,omitempty"`
			OriginalName     *string   `json:"original_name,omitempty"`
			Overview         *string   `json:"overview,omitempty"`
			Popularity       *float32  `json:"popularity,omitempty"`
			PosterPath       *string   `json:"poster_path,omitempty"`
			VoteAverage      *int      `json:"vote_average,omitempty"`
			VoteCount        *int      `json:"vote_count,omitempty"`
		} `json:"results,omitempty"`
		TotalPages   *int `json:"total_pages,omitempty"`
		TotalResults *int `json:"total_results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r TvSeriesSimilarResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TvSeriesSimilarResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TvSeriesTranslationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		ID           *int `json:"id,omitempty"`
		Translations *[]struct {
			Data *struct {
				Homepage *string `json:"homepage,omitempty"`
				Name     *string `json:"name,omitempty"`
				Overview *string `json:"overview,omitempty"`
				Tagline  *string `json:"tagline,omitempty"`
			} `json:"data,omitempty"`
			EnglishName *string `json:"english_name,omitempty"`
			Iso31661    *string `json:"iso_3166_1,omitempty"`
			Iso6391     *string `json:"iso_639_1,omitempty"`
			Name        *string `json:"name,omitempty"`
		} `json:"translations,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r TvSeriesTranslationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TvSeriesTranslationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TvSeriesVideosResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		ID      *int `json:"id,omitempty"`
		Results *[]struct {
			ID          *string `json:"id,omitempty"`
			Iso31661    *string `json:"iso_3166_1,omitempty"`
			Iso6391     *string `json:"iso_639_1,omitempty"`
			Key         *string `json:"key,omitempty"`
			Name        *string `json:"name,omitempty"`
			Official    *bool   `json:"official,omitempty"`
			PublishedAt *string `json:"published_at,omitempty"`
			Site        *string `json:"site,omitempty"`
			Size        *int    `json:"size,omitempty"`
			Type        *string `json:"type,omitempty"`
		} `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r TvSeriesVideosResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TvSeriesVideosResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TvSeriesWatchProvidersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		ID      *int `json:"id,omitempty"`
		Results *struct {
			AE *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"AE,omitempty"`
			AR *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"AR,omitempty"`
			AT *struct {
				Buy *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"buy,omitempty"`
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"AT,omitempty"`
			AU *struct {
				Buy *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"buy,omitempty"`
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"AU,omitempty"`
			BA *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"BA,omitempty"`
			BB *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"BB,omitempty"`
			BE *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"BE,omitempty"`
			BG *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"BG,omitempty"`
			BO *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"BO,omitempty"`
			BR *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"BR,omitempty"`
			BS *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"BS,omitempty"`
			CA *struct {
				Buy *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"buy,omitempty"`
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"CA,omitempty"`
			CH *struct {
				Buy *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"buy,omitempty"`
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"CH,omitempty"`
			CI *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"CI,omitempty"`
			CL *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"CL,omitempty"`
			CO *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"CO,omitempty"`
			CR *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"CR,omitempty"`
			CZ *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"CZ,omitempty"`
			DE *struct {
				Buy *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"buy,omitempty"`
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"DE,omitempty"`
			DK *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"DK,omitempty"`
			DO *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"DO,omitempty"`
			DZ *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"DZ,omitempty"`
			EC *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"EC,omitempty"`
			EG *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"EG,omitempty"`
			ES *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"ES,omitempty"`
			FI *struct {
				Buy *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"buy,omitempty"`
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"FI,omitempty"`
			FR *struct {
				Buy *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"buy,omitempty"`
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"FR,omitempty"`
			GB *struct {
				Buy *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"buy,omitempty"`
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"GB,omitempty"`
			GF *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"GF,omitempty"`
			GH *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"GH,omitempty"`
			GQ *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"GQ,omitempty"`
			GT *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"GT,omitempty"`
			HK *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"HK,omitempty"`
			HN *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"HN,omitempty"`
			HR *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"HR,omitempty"`
			HU *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"HU,omitempty"`
			ID *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"ID,omitempty"`
			IE *struct {
				Buy *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"buy,omitempty"`
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"IE,omitempty"`
			IL *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"IL,omitempty"`
			IQ *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"IQ,omitempty"`
			IT *struct {
				Buy *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"buy,omitempty"`
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"IT,omitempty"`
			JM *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"JM,omitempty"`
			JP *struct {
				Buy *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"buy,omitempty"`
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
				Rent *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"rent,omitempty"`
			} `json:"JP,omitempty"`
			KE *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"KE,omitempty"`
			KR *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"KR,omitempty"`
			LB *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"LB,omitempty"`
			LT *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"LT,omitempty"`
			LY *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"LY,omitempty"`
			MD *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"MD,omitempty"`
			MK *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"MK,omitempty"`
			MU *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"MU,omitempty"`
			MX *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"MX,omitempty"`
			MY *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"MY,omitempty"`
			MZ *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"MZ,omitempty"`
			NE *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"NE,omitempty"`
			NG *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"NG,omitempty"`
			NL *struct {
				Buy *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"buy,omitempty"`
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"NL,omitempty"`
			NO *struct {
				Buy *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"buy,omitempty"`
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"NO,omitempty"`
			NZ *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"NZ,omitempty"`
			PA *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"PA,omitempty"`
			PE *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"PE,omitempty"`
			PH *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"PH,omitempty"`
			PL *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
				Rent *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"rent,omitempty"`
			} `json:"PL,omitempty"`
			PS *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"PS,omitempty"`
			PT *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"PT,omitempty"`
			PY *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"PY,omitempty"`
			RO *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"RO,omitempty"`
			RS *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"RS,omitempty"`
			RU *struct {
				Ads *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"ads,omitempty"`
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"RU,omitempty"`
			SA *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"SA,omitempty"`
			SC *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"SC,omitempty"`
			SE *struct {
				Buy *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"buy,omitempty"`
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"SE,omitempty"`
			SG *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"SG,omitempty"`
			SI *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"SI,omitempty"`
			SK *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"SK,omitempty"`
			SN *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"SN,omitempty"`
			SV *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"SV,omitempty"`
			TH *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"TH,omitempty"`
			TR *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"TR,omitempty"`
			TT *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"TT,omitempty"`
			TW *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"TW,omitempty"`
			TZ *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"TZ,omitempty"`
			UG *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"UG,omitempty"`
			US *struct {
				Buy *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"buy,omitempty"`
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Free *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"free,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"US,omitempty"`
			UY *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"UY,omitempty"`
			VE *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"VE,omitempty"`
			ZA *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"ZA,omitempty"`
			ZM *struct {
				Flatrate *[]struct {
					DisplayPriority *int    `json:"display_priority,omitempty"`
					LogoPath        *string `json:"logo_path,omitempty"`
					ProviderID      *int    `json:"provider_id,omitempty"`
					ProviderName    *string `json:"provider_name,omitempty"`
				} `json:"flatrate,omitempty"`
				Link *string `json:"link,omitempty"`
			} `json:"ZM,omitempty"`
		} `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r TvSeriesWatchProvidersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TvSeriesWatchProvidersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WatchProvidersMovieListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Results *[]struct {
			DisplayPriorities *struct {
				AE *int `json:"AE,omitempty"`
				AR *int `json:"AR,omitempty"`
				AT *int `json:"AT,omitempty"`
				AU *int `json:"AU,omitempty"`
				BE *int `json:"BE,omitempty"`
				BG *int `json:"BG,omitempty"`
				BO *int `json:"BO,omitempty"`
				BR *int `json:"BR,omitempty"`
				CA *int `json:"CA,omitempty"`
				CH *int `json:"CH,omitempty"`
				CL *int `json:"CL,omitempty"`
				CO *int `json:"CO,omitempty"`
				CR *int `json:"CR,omitempty"`
				CV *int `json:"CV,omitempty"`
				CZ *int `json:"CZ,omitempty"`
				DE *int `json:"DE,omitempty"`
				DK *int `json:"DK,omitempty"`
				EC *int `json:"EC,omitempty"`
				EE *int `json:"EE,omitempty"`
				EG *int `json:"EG,omitempty"`
				ES *int `json:"ES,omitempty"`
				FI *int `json:"FI,omitempty"`
				FR *int `json:"FR,omitempty"`
				GB *int `json:"GB,omitempty"`
				GH *int `json:"GH,omitempty"`
				GR *int `json:"GR,omitempty"`
				GT *int `json:"GT,omitempty"`
				HK *int `json:"HK,omitempty"`
				HN *int `json:"HN,omitempty"`
				HU *int `json:"HU,omitempty"`
				ID *int `json:"ID,omitempty"`
				IE *int `json:"IE,omitempty"`
				IL *int `json:"IL,omitempty"`
				IN *int `json:"IN,omitempty"`
				IT *int `json:"IT,omitempty"`
				JP *int `json:"JP,omitempty"`
				LT *int `json:"LT,omitempty"`
				LV *int `json:"LV,omitempty"`
				MU *int `json:"MU,omitempty"`
				MX *int `json:"MX,omitempty"`
				MY *int `json:"MY,omitempty"`
				MZ *int `json:"MZ,omitempty"`
				NL *int `json:"NL,omitempty"`
				NO *int `json:"NO,omitempty"`
				NZ *int `json:"NZ,omitempty"`
				PE *int `json:"PE,omitempty"`
				PH *int `json:"PH,omitempty"`
				PL *int `json:"PL,omitempty"`
				PT *int `json:"PT,omitempty"`
				PY *int `json:"PY,omitempty"`
				RU *int `json:"RU,omitempty"`
				SA *int `json:"SA,omitempty"`
				SE *int `json:"SE,omitempty"`
				SG *int `json:"SG,omitempty"`
				SI *int `json:"SI,omitempty"`
				SK *int `json:"SK,omitempty"`
				TH *int `json:"TH,omitempty"`
				TR *int `json:"TR,omitempty"`
				TW *int `json:"TW,omitempty"`
				UG *int `json:"UG,omitempty"`
				US *int `json:"US,omitempty"`
				VE *int `json:"VE,omitempty"`
				ZA *int `json:"ZA,omitempty"`
			} `json:"display_priorities,omitempty"`
			DisplayPriority *int    `json:"display_priority,omitempty"`
			LogoPath        *string `json:"logo_path,omitempty"`
			ProviderID      *int    `json:"provider_id,omitempty"`
			ProviderName    *string `json:"provider_name,omitempty"`
		} `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r WatchProvidersMovieListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WatchProvidersMovieListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WatchProvidersAvailableRegionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Results *[]struct {
			EnglishName *string `json:"english_name,omitempty"`
			Iso31661    *string `json:"iso_3166_1,omitempty"`
			NativeName  *string `json:"native_name,omitempty"`
		} `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r WatchProvidersAvailableRegionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WatchProvidersAvailableRegionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WatchProviderTvListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Results *[]struct {
			DisplayPriorities *struct {
				AE *int `json:"AE,omitempty"`
				AR *int `json:"AR,omitempty"`
				AT *int `json:"AT,omitempty"`
				AU *int `json:"AU,omitempty"`
				BE *int `json:"BE,omitempty"`
				BG *int `json:"BG,omitempty"`
				BO *int `json:"BO,omitempty"`
				BR *int `json:"BR,omitempty"`
				CA *int `json:"CA,omitempty"`
				CH *int `json:"CH,omitempty"`
				CL *int `json:"CL,omitempty"`
				CO *int `json:"CO,omitempty"`
				CR *int `json:"CR,omitempty"`
				CV *int `json:"CV,omitempty"`
				CZ *int `json:"CZ,omitempty"`
				DE *int `json:"DE,omitempty"`
				DK *int `json:"DK,omitempty"`
				EC *int `json:"EC,omitempty"`
				EE *int `json:"EE,omitempty"`
				EG *int `json:"EG,omitempty"`
				ES *int `json:"ES,omitempty"`
				FI *int `json:"FI,omitempty"`
				FR *int `json:"FR,omitempty"`
				GB *int `json:"GB,omitempty"`
				GH *int `json:"GH,omitempty"`
				GR *int `json:"GR,omitempty"`
				GT *int `json:"GT,omitempty"`
				HK *int `json:"HK,omitempty"`
				HN *int `json:"HN,omitempty"`
				HU *int `json:"HU,omitempty"`
				ID *int `json:"ID,omitempty"`
				IE *int `json:"IE,omitempty"`
				IL *int `json:"IL,omitempty"`
				IN *int `json:"IN,omitempty"`
				IT *int `json:"IT,omitempty"`
				JP *int `json:"JP,omitempty"`
				LT *int `json:"LT,omitempty"`
				LV *int `json:"LV,omitempty"`
				MU *int `json:"MU,omitempty"`
				MX *int `json:"MX,omitempty"`
				MY *int `json:"MY,omitempty"`
				MZ *int `json:"MZ,omitempty"`
				NL *int `json:"NL,omitempty"`
				NO *int `json:"NO,omitempty"`
				NZ *int `json:"NZ,omitempty"`
				PE *int `json:"PE,omitempty"`
				PH *int `json:"PH,omitempty"`
				PL *int `json:"PL,omitempty"`
				PT *int `json:"PT,omitempty"`
				PY *int `json:"PY,omitempty"`
				RU *int `json:"RU,omitempty"`
				SA *int `json:"SA,omitempty"`
				SE *int `json:"SE,omitempty"`
				SG *int `json:"SG,omitempty"`
				SI *int `json:"SI,omitempty"`
				SK *int `json:"SK,omitempty"`
				TH *int `json:"TH,omitempty"`
				TR *int `json:"TR,omitempty"`
				TW *int `json:"TW,omitempty"`
				UG *int `json:"UG,omitempty"`
				US *int `json:"US,omitempty"`
				VE *int `json:"VE,omitempty"`
				ZA *int `json:"ZA,omitempty"`
			} `json:"display_priorities,omitempty"`
			DisplayPriority *int    `json:"display_priority,omitempty"`
			LogoPath        *string `json:"logo_path,omitempty"`
			ProviderID      *int    `json:"provider_id,omitempty"`
			ProviderName    *string `json:"provider_name,omitempty"`
		} `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r WatchProviderTvListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WatchProviderTvListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// AccountDetailsWithResponse request returning *AccountDetailsResponse
func (c *ClientWithResponses) AccountDetailsWithResponse(ctx context.Context, accountID int32, params *AccountDetailsParams, reqEditors ...RequestEditorFn) (*AccountDetailsResponse, error) {
	rsp, err := c.AccountDetails(ctx, accountID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAccountDetailsResponse(rsp)
}

// AccountAddFavoriteWithBodyWithResponse request with arbitrary body returning *AccountAddFavoriteResponse
func (c *ClientWithResponses) AccountAddFavoriteWithBodyWithResponse(ctx context.Context, accountID int32, params *AccountAddFavoriteParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AccountAddFavoriteResponse, error) {
	rsp, err := c.AccountAddFavoriteWithBody(ctx, accountID, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAccountAddFavoriteResponse(rsp)
}

func (c *ClientWithResponses) AccountAddFavoriteWithResponse(ctx context.Context, accountID int32, params *AccountAddFavoriteParams, body AccountAddFavoriteJSONRequestBody, reqEditors ...RequestEditorFn) (*AccountAddFavoriteResponse, error) {
	rsp, err := c.AccountAddFavorite(ctx, accountID, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAccountAddFavoriteResponse(rsp)
}

// AccountGetFavoritesWithResponse request returning *AccountGetFavoritesResponse
func (c *ClientWithResponses) AccountGetFavoritesWithResponse(ctx context.Context, accountID int32, params *AccountGetFavoritesParams, reqEditors ...RequestEditorFn) (*AccountGetFavoritesResponse, error) {
	rsp, err := c.AccountGetFavorites(ctx, accountID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAccountGetFavoritesResponse(rsp)
}

// AccountFavoriteTvWithResponse request returning *AccountFavoriteTvResponse
func (c *ClientWithResponses) AccountFavoriteTvWithResponse(ctx context.Context, accountID int32, params *AccountFavoriteTvParams, reqEditors ...RequestEditorFn) (*AccountFavoriteTvResponse, error) {
	rsp, err := c.AccountFavoriteTv(ctx, accountID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAccountFavoriteTvResponse(rsp)
}

// AccountListsWithResponse request returning *AccountListsResponse
func (c *ClientWithResponses) AccountListsWithResponse(ctx context.Context, accountID int32, params *AccountListsParams, reqEditors ...RequestEditorFn) (*AccountListsResponse, error) {
	rsp, err := c.AccountLists(ctx, accountID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAccountListsResponse(rsp)
}

// AccountRatedMoviesWithResponse request returning *AccountRatedMoviesResponse
func (c *ClientWithResponses) AccountRatedMoviesWithResponse(ctx context.Context, accountID int32, params *AccountRatedMoviesParams, reqEditors ...RequestEditorFn) (*AccountRatedMoviesResponse, error) {
	rsp, err := c.AccountRatedMovies(ctx, accountID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAccountRatedMoviesResponse(rsp)
}

// AccountRatedTvWithResponse request returning *AccountRatedTvResponse
func (c *ClientWithResponses) AccountRatedTvWithResponse(ctx context.Context, accountID int32, params *AccountRatedTvParams, reqEditors ...RequestEditorFn) (*AccountRatedTvResponse, error) {
	rsp, err := c.AccountRatedTv(ctx, accountID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAccountRatedTvResponse(rsp)
}

// AccountRatedTvEpisodesWithResponse request returning *AccountRatedTvEpisodesResponse
func (c *ClientWithResponses) AccountRatedTvEpisodesWithResponse(ctx context.Context, accountID int32, params *AccountRatedTvEpisodesParams, reqEditors ...RequestEditorFn) (*AccountRatedTvEpisodesResponse, error) {
	rsp, err := c.AccountRatedTvEpisodes(ctx, accountID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAccountRatedTvEpisodesResponse(rsp)
}

// AccountAddToWatchlistWithBodyWithResponse request with arbitrary body returning *AccountAddToWatchlistResponse
func (c *ClientWithResponses) AccountAddToWatchlistWithBodyWithResponse(ctx context.Context, accountID int32, params *AccountAddToWatchlistParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AccountAddToWatchlistResponse, error) {
	rsp, err := c.AccountAddToWatchlistWithBody(ctx, accountID, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAccountAddToWatchlistResponse(rsp)
}

func (c *ClientWithResponses) AccountAddToWatchlistWithResponse(ctx context.Context, accountID int32, params *AccountAddToWatchlistParams, body AccountAddToWatchlistJSONRequestBody, reqEditors ...RequestEditorFn) (*AccountAddToWatchlistResponse, error) {
	rsp, err := c.AccountAddToWatchlist(ctx, accountID, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAccountAddToWatchlistResponse(rsp)
}

// AccountWatchlistMoviesWithResponse request returning *AccountWatchlistMoviesResponse
func (c *ClientWithResponses) AccountWatchlistMoviesWithResponse(ctx context.Context, accountID int32, params *AccountWatchlistMoviesParams, reqEditors ...RequestEditorFn) (*AccountWatchlistMoviesResponse, error) {
	rsp, err := c.AccountWatchlistMovies(ctx, accountID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAccountWatchlistMoviesResponse(rsp)
}

// AccountWatchlistTvWithResponse request returning *AccountWatchlistTvResponse
func (c *ClientWithResponses) AccountWatchlistTvWithResponse(ctx context.Context, accountID int32, params *AccountWatchlistTvParams, reqEditors ...RequestEditorFn) (*AccountWatchlistTvResponse, error) {
	rsp, err := c.AccountWatchlistTv(ctx, accountID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAccountWatchlistTvResponse(rsp)
}

// AuthenticationValidateKeyWithResponse request returning *AuthenticationValidateKeyResponse
func (c *ClientWithResponses) AuthenticationValidateKeyWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*AuthenticationValidateKeyResponse, error) {
	rsp, err := c.AuthenticationValidateKey(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthenticationValidateKeyResponse(rsp)
}

// AuthenticationCreateGuestSessionWithResponse request returning *AuthenticationCreateGuestSessionResponse
func (c *ClientWithResponses) AuthenticationCreateGuestSessionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*AuthenticationCreateGuestSessionResponse, error) {
	rsp, err := c.AuthenticationCreateGuestSession(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthenticationCreateGuestSessionResponse(rsp)
}

// AuthenticationDeleteSessionWithBodyWithResponse request with arbitrary body returning *AuthenticationDeleteSessionResponse
func (c *ClientWithResponses) AuthenticationDeleteSessionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthenticationDeleteSessionResponse, error) {
	rsp, err := c.AuthenticationDeleteSessionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthenticationDeleteSessionResponse(rsp)
}

func (c *ClientWithResponses) AuthenticationDeleteSessionWithResponse(ctx context.Context, body AuthenticationDeleteSessionJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthenticationDeleteSessionResponse, error) {
	rsp, err := c.AuthenticationDeleteSession(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthenticationDeleteSessionResponse(rsp)
}

// AuthenticationCreateSessionFromV4TokenWithBodyWithResponse request with arbitrary body returning *AuthenticationCreateSessionFromV4TokenResponse
func (c *ClientWithResponses) AuthenticationCreateSessionFromV4TokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthenticationCreateSessionFromV4TokenResponse, error) {
	rsp, err := c.AuthenticationCreateSessionFromV4TokenWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthenticationCreateSessionFromV4TokenResponse(rsp)
}

func (c *ClientWithResponses) AuthenticationCreateSessionFromV4TokenWithResponse(ctx context.Context, body AuthenticationCreateSessionFromV4TokenJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthenticationCreateSessionFromV4TokenResponse, error) {
	rsp, err := c.AuthenticationCreateSessionFromV4Token(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthenticationCreateSessionFromV4TokenResponse(rsp)
}

// AuthenticationCreateSessionWithBodyWithResponse request with arbitrary body returning *AuthenticationCreateSessionResponse
func (c *ClientWithResponses) AuthenticationCreateSessionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthenticationCreateSessionResponse, error) {
	rsp, err := c.AuthenticationCreateSessionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthenticationCreateSessionResponse(rsp)
}

func (c *ClientWithResponses) AuthenticationCreateSessionWithResponse(ctx context.Context, body AuthenticationCreateSessionJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthenticationCreateSessionResponse, error) {
	rsp, err := c.AuthenticationCreateSession(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthenticationCreateSessionResponse(rsp)
}

// AuthenticationCreateRequestTokenWithResponse request returning *AuthenticationCreateRequestTokenResponse
func (c *ClientWithResponses) AuthenticationCreateRequestTokenWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*AuthenticationCreateRequestTokenResponse, error) {
	rsp, err := c.AuthenticationCreateRequestToken(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthenticationCreateRequestTokenResponse(rsp)
}

// AuthenticationCreateSessionFromLoginWithBodyWithResponse request with arbitrary body returning *AuthenticationCreateSessionFromLoginResponse
func (c *ClientWithResponses) AuthenticationCreateSessionFromLoginWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthenticationCreateSessionFromLoginResponse, error) {
	rsp, err := c.AuthenticationCreateSessionFromLoginWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthenticationCreateSessionFromLoginResponse(rsp)
}

func (c *ClientWithResponses) AuthenticationCreateSessionFromLoginWithResponse(ctx context.Context, body AuthenticationCreateSessionFromLoginJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthenticationCreateSessionFromLoginResponse, error) {
	rsp, err := c.AuthenticationCreateSessionFromLogin(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthenticationCreateSessionFromLoginResponse(rsp)
}

// CertificationMovieListWithResponse request returning *CertificationMovieListResponse
func (c *ClientWithResponses) CertificationMovieListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CertificationMovieListResponse, error) {
	rsp, err := c.CertificationMovieList(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCertificationMovieListResponse(rsp)
}

// CertificationsTvListWithResponse request returning *CertificationsTvListResponse
func (c *ClientWithResponses) CertificationsTvListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CertificationsTvListResponse, error) {
	rsp, err := c.CertificationsTvList(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCertificationsTvListResponse(rsp)
}

// CollectionDetailsWithResponse request returning *CollectionDetailsResponse
func (c *ClientWithResponses) CollectionDetailsWithResponse(ctx context.Context, collectionID int32, params *CollectionDetailsParams, reqEditors ...RequestEditorFn) (*CollectionDetailsResponse, error) {
	rsp, err := c.CollectionDetails(ctx, collectionID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCollectionDetailsResponse(rsp)
}

// CollectionImagesWithResponse request returning *CollectionImagesResponse
func (c *ClientWithResponses) CollectionImagesWithResponse(ctx context.Context, collectionID int32, params *CollectionImagesParams, reqEditors ...RequestEditorFn) (*CollectionImagesResponse, error) {
	rsp, err := c.CollectionImages(ctx, collectionID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCollectionImagesResponse(rsp)
}

// CollectionTranslationsWithResponse request returning *CollectionTranslationsResponse
func (c *ClientWithResponses) CollectionTranslationsWithResponse(ctx context.Context, collectionID int32, reqEditors ...RequestEditorFn) (*CollectionTranslationsResponse, error) {
	rsp, err := c.CollectionTranslations(ctx, collectionID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCollectionTranslationsResponse(rsp)
}

// CompanyDetailsWithResponse request returning *CompanyDetailsResponse
func (c *ClientWithResponses) CompanyDetailsWithResponse(ctx context.Context, companyID int32, reqEditors ...RequestEditorFn) (*CompanyDetailsResponse, error) {
	rsp, err := c.CompanyDetails(ctx, companyID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCompanyDetailsResponse(rsp)
}

// CompanyAlternativeNamesWithResponse request returning *CompanyAlternativeNamesResponse
func (c *ClientWithResponses) CompanyAlternativeNamesWithResponse(ctx context.Context, companyID int32, reqEditors ...RequestEditorFn) (*CompanyAlternativeNamesResponse, error) {
	rsp, err := c.CompanyAlternativeNames(ctx, companyID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCompanyAlternativeNamesResponse(rsp)
}

// CompanyImagesWithResponse request returning *CompanyImagesResponse
func (c *ClientWithResponses) CompanyImagesWithResponse(ctx context.Context, companyID int32, reqEditors ...RequestEditorFn) (*CompanyImagesResponse, error) {
	rsp, err := c.CompanyImages(ctx, companyID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCompanyImagesResponse(rsp)
}

// ConfigurationDetailsWithResponse request returning *ConfigurationDetailsResponse
func (c *ClientWithResponses) ConfigurationDetailsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ConfigurationDetailsResponse, error) {
	rsp, err := c.ConfigurationDetails(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConfigurationDetailsResponse(rsp)
}

// ConfigurationCountriesWithResponse request returning *ConfigurationCountriesResponse
func (c *ClientWithResponses) ConfigurationCountriesWithResponse(ctx context.Context, params *ConfigurationCountriesParams, reqEditors ...RequestEditorFn) (*ConfigurationCountriesResponse, error) {
	rsp, err := c.ConfigurationCountries(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConfigurationCountriesResponse(rsp)
}

// ConfigurationJobsWithResponse request returning *ConfigurationJobsResponse
func (c *ClientWithResponses) ConfigurationJobsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ConfigurationJobsResponse, error) {
	rsp, err := c.ConfigurationJobs(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConfigurationJobsResponse(rsp)
}

// ConfigurationLanguagesWithResponse request returning *ConfigurationLanguagesResponse
func (c *ClientWithResponses) ConfigurationLanguagesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ConfigurationLanguagesResponse, error) {
	rsp, err := c.ConfigurationLanguages(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConfigurationLanguagesResponse(rsp)
}

// ConfigurationPrimaryTranslationsWithResponse request returning *ConfigurationPrimaryTranslationsResponse
func (c *ClientWithResponses) ConfigurationPrimaryTranslationsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ConfigurationPrimaryTranslationsResponse, error) {
	rsp, err := c.ConfigurationPrimaryTranslations(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConfigurationPrimaryTranslationsResponse(rsp)
}

// ConfigurationTimezonesWithResponse request returning *ConfigurationTimezonesResponse
func (c *ClientWithResponses) ConfigurationTimezonesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ConfigurationTimezonesResponse, error) {
	rsp, err := c.ConfigurationTimezones(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConfigurationTimezonesResponse(rsp)
}

// CreditDetailsWithResponse request returning *CreditDetailsResponse
func (c *ClientWithResponses) CreditDetailsWithResponse(ctx context.Context, creditID string, reqEditors ...RequestEditorFn) (*CreditDetailsResponse, error) {
	rsp, err := c.CreditDetails(ctx, creditID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreditDetailsResponse(rsp)
}

// DiscoverMovieWithResponse request returning *DiscoverMovieResponse
func (c *ClientWithResponses) DiscoverMovieWithResponse(ctx context.Context, params *DiscoverMovieParams, reqEditors ...RequestEditorFn) (*DiscoverMovieResponse, error) {
	rsp, err := c.DiscoverMovie(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDiscoverMovieResponse(rsp)
}

// DiscoverTvWithResponse request returning *DiscoverTvResponse
func (c *ClientWithResponses) DiscoverTvWithResponse(ctx context.Context, params *DiscoverTvParams, reqEditors ...RequestEditorFn) (*DiscoverTvResponse, error) {
	rsp, err := c.DiscoverTv(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDiscoverTvResponse(rsp)
}

// FindByIDWithResponse request returning *FindByIDResponse
func (c *ClientWithResponses) FindByIDWithResponse(ctx context.Context, externalID string, params *FindByIDParams, reqEditors ...RequestEditorFn) (*FindByIDResponse, error) {
	rsp, err := c.FindByID(ctx, externalID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindByIDResponse(rsp)
}

// GenreMovieListWithResponse request returning *GenreMovieListResponse
func (c *ClientWithResponses) GenreMovieListWithResponse(ctx context.Context, params *GenreMovieListParams, reqEditors ...RequestEditorFn) (*GenreMovieListResponse, error) {
	rsp, err := c.GenreMovieList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenreMovieListResponse(rsp)
}

// GenreTvListWithResponse request returning *GenreTvListResponse
func (c *ClientWithResponses) GenreTvListWithResponse(ctx context.Context, params *GenreTvListParams, reqEditors ...RequestEditorFn) (*GenreTvListResponse, error) {
	rsp, err := c.GenreTvList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenreTvListResponse(rsp)
}

// GuestSessionRatedMoviesWithResponse request returning *GuestSessionRatedMoviesResponse
func (c *ClientWithResponses) GuestSessionRatedMoviesWithResponse(ctx context.Context, guestSessionID string, params *GuestSessionRatedMoviesParams, reqEditors ...RequestEditorFn) (*GuestSessionRatedMoviesResponse, error) {
	rsp, err := c.GuestSessionRatedMovies(ctx, guestSessionID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGuestSessionRatedMoviesResponse(rsp)
}

// GuestSessionRatedTvWithResponse request returning *GuestSessionRatedTvResponse
func (c *ClientWithResponses) GuestSessionRatedTvWithResponse(ctx context.Context, guestSessionID string, params *GuestSessionRatedTvParams, reqEditors ...RequestEditorFn) (*GuestSessionRatedTvResponse, error) {
	rsp, err := c.GuestSessionRatedTv(ctx, guestSessionID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGuestSessionRatedTvResponse(rsp)
}

// GuestSessionRatedTvEpisodesWithResponse request returning *GuestSessionRatedTvEpisodesResponse
func (c *ClientWithResponses) GuestSessionRatedTvEpisodesWithResponse(ctx context.Context, guestSessionID string, params *GuestSessionRatedTvEpisodesParams, reqEditors ...RequestEditorFn) (*GuestSessionRatedTvEpisodesResponse, error) {
	rsp, err := c.GuestSessionRatedTvEpisodes(ctx, guestSessionID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGuestSessionRatedTvEpisodesResponse(rsp)
}

// KeywordDetailsWithResponse request returning *KeywordDetailsResponse
func (c *ClientWithResponses) KeywordDetailsWithResponse(ctx context.Context, keywordID int32, reqEditors ...RequestEditorFn) (*KeywordDetailsResponse, error) {
	rsp, err := c.KeywordDetails(ctx, keywordID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseKeywordDetailsResponse(rsp)
}

// KeywordMoviesWithResponse request returning *KeywordMoviesResponse
func (c *ClientWithResponses) KeywordMoviesWithResponse(ctx context.Context, keywordID string, params *KeywordMoviesParams, reqEditors ...RequestEditorFn) (*KeywordMoviesResponse, error) {
	rsp, err := c.KeywordMovies(ctx, keywordID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseKeywordMoviesResponse(rsp)
}

// ListCreateWithBodyWithResponse request with arbitrary body returning *ListCreateResponse
func (c *ClientWithResponses) ListCreateWithBodyWithResponse(ctx context.Context, params *ListCreateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListCreateResponse, error) {
	rsp, err := c.ListCreateWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListCreateResponse(rsp)
}

func (c *ClientWithResponses) ListCreateWithResponse(ctx context.Context, params *ListCreateParams, body ListCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ListCreateResponse, error) {
	rsp, err := c.ListCreate(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListCreateResponse(rsp)
}

// ListDeleteWithResponse request returning *ListDeleteResponse
func (c *ClientWithResponses) ListDeleteWithResponse(ctx context.Context, listID int32, params *ListDeleteParams, reqEditors ...RequestEditorFn) (*ListDeleteResponse, error) {
	rsp, err := c.ListDelete(ctx, listID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListDeleteResponse(rsp)
}

// ListDetailsWithResponse request returning *ListDetailsResponse
func (c *ClientWithResponses) ListDetailsWithResponse(ctx context.Context, listID int32, params *ListDetailsParams, reqEditors ...RequestEditorFn) (*ListDetailsResponse, error) {
	rsp, err := c.ListDetails(ctx, listID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListDetailsResponse(rsp)
}

// ListAddMovieWithBodyWithResponse request with arbitrary body returning *ListAddMovieResponse
func (c *ClientWithResponses) ListAddMovieWithBodyWithResponse(ctx context.Context, listID int32, params *ListAddMovieParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListAddMovieResponse, error) {
	rsp, err := c.ListAddMovieWithBody(ctx, listID, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAddMovieResponse(rsp)
}

func (c *ClientWithResponses) ListAddMovieWithResponse(ctx context.Context, listID int32, params *ListAddMovieParams, body ListAddMovieJSONRequestBody, reqEditors ...RequestEditorFn) (*ListAddMovieResponse, error) {
	rsp, err := c.ListAddMovie(ctx, listID, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAddMovieResponse(rsp)
}

// ListClearWithResponse request returning *ListClearResponse
func (c *ClientWithResponses) ListClearWithResponse(ctx context.Context, listID int32, params *ListClearParams, reqEditors ...RequestEditorFn) (*ListClearResponse, error) {
	rsp, err := c.ListClear(ctx, listID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListClearResponse(rsp)
}

// ListCheckItemStatusWithResponse request returning *ListCheckItemStatusResponse
func (c *ClientWithResponses) ListCheckItemStatusWithResponse(ctx context.Context, listID int32, params *ListCheckItemStatusParams, reqEditors ...RequestEditorFn) (*ListCheckItemStatusResponse, error) {
	rsp, err := c.ListCheckItemStatus(ctx, listID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListCheckItemStatusResponse(rsp)
}

// ListRemoveMovieWithBodyWithResponse request with arbitrary body returning *ListRemoveMovieResponse
func (c *ClientWithResponses) ListRemoveMovieWithBodyWithResponse(ctx context.Context, listID int32, params *ListRemoveMovieParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListRemoveMovieResponse, error) {
	rsp, err := c.ListRemoveMovieWithBody(ctx, listID, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListRemoveMovieResponse(rsp)
}

func (c *ClientWithResponses) ListRemoveMovieWithResponse(ctx context.Context, listID int32, params *ListRemoveMovieParams, body ListRemoveMovieJSONRequestBody, reqEditors ...RequestEditorFn) (*ListRemoveMovieResponse, error) {
	rsp, err := c.ListRemoveMovie(ctx, listID, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListRemoveMovieResponse(rsp)
}

// ChangesMovieListWithResponse request returning *ChangesMovieListResponse
func (c *ClientWithResponses) ChangesMovieListWithResponse(ctx context.Context, params *ChangesMovieListParams, reqEditors ...RequestEditorFn) (*ChangesMovieListResponse, error) {
	rsp, err := c.ChangesMovieList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseChangesMovieListResponse(rsp)
}

// MovieLatestIDWithResponse request returning *MovieLatestIDResponse
func (c *ClientWithResponses) MovieLatestIDWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*MovieLatestIDResponse, error) {
	rsp, err := c.MovieLatestID(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMovieLatestIDResponse(rsp)
}

// MovieNowPlayingListWithResponse request returning *MovieNowPlayingListResponse
func (c *ClientWithResponses) MovieNowPlayingListWithResponse(ctx context.Context, params *MovieNowPlayingListParams, reqEditors ...RequestEditorFn) (*MovieNowPlayingListResponse, error) {
	rsp, err := c.MovieNowPlayingList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMovieNowPlayingListResponse(rsp)
}

// MoviePopularListWithResponse request returning *MoviePopularListResponse
func (c *ClientWithResponses) MoviePopularListWithResponse(ctx context.Context, params *MoviePopularListParams, reqEditors ...RequestEditorFn) (*MoviePopularListResponse, error) {
	rsp, err := c.MoviePopularList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMoviePopularListResponse(rsp)
}

// MovieTopRatedListWithResponse request returning *MovieTopRatedListResponse
func (c *ClientWithResponses) MovieTopRatedListWithResponse(ctx context.Context, params *MovieTopRatedListParams, reqEditors ...RequestEditorFn) (*MovieTopRatedListResponse, error) {
	rsp, err := c.MovieTopRatedList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMovieTopRatedListResponse(rsp)
}

// MovieUpcomingListWithResponse request returning *MovieUpcomingListResponse
func (c *ClientWithResponses) MovieUpcomingListWithResponse(ctx context.Context, params *MovieUpcomingListParams, reqEditors ...RequestEditorFn) (*MovieUpcomingListResponse, error) {
	rsp, err := c.MovieUpcomingList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMovieUpcomingListResponse(rsp)
}

// MovieDetailsWithResponse request returning *MovieDetailsResponse
func (c *ClientWithResponses) MovieDetailsWithResponse(ctx context.Context, movieID int32, params *MovieDetailsParams, reqEditors ...RequestEditorFn) (*MovieDetailsResponse, error) {
	rsp, err := c.MovieDetails(ctx, movieID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMovieDetailsResponse(rsp)
}

// MovieAccountStatesWithResponse request returning *MovieAccountStatesResponse
func (c *ClientWithResponses) MovieAccountStatesWithResponse(ctx context.Context, movieID int32, params *MovieAccountStatesParams, reqEditors ...RequestEditorFn) (*MovieAccountStatesResponse, error) {
	rsp, err := c.MovieAccountStates(ctx, movieID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMovieAccountStatesResponse(rsp)
}

// MovieAlternativeTitlesWithResponse request returning *MovieAlternativeTitlesResponse
func (c *ClientWithResponses) MovieAlternativeTitlesWithResponse(ctx context.Context, movieID int32, params *MovieAlternativeTitlesParams, reqEditors ...RequestEditorFn) (*MovieAlternativeTitlesResponse, error) {
	rsp, err := c.MovieAlternativeTitles(ctx, movieID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMovieAlternativeTitlesResponse(rsp)
}

// MovieChangesWithResponse request returning *MovieChangesResponse
func (c *ClientWithResponses) MovieChangesWithResponse(ctx context.Context, movieID int32, params *MovieChangesParams, reqEditors ...RequestEditorFn) (*MovieChangesResponse, error) {
	rsp, err := c.MovieChanges(ctx, movieID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMovieChangesResponse(rsp)
}

// MovieCreditsWithResponse request returning *MovieCreditsResponse
func (c *ClientWithResponses) MovieCreditsWithResponse(ctx context.Context, movieID int32, params *MovieCreditsParams, reqEditors ...RequestEditorFn) (*MovieCreditsResponse, error) {
	rsp, err := c.MovieCredits(ctx, movieID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMovieCreditsResponse(rsp)
}

// MovieExternalIdsWithResponse request returning *MovieExternalIdsResponse
func (c *ClientWithResponses) MovieExternalIdsWithResponse(ctx context.Context, movieID int32, reqEditors ...RequestEditorFn) (*MovieExternalIdsResponse, error) {
	rsp, err := c.MovieExternalIds(ctx, movieID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMovieExternalIdsResponse(rsp)
}

// MovieImagesWithResponse request returning *MovieImagesResponse
func (c *ClientWithResponses) MovieImagesWithResponse(ctx context.Context, movieID int32, params *MovieImagesParams, reqEditors ...RequestEditorFn) (*MovieImagesResponse, error) {
	rsp, err := c.MovieImages(ctx, movieID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMovieImagesResponse(rsp)
}

// MovieKeywordsWithResponse request returning *MovieKeywordsResponse
func (c *ClientWithResponses) MovieKeywordsWithResponse(ctx context.Context, movieID string, reqEditors ...RequestEditorFn) (*MovieKeywordsResponse, error) {
	rsp, err := c.MovieKeywords(ctx, movieID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMovieKeywordsResponse(rsp)
}

// MovieListsWithResponse request returning *MovieListsResponse
func (c *ClientWithResponses) MovieListsWithResponse(ctx context.Context, movieID int32, params *MovieListsParams, reqEditors ...RequestEditorFn) (*MovieListsResponse, error) {
	rsp, err := c.MovieLists(ctx, movieID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMovieListsResponse(rsp)
}

// MovieDeleteRatingWithResponse request returning *MovieDeleteRatingResponse
func (c *ClientWithResponses) MovieDeleteRatingWithResponse(ctx context.Context, movieID int32, params *MovieDeleteRatingParams, reqEditors ...RequestEditorFn) (*MovieDeleteRatingResponse, error) {
	rsp, err := c.MovieDeleteRating(ctx, movieID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMovieDeleteRatingResponse(rsp)
}

// MovieAddRatingWithBodyWithResponse request with arbitrary body returning *MovieAddRatingResponse
func (c *ClientWithResponses) MovieAddRatingWithBodyWithResponse(ctx context.Context, movieID int32, params *MovieAddRatingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MovieAddRatingResponse, error) {
	rsp, err := c.MovieAddRatingWithBody(ctx, movieID, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMovieAddRatingResponse(rsp)
}

func (c *ClientWithResponses) MovieAddRatingWithResponse(ctx context.Context, movieID int32, params *MovieAddRatingParams, body MovieAddRatingJSONRequestBody, reqEditors ...RequestEditorFn) (*MovieAddRatingResponse, error) {
	rsp, err := c.MovieAddRating(ctx, movieID, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMovieAddRatingResponse(rsp)
}

// MovieRecommendationsWithResponse request returning *MovieRecommendationsResponse
func (c *ClientWithResponses) MovieRecommendationsWithResponse(ctx context.Context, movieID int32, params *MovieRecommendationsParams, reqEditors ...RequestEditorFn) (*MovieRecommendationsResponse, error) {
	rsp, err := c.MovieRecommendations(ctx, movieID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMovieRecommendationsResponse(rsp)
}

// MovieReleaseDatesWithResponse request returning *MovieReleaseDatesResponse
func (c *ClientWithResponses) MovieReleaseDatesWithResponse(ctx context.Context, movieID int32, reqEditors ...RequestEditorFn) (*MovieReleaseDatesResponse, error) {
	rsp, err := c.MovieReleaseDates(ctx, movieID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMovieReleaseDatesResponse(rsp)
}

// MovieReviewsWithResponse request returning *MovieReviewsResponse
func (c *ClientWithResponses) MovieReviewsWithResponse(ctx context.Context, movieID int32, params *MovieReviewsParams, reqEditors ...RequestEditorFn) (*MovieReviewsResponse, error) {
	rsp, err := c.MovieReviews(ctx, movieID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMovieReviewsResponse(rsp)
}

// MovieSimilarWithResponse request returning *MovieSimilarResponse
func (c *ClientWithResponses) MovieSimilarWithResponse(ctx context.Context, movieID int32, params *MovieSimilarParams, reqEditors ...RequestEditorFn) (*MovieSimilarResponse, error) {
	rsp, err := c.MovieSimilar(ctx, movieID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMovieSimilarResponse(rsp)
}

// MovieTranslationsWithResponse request returning *MovieTranslationsResponse
func (c *ClientWithResponses) MovieTranslationsWithResponse(ctx context.Context, movieID int32, reqEditors ...RequestEditorFn) (*MovieTranslationsResponse, error) {
	rsp, err := c.MovieTranslations(ctx, movieID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMovieTranslationsResponse(rsp)
}

// MovieVideosWithResponse request returning *MovieVideosResponse
func (c *ClientWithResponses) MovieVideosWithResponse(ctx context.Context, movieID int32, params *MovieVideosParams, reqEditors ...RequestEditorFn) (*MovieVideosResponse, error) {
	rsp, err := c.MovieVideos(ctx, movieID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMovieVideosResponse(rsp)
}

// MovieWatchProvidersWithResponse request returning *MovieWatchProvidersResponse
func (c *ClientWithResponses) MovieWatchProvidersWithResponse(ctx context.Context, movieID int32, reqEditors ...RequestEditorFn) (*MovieWatchProvidersResponse, error) {
	rsp, err := c.MovieWatchProviders(ctx, movieID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMovieWatchProvidersResponse(rsp)
}

// NetworkDetailsWithResponse request returning *NetworkDetailsResponse
func (c *ClientWithResponses) NetworkDetailsWithResponse(ctx context.Context, networkID int32, reqEditors ...RequestEditorFn) (*NetworkDetailsResponse, error) {
	rsp, err := c.NetworkDetails(ctx, networkID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNetworkDetailsResponse(rsp)
}

// DetailsCopyWithResponse request returning *DetailsCopyResponse
func (c *ClientWithResponses) DetailsCopyWithResponse(ctx context.Context, networkID int32, reqEditors ...RequestEditorFn) (*DetailsCopyResponse, error) {
	rsp, err := c.DetailsCopy(ctx, networkID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDetailsCopyResponse(rsp)
}

// AlternativeNamesCopyWithResponse request returning *AlternativeNamesCopyResponse
func (c *ClientWithResponses) AlternativeNamesCopyWithResponse(ctx context.Context, networkID int32, reqEditors ...RequestEditorFn) (*AlternativeNamesCopyResponse, error) {
	rsp, err := c.AlternativeNamesCopy(ctx, networkID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAlternativeNamesCopyResponse(rsp)
}

// ChangesPeopleListWithResponse request returning *ChangesPeopleListResponse
func (c *ClientWithResponses) ChangesPeopleListWithResponse(ctx context.Context, params *ChangesPeopleListParams, reqEditors ...RequestEditorFn) (*ChangesPeopleListResponse, error) {
	rsp, err := c.ChangesPeopleList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseChangesPeopleListResponse(rsp)
}

// PersonLatestIDWithResponse request returning *PersonLatestIDResponse
func (c *ClientWithResponses) PersonLatestIDWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PersonLatestIDResponse, error) {
	rsp, err := c.PersonLatestID(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersonLatestIDResponse(rsp)
}

// PersonPopularListWithResponse request returning *PersonPopularListResponse
func (c *ClientWithResponses) PersonPopularListWithResponse(ctx context.Context, params *PersonPopularListParams, reqEditors ...RequestEditorFn) (*PersonPopularListResponse, error) {
	rsp, err := c.PersonPopularList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersonPopularListResponse(rsp)
}

// PersonDetailsWithResponse request returning *PersonDetailsResponse
func (c *ClientWithResponses) PersonDetailsWithResponse(ctx context.Context, personID int32, params *PersonDetailsParams, reqEditors ...RequestEditorFn) (*PersonDetailsResponse, error) {
	rsp, err := c.PersonDetails(ctx, personID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersonDetailsResponse(rsp)
}

// PersonChangesWithResponse request returning *PersonChangesResponse
func (c *ClientWithResponses) PersonChangesWithResponse(ctx context.Context, personID int32, params *PersonChangesParams, reqEditors ...RequestEditorFn) (*PersonChangesResponse, error) {
	rsp, err := c.PersonChanges(ctx, personID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersonChangesResponse(rsp)
}

// PersonCombinedCreditsWithResponse request returning *PersonCombinedCreditsResponse
func (c *ClientWithResponses) PersonCombinedCreditsWithResponse(ctx context.Context, personID string, params *PersonCombinedCreditsParams, reqEditors ...RequestEditorFn) (*PersonCombinedCreditsResponse, error) {
	rsp, err := c.PersonCombinedCredits(ctx, personID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersonCombinedCreditsResponse(rsp)
}

// PersonExternalIdsWithResponse request returning *PersonExternalIdsResponse
func (c *ClientWithResponses) PersonExternalIdsWithResponse(ctx context.Context, personID int32, reqEditors ...RequestEditorFn) (*PersonExternalIdsResponse, error) {
	rsp, err := c.PersonExternalIds(ctx, personID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersonExternalIdsResponse(rsp)
}

// PersonImagesWithResponse request returning *PersonImagesResponse
func (c *ClientWithResponses) PersonImagesWithResponse(ctx context.Context, personID int32, reqEditors ...RequestEditorFn) (*PersonImagesResponse, error) {
	rsp, err := c.PersonImages(ctx, personID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersonImagesResponse(rsp)
}

// PersonMovieCreditsWithResponse request returning *PersonMovieCreditsResponse
func (c *ClientWithResponses) PersonMovieCreditsWithResponse(ctx context.Context, personID int32, params *PersonMovieCreditsParams, reqEditors ...RequestEditorFn) (*PersonMovieCreditsResponse, error) {
	rsp, err := c.PersonMovieCredits(ctx, personID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersonMovieCreditsResponse(rsp)
}

// PersonTaggedImagesWithResponse request returning *PersonTaggedImagesResponse
func (c *ClientWithResponses) PersonTaggedImagesWithResponse(ctx context.Context, personID int32, params *PersonTaggedImagesParams, reqEditors ...RequestEditorFn) (*PersonTaggedImagesResponse, error) {
	rsp, err := c.PersonTaggedImages(ctx, personID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersonTaggedImagesResponse(rsp)
}

// TranslationsWithResponse request returning *TranslationsResponse
func (c *ClientWithResponses) TranslationsWithResponse(ctx context.Context, personID int32, reqEditors ...RequestEditorFn) (*TranslationsResponse, error) {
	rsp, err := c.Translations(ctx, personID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTranslationsResponse(rsp)
}

// PersonTvCreditsWithResponse request returning *PersonTvCreditsResponse
func (c *ClientWithResponses) PersonTvCreditsWithResponse(ctx context.Context, personID int32, params *PersonTvCreditsParams, reqEditors ...RequestEditorFn) (*PersonTvCreditsResponse, error) {
	rsp, err := c.PersonTvCredits(ctx, personID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersonTvCreditsResponse(rsp)
}

// ReviewDetailsWithResponse request returning *ReviewDetailsResponse
func (c *ClientWithResponses) ReviewDetailsWithResponse(ctx context.Context, reviewID string, reqEditors ...RequestEditorFn) (*ReviewDetailsResponse, error) {
	rsp, err := c.ReviewDetails(ctx, reviewID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReviewDetailsResponse(rsp)
}

// SearchCollectionWithResponse request returning *SearchCollectionResponse
func (c *ClientWithResponses) SearchCollectionWithResponse(ctx context.Context, params *SearchCollectionParams, reqEditors ...RequestEditorFn) (*SearchCollectionResponse, error) {
	rsp, err := c.SearchCollection(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchCollectionResponse(rsp)
}

// SearchCompanyWithResponse request returning *SearchCompanyResponse
func (c *ClientWithResponses) SearchCompanyWithResponse(ctx context.Context, params *SearchCompanyParams, reqEditors ...RequestEditorFn) (*SearchCompanyResponse, error) {
	rsp, err := c.SearchCompany(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchCompanyResponse(rsp)
}

// SearchKeywordWithResponse request returning *SearchKeywordResponse
func (c *ClientWithResponses) SearchKeywordWithResponse(ctx context.Context, params *SearchKeywordParams, reqEditors ...RequestEditorFn) (*SearchKeywordResponse, error) {
	rsp, err := c.SearchKeyword(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchKeywordResponse(rsp)
}

// SearchMovieWithResponse request returning *SearchMovieResponse
func (c *ClientWithResponses) SearchMovieWithResponse(ctx context.Context, params *SearchMovieParams, reqEditors ...RequestEditorFn) (*SearchMovieResponse, error) {
	rsp, err := c.SearchMovie(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchMovieResponse(rsp)
}

// SearchMultiWithResponse request returning *SearchMultiResponse
func (c *ClientWithResponses) SearchMultiWithResponse(ctx context.Context, params *SearchMultiParams, reqEditors ...RequestEditorFn) (*SearchMultiResponse, error) {
	rsp, err := c.SearchMulti(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchMultiResponse(rsp)
}

// SearchPersonWithResponse request returning *SearchPersonResponse
func (c *ClientWithResponses) SearchPersonWithResponse(ctx context.Context, params *SearchPersonParams, reqEditors ...RequestEditorFn) (*SearchPersonResponse, error) {
	rsp, err := c.SearchPerson(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchPersonResponse(rsp)
}

// SearchTvWithResponse request returning *SearchTvResponse
func (c *ClientWithResponses) SearchTvWithResponse(ctx context.Context, params *SearchTvParams, reqEditors ...RequestEditorFn) (*SearchTvResponse, error) {
	rsp, err := c.SearchTv(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchTvResponse(rsp)
}

// TrendingAllWithResponse request returning *TrendingAllResponse
func (c *ClientWithResponses) TrendingAllWithResponse(ctx context.Context, timeWindow TrendingAllParamsTimeWindow, params *TrendingAllParams, reqEditors ...RequestEditorFn) (*TrendingAllResponse, error) {
	rsp, err := c.TrendingAll(ctx, timeWindow, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTrendingAllResponse(rsp)
}

// TrendingMoviesWithResponse request returning *TrendingMoviesResponse
func (c *ClientWithResponses) TrendingMoviesWithResponse(ctx context.Context, timeWindow TrendingMoviesParamsTimeWindow, params *TrendingMoviesParams, reqEditors ...RequestEditorFn) (*TrendingMoviesResponse, error) {
	rsp, err := c.TrendingMovies(ctx, timeWindow, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTrendingMoviesResponse(rsp)
}

// TrendingPeopleWithResponse request returning *TrendingPeopleResponse
func (c *ClientWithResponses) TrendingPeopleWithResponse(ctx context.Context, timeWindow TrendingPeopleParamsTimeWindow, params *TrendingPeopleParams, reqEditors ...RequestEditorFn) (*TrendingPeopleResponse, error) {
	rsp, err := c.TrendingPeople(ctx, timeWindow, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTrendingPeopleResponse(rsp)
}

// TrendingTvWithResponse request returning *TrendingTvResponse
func (c *ClientWithResponses) TrendingTvWithResponse(ctx context.Context, timeWindow TrendingTvParamsTimeWindow, params *TrendingTvParams, reqEditors ...RequestEditorFn) (*TrendingTvResponse, error) {
	rsp, err := c.TrendingTv(ctx, timeWindow, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTrendingTvResponse(rsp)
}

// TvSeriesAiringTodayListWithResponse request returning *TvSeriesAiringTodayListResponse
func (c *ClientWithResponses) TvSeriesAiringTodayListWithResponse(ctx context.Context, params *TvSeriesAiringTodayListParams, reqEditors ...RequestEditorFn) (*TvSeriesAiringTodayListResponse, error) {
	rsp, err := c.TvSeriesAiringTodayList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTvSeriesAiringTodayListResponse(rsp)
}

// ChangesTvListWithResponse request returning *ChangesTvListResponse
func (c *ClientWithResponses) ChangesTvListWithResponse(ctx context.Context, params *ChangesTvListParams, reqEditors ...RequestEditorFn) (*ChangesTvListResponse, error) {
	rsp, err := c.ChangesTvList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseChangesTvListResponse(rsp)
}

// TvEpisodeChangesByIDWithResponse request returning *TvEpisodeChangesByIDResponse
func (c *ClientWithResponses) TvEpisodeChangesByIDWithResponse(ctx context.Context, episodeID int32, reqEditors ...RequestEditorFn) (*TvEpisodeChangesByIDResponse, error) {
	rsp, err := c.TvEpisodeChangesByID(ctx, episodeID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTvEpisodeChangesByIDResponse(rsp)
}

// TvEpisodeGroupDetailsWithResponse request returning *TvEpisodeGroupDetailsResponse
func (c *ClientWithResponses) TvEpisodeGroupDetailsWithResponse(ctx context.Context, tvEpisodeGroupID string, reqEditors ...RequestEditorFn) (*TvEpisodeGroupDetailsResponse, error) {
	rsp, err := c.TvEpisodeGroupDetails(ctx, tvEpisodeGroupID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTvEpisodeGroupDetailsResponse(rsp)
}

// TvSeriesLatestIDWithResponse request returning *TvSeriesLatestIDResponse
func (c *ClientWithResponses) TvSeriesLatestIDWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*TvSeriesLatestIDResponse, error) {
	rsp, err := c.TvSeriesLatestID(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTvSeriesLatestIDResponse(rsp)
}

// TvSeriesOnTheAirListWithResponse request returning *TvSeriesOnTheAirListResponse
func (c *ClientWithResponses) TvSeriesOnTheAirListWithResponse(ctx context.Context, params *TvSeriesOnTheAirListParams, reqEditors ...RequestEditorFn) (*TvSeriesOnTheAirListResponse, error) {
	rsp, err := c.TvSeriesOnTheAirList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTvSeriesOnTheAirListResponse(rsp)
}

// TvSeriesPopularListWithResponse request returning *TvSeriesPopularListResponse
func (c *ClientWithResponses) TvSeriesPopularListWithResponse(ctx context.Context, params *TvSeriesPopularListParams, reqEditors ...RequestEditorFn) (*TvSeriesPopularListResponse, error) {
	rsp, err := c.TvSeriesPopularList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTvSeriesPopularListResponse(rsp)
}

// TvSeasonChangesByIDWithResponse request returning *TvSeasonChangesByIDResponse
func (c *ClientWithResponses) TvSeasonChangesByIDWithResponse(ctx context.Context, seasonID int32, params *TvSeasonChangesByIDParams, reqEditors ...RequestEditorFn) (*TvSeasonChangesByIDResponse, error) {
	rsp, err := c.TvSeasonChangesByID(ctx, seasonID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTvSeasonChangesByIDResponse(rsp)
}

// TvSeriesTopRatedListWithResponse request returning *TvSeriesTopRatedListResponse
func (c *ClientWithResponses) TvSeriesTopRatedListWithResponse(ctx context.Context, params *TvSeriesTopRatedListParams, reqEditors ...RequestEditorFn) (*TvSeriesTopRatedListResponse, error) {
	rsp, err := c.TvSeriesTopRatedList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTvSeriesTopRatedListResponse(rsp)
}

// TvSeriesDetailsWithResponse request returning *TvSeriesDetailsResponse
func (c *ClientWithResponses) TvSeriesDetailsWithResponse(ctx context.Context, seriesID int32, params *TvSeriesDetailsParams, reqEditors ...RequestEditorFn) (*TvSeriesDetailsResponse, error) {
	rsp, err := c.TvSeriesDetails(ctx, seriesID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTvSeriesDetailsResponse(rsp)
}

// TvSeriesAccountStatesWithResponse request returning *TvSeriesAccountStatesResponse
func (c *ClientWithResponses) TvSeriesAccountStatesWithResponse(ctx context.Context, seriesID int32, params *TvSeriesAccountStatesParams, reqEditors ...RequestEditorFn) (*TvSeriesAccountStatesResponse, error) {
	rsp, err := c.TvSeriesAccountStates(ctx, seriesID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTvSeriesAccountStatesResponse(rsp)
}

// TvSeriesAggregateCreditsWithResponse request returning *TvSeriesAggregateCreditsResponse
func (c *ClientWithResponses) TvSeriesAggregateCreditsWithResponse(ctx context.Context, seriesID int32, params *TvSeriesAggregateCreditsParams, reqEditors ...RequestEditorFn) (*TvSeriesAggregateCreditsResponse, error) {
	rsp, err := c.TvSeriesAggregateCredits(ctx, seriesID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTvSeriesAggregateCreditsResponse(rsp)
}

// TvSeriesAlternativeTitlesWithResponse request returning *TvSeriesAlternativeTitlesResponse
func (c *ClientWithResponses) TvSeriesAlternativeTitlesWithResponse(ctx context.Context, seriesID int32, reqEditors ...RequestEditorFn) (*TvSeriesAlternativeTitlesResponse, error) {
	rsp, err := c.TvSeriesAlternativeTitles(ctx, seriesID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTvSeriesAlternativeTitlesResponse(rsp)
}

// TvSeriesChangesWithResponse request returning *TvSeriesChangesResponse
func (c *ClientWithResponses) TvSeriesChangesWithResponse(ctx context.Context, seriesID int32, params *TvSeriesChangesParams, reqEditors ...RequestEditorFn) (*TvSeriesChangesResponse, error) {
	rsp, err := c.TvSeriesChanges(ctx, seriesID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTvSeriesChangesResponse(rsp)
}

// TvSeriesContentRatingsWithResponse request returning *TvSeriesContentRatingsResponse
func (c *ClientWithResponses) TvSeriesContentRatingsWithResponse(ctx context.Context, seriesID int32, reqEditors ...RequestEditorFn) (*TvSeriesContentRatingsResponse, error) {
	rsp, err := c.TvSeriesContentRatings(ctx, seriesID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTvSeriesContentRatingsResponse(rsp)
}

// TvSeriesCreditsWithResponse request returning *TvSeriesCreditsResponse
func (c *ClientWithResponses) TvSeriesCreditsWithResponse(ctx context.Context, seriesID int32, params *TvSeriesCreditsParams, reqEditors ...RequestEditorFn) (*TvSeriesCreditsResponse, error) {
	rsp, err := c.TvSeriesCredits(ctx, seriesID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTvSeriesCreditsResponse(rsp)
}

// TvSeriesEpisodeGroupsWithResponse request returning *TvSeriesEpisodeGroupsResponse
func (c *ClientWithResponses) TvSeriesEpisodeGroupsWithResponse(ctx context.Context, seriesID int32, reqEditors ...RequestEditorFn) (*TvSeriesEpisodeGroupsResponse, error) {
	rsp, err := c.TvSeriesEpisodeGroups(ctx, seriesID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTvSeriesEpisodeGroupsResponse(rsp)
}

// TvSeriesExternalIdsWithResponse request returning *TvSeriesExternalIdsResponse
func (c *ClientWithResponses) TvSeriesExternalIdsWithResponse(ctx context.Context, seriesID int32, reqEditors ...RequestEditorFn) (*TvSeriesExternalIdsResponse, error) {
	rsp, err := c.TvSeriesExternalIds(ctx, seriesID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTvSeriesExternalIdsResponse(rsp)
}

// TvSeriesImagesWithResponse request returning *TvSeriesImagesResponse
func (c *ClientWithResponses) TvSeriesImagesWithResponse(ctx context.Context, seriesID int32, params *TvSeriesImagesParams, reqEditors ...RequestEditorFn) (*TvSeriesImagesResponse, error) {
	rsp, err := c.TvSeriesImages(ctx, seriesID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTvSeriesImagesResponse(rsp)
}

// TvSeriesKeywordsWithResponse request returning *TvSeriesKeywordsResponse
func (c *ClientWithResponses) TvSeriesKeywordsWithResponse(ctx context.Context, seriesID int32, reqEditors ...RequestEditorFn) (*TvSeriesKeywordsResponse, error) {
	rsp, err := c.TvSeriesKeywords(ctx, seriesID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTvSeriesKeywordsResponse(rsp)
}

// ListsCopyWithResponse request returning *ListsCopyResponse
func (c *ClientWithResponses) ListsCopyWithResponse(ctx context.Context, seriesID int32, params *ListsCopyParams, reqEditors ...RequestEditorFn) (*ListsCopyResponse, error) {
	rsp, err := c.ListsCopy(ctx, seriesID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListsCopyResponse(rsp)
}

// TvSeriesDeleteRatingWithResponse request returning *TvSeriesDeleteRatingResponse
func (c *ClientWithResponses) TvSeriesDeleteRatingWithResponse(ctx context.Context, seriesID int32, params *TvSeriesDeleteRatingParams, reqEditors ...RequestEditorFn) (*TvSeriesDeleteRatingResponse, error) {
	rsp, err := c.TvSeriesDeleteRating(ctx, seriesID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTvSeriesDeleteRatingResponse(rsp)
}

// TvSeriesAddRatingWithBodyWithResponse request with arbitrary body returning *TvSeriesAddRatingResponse
func (c *ClientWithResponses) TvSeriesAddRatingWithBodyWithResponse(ctx context.Context, seriesID int32, params *TvSeriesAddRatingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TvSeriesAddRatingResponse, error) {
	rsp, err := c.TvSeriesAddRatingWithBody(ctx, seriesID, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTvSeriesAddRatingResponse(rsp)
}

func (c *ClientWithResponses) TvSeriesAddRatingWithResponse(ctx context.Context, seriesID int32, params *TvSeriesAddRatingParams, body TvSeriesAddRatingJSONRequestBody, reqEditors ...RequestEditorFn) (*TvSeriesAddRatingResponse, error) {
	rsp, err := c.TvSeriesAddRating(ctx, seriesID, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTvSeriesAddRatingResponse(rsp)
}

// TvSeriesRecommendationsWithResponse request returning *TvSeriesRecommendationsResponse
func (c *ClientWithResponses) TvSeriesRecommendationsWithResponse(ctx context.Context, seriesID int32, params *TvSeriesRecommendationsParams, reqEditors ...RequestEditorFn) (*TvSeriesRecommendationsResponse, error) {
	rsp, err := c.TvSeriesRecommendations(ctx, seriesID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTvSeriesRecommendationsResponse(rsp)
}

// TvSeriesReviewsWithResponse request returning *TvSeriesReviewsResponse
func (c *ClientWithResponses) TvSeriesReviewsWithResponse(ctx context.Context, seriesID int32, params *TvSeriesReviewsParams, reqEditors ...RequestEditorFn) (*TvSeriesReviewsResponse, error) {
	rsp, err := c.TvSeriesReviews(ctx, seriesID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTvSeriesReviewsResponse(rsp)
}

// TvSeriesScreenedTheatricallyWithResponse request returning *TvSeriesScreenedTheatricallyResponse
func (c *ClientWithResponses) TvSeriesScreenedTheatricallyWithResponse(ctx context.Context, seriesID int32, reqEditors ...RequestEditorFn) (*TvSeriesScreenedTheatricallyResponse, error) {
	rsp, err := c.TvSeriesScreenedTheatrically(ctx, seriesID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTvSeriesScreenedTheatricallyResponse(rsp)
}

// TvSeasonDetailsWithResponse request returning *TvSeasonDetailsResponse
func (c *ClientWithResponses) TvSeasonDetailsWithResponse(ctx context.Context, seriesID int32, seasonNumber int32, params *TvSeasonDetailsParams, reqEditors ...RequestEditorFn) (*TvSeasonDetailsResponse, error) {
	rsp, err := c.TvSeasonDetails(ctx, seriesID, seasonNumber, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTvSeasonDetailsResponse(rsp)
}

// TvSeasonAccountStatesWithResponse request returning *TvSeasonAccountStatesResponse
func (c *ClientWithResponses) TvSeasonAccountStatesWithResponse(ctx context.Context, seriesID int32, seasonNumber int32, params *TvSeasonAccountStatesParams, reqEditors ...RequestEditorFn) (*TvSeasonAccountStatesResponse, error) {
	rsp, err := c.TvSeasonAccountStates(ctx, seriesID, seasonNumber, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTvSeasonAccountStatesResponse(rsp)
}

// TvSeasonAggregateCreditsWithResponse request returning *TvSeasonAggregateCreditsResponse
func (c *ClientWithResponses) TvSeasonAggregateCreditsWithResponse(ctx context.Context, seriesID int32, seasonNumber int32, params *TvSeasonAggregateCreditsParams, reqEditors ...RequestEditorFn) (*TvSeasonAggregateCreditsResponse, error) {
	rsp, err := c.TvSeasonAggregateCredits(ctx, seriesID, seasonNumber, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTvSeasonAggregateCreditsResponse(rsp)
}

// TvSeasonCreditsWithResponse request returning *TvSeasonCreditsResponse
func (c *ClientWithResponses) TvSeasonCreditsWithResponse(ctx context.Context, seriesID int32, seasonNumber int32, params *TvSeasonCreditsParams, reqEditors ...RequestEditorFn) (*TvSeasonCreditsResponse, error) {
	rsp, err := c.TvSeasonCredits(ctx, seriesID, seasonNumber, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTvSeasonCreditsResponse(rsp)
}

// TvEpisodeDetailsWithResponse request returning *TvEpisodeDetailsResponse
func (c *ClientWithResponses) TvEpisodeDetailsWithResponse(ctx context.Context, seriesID int32, seasonNumber int32, episodeNumber int32, params *TvEpisodeDetailsParams, reqEditors ...RequestEditorFn) (*TvEpisodeDetailsResponse, error) {
	rsp, err := c.TvEpisodeDetails(ctx, seriesID, seasonNumber, episodeNumber, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTvEpisodeDetailsResponse(rsp)
}

// TvEpisodeAccountStatesWithResponse request returning *TvEpisodeAccountStatesResponse
func (c *ClientWithResponses) TvEpisodeAccountStatesWithResponse(ctx context.Context, seriesID int32, seasonNumber int32, episodeNumber int32, params *TvEpisodeAccountStatesParams, reqEditors ...RequestEditorFn) (*TvEpisodeAccountStatesResponse, error) {
	rsp, err := c.TvEpisodeAccountStates(ctx, seriesID, seasonNumber, episodeNumber, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTvEpisodeAccountStatesResponse(rsp)
}

// TvEpisodeCreditsWithResponse request returning *TvEpisodeCreditsResponse
func (c *ClientWithResponses) TvEpisodeCreditsWithResponse(ctx context.Context, seriesID int32, seasonNumber int32, episodeNumber int32, params *TvEpisodeCreditsParams, reqEditors ...RequestEditorFn) (*TvEpisodeCreditsResponse, error) {
	rsp, err := c.TvEpisodeCredits(ctx, seriesID, seasonNumber, episodeNumber, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTvEpisodeCreditsResponse(rsp)
}

// TvEpisodeExternalIdsWithResponse request returning *TvEpisodeExternalIdsResponse
func (c *ClientWithResponses) TvEpisodeExternalIdsWithResponse(ctx context.Context, seriesID int32, seasonNumber int32, episodeNumber string, reqEditors ...RequestEditorFn) (*TvEpisodeExternalIdsResponse, error) {
	rsp, err := c.TvEpisodeExternalIds(ctx, seriesID, seasonNumber, episodeNumber, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTvEpisodeExternalIdsResponse(rsp)
}

// TvEpisodeImagesWithResponse request returning *TvEpisodeImagesResponse
func (c *ClientWithResponses) TvEpisodeImagesWithResponse(ctx context.Context, seriesID int32, seasonNumber int32, episodeNumber int32, params *TvEpisodeImagesParams, reqEditors ...RequestEditorFn) (*TvEpisodeImagesResponse, error) {
	rsp, err := c.TvEpisodeImages(ctx, seriesID, seasonNumber, episodeNumber, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTvEpisodeImagesResponse(rsp)
}

// TvEpisodeDeleteRatingWithResponse request returning *TvEpisodeDeleteRatingResponse
func (c *ClientWithResponses) TvEpisodeDeleteRatingWithResponse(ctx context.Context, seriesID int32, seasonNumber int32, episodeNumber int32, params *TvEpisodeDeleteRatingParams, reqEditors ...RequestEditorFn) (*TvEpisodeDeleteRatingResponse, error) {
	rsp, err := c.TvEpisodeDeleteRating(ctx, seriesID, seasonNumber, episodeNumber, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTvEpisodeDeleteRatingResponse(rsp)
}

// TvEpisodeAddRatingWithBodyWithResponse request with arbitrary body returning *TvEpisodeAddRatingResponse
func (c *ClientWithResponses) TvEpisodeAddRatingWithBodyWithResponse(ctx context.Context, seriesID int32, seasonNumber int32, episodeNumber int32, params *TvEpisodeAddRatingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TvEpisodeAddRatingResponse, error) {
	rsp, err := c.TvEpisodeAddRatingWithBody(ctx, seriesID, seasonNumber, episodeNumber, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTvEpisodeAddRatingResponse(rsp)
}

func (c *ClientWithResponses) TvEpisodeAddRatingWithResponse(ctx context.Context, seriesID int32, seasonNumber int32, episodeNumber int32, params *TvEpisodeAddRatingParams, body TvEpisodeAddRatingJSONRequestBody, reqEditors ...RequestEditorFn) (*TvEpisodeAddRatingResponse, error) {
	rsp, err := c.TvEpisodeAddRating(ctx, seriesID, seasonNumber, episodeNumber, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTvEpisodeAddRatingResponse(rsp)
}

// TvEpisodeTranslationsWithResponse request returning *TvEpisodeTranslationsResponse
func (c *ClientWithResponses) TvEpisodeTranslationsWithResponse(ctx context.Context, seriesID int32, seasonNumber int32, episodeNumber int32, reqEditors ...RequestEditorFn) (*TvEpisodeTranslationsResponse, error) {
	rsp, err := c.TvEpisodeTranslations(ctx, seriesID, seasonNumber, episodeNumber, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTvEpisodeTranslationsResponse(rsp)
}

// TvEpisodeVideosWithResponse request returning *TvEpisodeVideosResponse
func (c *ClientWithResponses) TvEpisodeVideosWithResponse(ctx context.Context, seriesID int32, seasonNumber int32, episodeNumber int32, params *TvEpisodeVideosParams, reqEditors ...RequestEditorFn) (*TvEpisodeVideosResponse, error) {
	rsp, err := c.TvEpisodeVideos(ctx, seriesID, seasonNumber, episodeNumber, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTvEpisodeVideosResponse(rsp)
}

// TvSeasonExternalIdsWithResponse request returning *TvSeasonExternalIdsResponse
func (c *ClientWithResponses) TvSeasonExternalIdsWithResponse(ctx context.Context, seriesID int32, seasonNumber int32, reqEditors ...RequestEditorFn) (*TvSeasonExternalIdsResponse, error) {
	rsp, err := c.TvSeasonExternalIds(ctx, seriesID, seasonNumber, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTvSeasonExternalIdsResponse(rsp)
}

// TvSeasonImagesWithResponse request returning *TvSeasonImagesResponse
func (c *ClientWithResponses) TvSeasonImagesWithResponse(ctx context.Context, seriesID int32, seasonNumber int32, params *TvSeasonImagesParams, reqEditors ...RequestEditorFn) (*TvSeasonImagesResponse, error) {
	rsp, err := c.TvSeasonImages(ctx, seriesID, seasonNumber, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTvSeasonImagesResponse(rsp)
}

// TvSeasonTranslationsWithResponse request returning *TvSeasonTranslationsResponse
func (c *ClientWithResponses) TvSeasonTranslationsWithResponse(ctx context.Context, seriesID int32, seasonNumber int32, reqEditors ...RequestEditorFn) (*TvSeasonTranslationsResponse, error) {
	rsp, err := c.TvSeasonTranslations(ctx, seriesID, seasonNumber, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTvSeasonTranslationsResponse(rsp)
}

// TvSeasonVideosWithResponse request returning *TvSeasonVideosResponse
func (c *ClientWithResponses) TvSeasonVideosWithResponse(ctx context.Context, seriesID int32, seasonNumber int32, params *TvSeasonVideosParams, reqEditors ...RequestEditorFn) (*TvSeasonVideosResponse, error) {
	rsp, err := c.TvSeasonVideos(ctx, seriesID, seasonNumber, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTvSeasonVideosResponse(rsp)
}

// TvSeasonWatchProvidersWithResponse request returning *TvSeasonWatchProvidersResponse
func (c *ClientWithResponses) TvSeasonWatchProvidersWithResponse(ctx context.Context, seriesID int32, seasonNumber int32, params *TvSeasonWatchProvidersParams, reqEditors ...RequestEditorFn) (*TvSeasonWatchProvidersResponse, error) {
	rsp, err := c.TvSeasonWatchProviders(ctx, seriesID, seasonNumber, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTvSeasonWatchProvidersResponse(rsp)
}

// TvSeriesSimilarWithResponse request returning *TvSeriesSimilarResponse
func (c *ClientWithResponses) TvSeriesSimilarWithResponse(ctx context.Context, seriesID string, params *TvSeriesSimilarParams, reqEditors ...RequestEditorFn) (*TvSeriesSimilarResponse, error) {
	rsp, err := c.TvSeriesSimilar(ctx, seriesID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTvSeriesSimilarResponse(rsp)
}

// TvSeriesTranslationsWithResponse request returning *TvSeriesTranslationsResponse
func (c *ClientWithResponses) TvSeriesTranslationsWithResponse(ctx context.Context, seriesID int32, reqEditors ...RequestEditorFn) (*TvSeriesTranslationsResponse, error) {
	rsp, err := c.TvSeriesTranslations(ctx, seriesID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTvSeriesTranslationsResponse(rsp)
}

// TvSeriesVideosWithResponse request returning *TvSeriesVideosResponse
func (c *ClientWithResponses) TvSeriesVideosWithResponse(ctx context.Context, seriesID int32, params *TvSeriesVideosParams, reqEditors ...RequestEditorFn) (*TvSeriesVideosResponse, error) {
	rsp, err := c.TvSeriesVideos(ctx, seriesID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTvSeriesVideosResponse(rsp)
}

// TvSeriesWatchProvidersWithResponse request returning *TvSeriesWatchProvidersResponse
func (c *ClientWithResponses) TvSeriesWatchProvidersWithResponse(ctx context.Context, seriesID int32, reqEditors ...RequestEditorFn) (*TvSeriesWatchProvidersResponse, error) {
	rsp, err := c.TvSeriesWatchProviders(ctx, seriesID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTvSeriesWatchProvidersResponse(rsp)
}

// WatchProvidersMovieListWithResponse request returning *WatchProvidersMovieListResponse
func (c *ClientWithResponses) WatchProvidersMovieListWithResponse(ctx context.Context, params *WatchProvidersMovieListParams, reqEditors ...RequestEditorFn) (*WatchProvidersMovieListResponse, error) {
	rsp, err := c.WatchProvidersMovieList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWatchProvidersMovieListResponse(rsp)
}

// WatchProvidersAvailableRegionsWithResponse request returning *WatchProvidersAvailableRegionsResponse
func (c *ClientWithResponses) WatchProvidersAvailableRegionsWithResponse(ctx context.Context, params *WatchProvidersAvailableRegionsParams, reqEditors ...RequestEditorFn) (*WatchProvidersAvailableRegionsResponse, error) {
	rsp, err := c.WatchProvidersAvailableRegions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWatchProvidersAvailableRegionsResponse(rsp)
}

// WatchProviderTvListWithResponse request returning *WatchProviderTvListResponse
func (c *ClientWithResponses) WatchProviderTvListWithResponse(ctx context.Context, params *WatchProviderTvListParams, reqEditors ...RequestEditorFn) (*WatchProviderTvListResponse, error) {
	rsp, err := c.WatchProviderTvList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWatchProviderTvListResponse(rsp)
}

// ParseAccountDetailsResponse parses an HTTP response from a AccountDetailsWithResponse call
func ParseAccountDetailsResponse(rsp *http.Response) (*AccountDetailsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AccountDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Avatar *struct {
				Gravatar *struct {
					Hash *string `json:"hash,omitempty"`
				} `json:"gravatar,omitempty"`
				Tmdb *struct {
					AvatarPath *string `json:"avatar_path,omitempty"`
				} `json:"tmdb,omitempty"`
			} `json:"avatar,omitempty"`
			ID           *int    `json:"id,omitempty"`
			IncludeAdult *bool   `json:"include_adult,omitempty"`
			Iso31661     *string `json:"iso_3166_1,omitempty"`
			Iso6391      *string `json:"iso_639_1,omitempty"`
			Name         *string `json:"name,omitempty"`
			Username     *string `json:"username,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAccountAddFavoriteResponse parses an HTTP response from a AccountAddFavoriteWithResponse call
func ParseAccountAddFavoriteResponse(rsp *http.Response) (*AccountAddFavoriteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AccountAddFavoriteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			StatusCode    *int    `json:"status_code,omitempty"`
			StatusMessage *string `json:"status_message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAccountGetFavoritesResponse parses an HTTP response from a AccountGetFavoritesWithResponse call
func ParseAccountGetFavoritesResponse(rsp *http.Response) (*AccountGetFavoritesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AccountGetFavoritesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Page    *int `json:"page,omitempty"`
			Results *[]struct {
				Adult            *bool    `json:"adult,omitempty"`
				BackdropPath     *string  `json:"backdrop_path,omitempty"`
				GenreIds         *[]int   `json:"genre_ids,omitempty"`
				ID               *int     `json:"id,omitempty"`
				OriginalLanguage *string  `json:"original_language,omitempty"`
				OriginalTitle    *string  `json:"original_title,omitempty"`
				Overview         *string  `json:"overview,omitempty"`
				Popularity       *float32 `json:"popularity,omitempty"`
				PosterPath       *string  `json:"poster_path,omitempty"`
				ReleaseDate      *string  `json:"release_date,omitempty"`
				Title            *string  `json:"title,omitempty"`
				Video            *bool    `json:"video,omitempty"`
				VoteAverage      *float32 `json:"vote_average,omitempty"`
				VoteCount        *int     `json:"vote_count,omitempty"`
			} `json:"results,omitempty"`
			TotalPages   *int `json:"total_pages,omitempty"`
			TotalResults *int `json:"total_results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAccountFavoriteTvResponse parses an HTTP response from a AccountFavoriteTvWithResponse call
func ParseAccountFavoriteTvResponse(rsp *http.Response) (*AccountFavoriteTvResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AccountFavoriteTvResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Page    *int `json:"page,omitempty"`
			Results *[]struct {
				Adult            *bool     `json:"adult,omitempty"`
				BackdropPath     *string   `json:"backdrop_path,omitempty"`
				FirstAirDate     *string   `json:"first_air_date,omitempty"`
				GenreIds         *[]int    `json:"genre_ids,omitempty"`
				ID               *int      `json:"id,omitempty"`
				Name             *string   `json:"name,omitempty"`
				OriginCountry    *[]string `json:"origin_country,omitempty"`
				OriginalLanguage *string   `json:"original_language,omitempty"`
				OriginalName     *string   `json:"original_name,omitempty"`
				Overview         *string   `json:"overview,omitempty"`
				Popularity       *float32  `json:"popularity,omitempty"`
				PosterPath       *string   `json:"poster_path,omitempty"`
				VoteAverage      *float32  `json:"vote_average,omitempty"`
				VoteCount        *int      `json:"vote_count,omitempty"`
			} `json:"results,omitempty"`
			TotalPages   *int `json:"total_pages,omitempty"`
			TotalResults *int `json:"total_results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAccountListsResponse parses an HTTP response from a AccountListsWithResponse call
func ParseAccountListsResponse(rsp *http.Response) (*AccountListsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AccountListsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Page    *int `json:"page,omitempty"`
			Results *[]struct {
				Description   *string      `json:"description,omitempty"`
				FavoriteCount *int         `json:"favorite_count,omitempty"`
				ID            *int         `json:"id,omitempty"`
				Iso6391       *string      `json:"iso_639_1,omitempty"`
				ItemCount     *int         `json:"item_count,omitempty"`
				ListType      *string      `json:"list_type,omitempty"`
				Name          *string      `json:"name,omitempty"`
				PosterPath    *interface{} `json:"poster_path,omitempty"`
			} `json:"results,omitempty"`
			TotalPages   *int `json:"total_pages,omitempty"`
			TotalResults *int `json:"total_results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAccountRatedMoviesResponse parses an HTTP response from a AccountRatedMoviesWithResponse call
func ParseAccountRatedMoviesResponse(rsp *http.Response) (*AccountRatedMoviesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AccountRatedMoviesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Page    *int `json:"page,omitempty"`
			Results *[]struct {
				Adult            *bool    `json:"adult,omitempty"`
				BackdropPath     *string  `json:"backdrop_path,omitempty"`
				GenreIds         *[]int   `json:"genre_ids,omitempty"`
				ID               *int     `json:"id,omitempty"`
				OriginalLanguage *string  `json:"original_language,omitempty"`
				OriginalTitle    *string  `json:"original_title,omitempty"`
				Overview         *string  `json:"overview,omitempty"`
				Popularity       *float32 `json:"popularity,omitempty"`
				PosterPath       *string  `json:"poster_path,omitempty"`
				Rating           *int     `json:"rating,omitempty"`
				ReleaseDate      *string  `json:"release_date,omitempty"`
				Title            *string  `json:"title,omitempty"`
				Video            *bool    `json:"video,omitempty"`
				VoteAverage      *float32 `json:"vote_average,omitempty"`
				VoteCount        *int     `json:"vote_count,omitempty"`
			} `json:"results,omitempty"`
			TotalPages   *int `json:"total_pages,omitempty"`
			TotalResults *int `json:"total_results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAccountRatedTvResponse parses an HTTP response from a AccountRatedTvWithResponse call
func ParseAccountRatedTvResponse(rsp *http.Response) (*AccountRatedTvResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AccountRatedTvResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Page    *int `json:"page,omitempty"`
			Results *[]struct {
				Adult            *bool     `json:"adult,omitempty"`
				BackdropPath     *string   `json:"backdrop_path,omitempty"`
				FirstAirDate     *string   `json:"first_air_date,omitempty"`
				GenreIds         *[]int    `json:"genre_ids,omitempty"`
				ID               *int      `json:"id,omitempty"`
				Name             *string   `json:"name,omitempty"`
				OriginCountry    *[]string `json:"origin_country,omitempty"`
				OriginalLanguage *string   `json:"original_language,omitempty"`
				OriginalName     *string   `json:"original_name,omitempty"`
				Overview         *string   `json:"overview,omitempty"`
				Popularity       *float32  `json:"popularity,omitempty"`
				PosterPath       *string   `json:"poster_path,omitempty"`
				Rating           *int      `json:"rating,omitempty"`
				VoteAverage      *float32  `json:"vote_average,omitempty"`
				VoteCount        *int      `json:"vote_count,omitempty"`
			} `json:"results,omitempty"`
			TotalPages   *int `json:"total_pages,omitempty"`
			TotalResults *int `json:"total_results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAccountRatedTvEpisodesResponse parses an HTTP response from a AccountRatedTvEpisodesWithResponse call
func ParseAccountRatedTvEpisodesResponse(rsp *http.Response) (*AccountRatedTvEpisodesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AccountRatedTvEpisodesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Page    *int `json:"page,omitempty"`
			Results *[]struct {
				AirDate        *string  `json:"air_date,omitempty"`
				EpisodeNumber  *int     `json:"episode_number,omitempty"`
				ID             *int     `json:"id,omitempty"`
				Name           *string  `json:"name,omitempty"`
				Overview       *string  `json:"overview,omitempty"`
				ProductionCode *string  `json:"production_code,omitempty"`
				Rating         *int     `json:"rating,omitempty"`
				Runtime        *int     `json:"runtime,omitempty"`
				SeasonNumber   *int     `json:"season_number,omitempty"`
				ShowID         *int     `json:"show_id,omitempty"`
				StillPath      *string  `json:"still_path,omitempty"`
				VoteAverage    *float32 `json:"vote_average,omitempty"`
				VoteCount      *int     `json:"vote_count,omitempty"`
			} `json:"results,omitempty"`
			TotalPages   *int `json:"total_pages,omitempty"`
			TotalResults *int `json:"total_results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAccountAddToWatchlistResponse parses an HTTP response from a AccountAddToWatchlistWithResponse call
func ParseAccountAddToWatchlistResponse(rsp *http.Response) (*AccountAddToWatchlistResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AccountAddToWatchlistResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			StatusCode    *int    `json:"status_code,omitempty"`
			StatusMessage *string `json:"status_message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAccountWatchlistMoviesResponse parses an HTTP response from a AccountWatchlistMoviesWithResponse call
func ParseAccountWatchlistMoviesResponse(rsp *http.Response) (*AccountWatchlistMoviesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AccountWatchlistMoviesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Page    *int `json:"page,omitempty"`
			Results *[]struct {
				Adult            *bool    `json:"adult,omitempty"`
				BackdropPath     *string  `json:"backdrop_path,omitempty"`
				GenreIds         *[]int   `json:"genre_ids,omitempty"`
				ID               *int     `json:"id,omitempty"`
				OriginalLanguage *string  `json:"original_language,omitempty"`
				OriginalTitle    *string  `json:"original_title,omitempty"`
				Overview         *string  `json:"overview,omitempty"`
				Popularity       *float32 `json:"popularity,omitempty"`
				PosterPath       *string  `json:"poster_path,omitempty"`
				ReleaseDate      *string  `json:"release_date,omitempty"`
				Title            *string  `json:"title,omitempty"`
				Video            *bool    `json:"video,omitempty"`
				VoteAverage      *float32 `json:"vote_average,omitempty"`
				VoteCount        *int     `json:"vote_count,omitempty"`
			} `json:"results,omitempty"`
			TotalPages   *int `json:"total_pages,omitempty"`
			TotalResults *int `json:"total_results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAccountWatchlistTvResponse parses an HTTP response from a AccountWatchlistTvWithResponse call
func ParseAccountWatchlistTvResponse(rsp *http.Response) (*AccountWatchlistTvResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AccountWatchlistTvResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Page    *int `json:"page,omitempty"`
			Results *[]struct {
				Adult            *bool     `json:"adult,omitempty"`
				BackdropPath     *string   `json:"backdrop_path,omitempty"`
				FirstAirDate     *string   `json:"first_air_date,omitempty"`
				GenreIds         *[]int    `json:"genre_ids,omitempty"`
				ID               *int      `json:"id,omitempty"`
				Name             *string   `json:"name,omitempty"`
				OriginCountry    *[]string `json:"origin_country,omitempty"`
				OriginalLanguage *string   `json:"original_language,omitempty"`
				OriginalName     *string   `json:"original_name,omitempty"`
				Overview         *string   `json:"overview,omitempty"`
				Popularity       *float32  `json:"popularity,omitempty"`
				PosterPath       *string   `json:"poster_path,omitempty"`
				VoteAverage      *float32  `json:"vote_average,omitempty"`
				VoteCount        *int      `json:"vote_count,omitempty"`
			} `json:"results,omitempty"`
			TotalPages   *int `json:"total_pages,omitempty"`
			TotalResults *int `json:"total_results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAuthenticationValidateKeyResponse parses an HTTP response from a AuthenticationValidateKeyWithResponse call
func ParseAuthenticationValidateKeyResponse(rsp *http.Response) (*AuthenticationValidateKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AuthenticationValidateKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			StatusCode    *int    `json:"status_code,omitempty"`
			StatusMessage *string `json:"status_message,omitempty"`
			Success       *bool   `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			StatusCode    *int    `json:"status_code,omitempty"`
			StatusMessage *string `json:"status_message,omitempty"`
			Success       *bool   `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseAuthenticationCreateGuestSessionResponse parses an HTTP response from a AuthenticationCreateGuestSessionWithResponse call
func ParseAuthenticationCreateGuestSessionResponse(rsp *http.Response) (*AuthenticationCreateGuestSessionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AuthenticationCreateGuestSessionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			ExpiresAt      *string `json:"expires_at,omitempty"`
			GuestSessionID *string `json:"guest_session_id,omitempty"`
			Success        *bool   `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAuthenticationDeleteSessionResponse parses an HTTP response from a AuthenticationDeleteSessionWithResponse call
func ParseAuthenticationDeleteSessionResponse(rsp *http.Response) (*AuthenticationDeleteSessionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AuthenticationDeleteSessionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAuthenticationCreateSessionFromV4TokenResponse parses an HTTP response from a AuthenticationCreateSessionFromV4TokenWithResponse call
func ParseAuthenticationCreateSessionFromV4TokenResponse(rsp *http.Response) (*AuthenticationCreateSessionFromV4TokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AuthenticationCreateSessionFromV4TokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			SessionID *string `json:"session_id,omitempty"`
			Success   *bool   `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAuthenticationCreateSessionResponse parses an HTTP response from a AuthenticationCreateSessionWithResponse call
func ParseAuthenticationCreateSessionResponse(rsp *http.Response) (*AuthenticationCreateSessionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AuthenticationCreateSessionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			SessionID *string `json:"session_id,omitempty"`
			Success   *bool   `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAuthenticationCreateRequestTokenResponse parses an HTTP response from a AuthenticationCreateRequestTokenWithResponse call
func ParseAuthenticationCreateRequestTokenResponse(rsp *http.Response) (*AuthenticationCreateRequestTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AuthenticationCreateRequestTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			ExpiresAt    *string `json:"expires_at,omitempty"`
			RequestToken *string `json:"request_token,omitempty"`
			Success      *bool   `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAuthenticationCreateSessionFromLoginResponse parses an HTTP response from a AuthenticationCreateSessionFromLoginWithResponse call
func ParseAuthenticationCreateSessionFromLoginResponse(rsp *http.Response) (*AuthenticationCreateSessionFromLoginResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AuthenticationCreateSessionFromLoginResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			ExpiresAt    *string `json:"expires_at,omitempty"`
			RequestToken *string `json:"request_token,omitempty"`
			Success      *bool   `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCertificationMovieListResponse parses an HTTP response from a CertificationMovieListWithResponse call
func ParseCertificationMovieListResponse(rsp *http.Response) (*CertificationMovieListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CertificationMovieListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Certifications *struct {
				AR *[]struct {
					Certification *string `json:"certification,omitempty"`
					Meaning       *string `json:"meaning,omitempty"`
					Order         *int    `json:"order,omitempty"`
				} `json:"AR,omitempty"`
				AU *[]struct {
					Certification *string `json:"certification,omitempty"`
					Meaning       *string `json:"meaning,omitempty"`
					Order         *int    `json:"order,omitempty"`
				} `json:"AU,omitempty"`
				BG *[]struct {
					Certification *string `json:"certification,omitempty"`
					Meaning       *string `json:"meaning,omitempty"`
					Order         *int    `json:"order,omitempty"`
				} `json:"BG,omitempty"`
				BR *[]struct {
					Certification *string `json:"certification,omitempty"`
					Meaning       *string `json:"meaning,omitempty"`
					Order         *int    `json:"order,omitempty"`
				} `json:"BR,omitempty"`
				CA *[]struct {
					Certification *string `json:"certification,omitempty"`
					Meaning       *string `json:"meaning,omitempty"`
					Order         *int    `json:"order,omitempty"`
				} `json:"CA,omitempty"`
				CAQC *[]struct {
					Certification *string `json:"certification,omitempty"`
					Meaning       *string `json:"meaning,omitempty"`
					Order         *int    `json:"order,omitempty"`
				} `json:"CA-QC,omitempty"`
				CH *[]struct {
					Certification *string `json:"certification,omitempty"`
					Meaning       *string `json:"meaning,omitempty"`
					Order         *int    `json:"order,omitempty"`
				} `json:"CH,omitempty"`
				DE *[]struct {
					Certification *string `json:"certification,omitempty"`
					Meaning       *string `json:"meaning,omitempty"`
					Order         *int    `json:"order,omitempty"`
				} `json:"DE,omitempty"`
				DK *[]struct {
					Certification *string `json:"certification,omitempty"`
					Meaning       *string `json:"meaning,omitempty"`
					Order         *int    `json:"order,omitempty"`
				} `json:"DK,omitempty"`
				ES *[]struct {
					Certification *string `json:"certification,omitempty"`
					Meaning       *string `json:"meaning,omitempty"`
					Order         *int    `json:"order,omitempty"`
				} `json:"ES,omitempty"`
				FI *[]struct {
					Certification *string `json:"certification,omitempty"`
					Meaning       *string `json:"meaning,omitempty"`
					Order         *int    `json:"order,omitempty"`
				} `json:"FI,omitempty"`
				FR *[]struct {
					Certification *string `json:"certification,omitempty"`
					Meaning       *string `json:"meaning,omitempty"`
					Order         *int    `json:"order,omitempty"`
				} `json:"FR,omitempty"`
				GB *[]struct {
					Certification *string `json:"certification,omitempty"`
					Meaning       *string `json:"meaning,omitempty"`
					Order         *int    `json:"order,omitempty"`
				} `json:"GB,omitempty"`
				GR *[]struct {
					Certification *string `json:"certification,omitempty"`
					Meaning       *string `json:"meaning,omitempty"`
					Order         *int    `json:"order,omitempty"`
				} `json:"GR,omitempty"`
				HK *[]struct {
					Certification *string `json:"certification,omitempty"`
					Meaning       *string `json:"meaning,omitempty"`
					Order         *int    `json:"order,omitempty"`
				} `json:"HK,omitempty"`
				HU *[]struct {
					Certification *string `json:"certification,omitempty"`
					Meaning       *string `json:"meaning,omitempty"`
					Order         *int    `json:"order,omitempty"`
				} `json:"HU,omitempty"`
				ID *[]struct {
					Certification *string `json:"certification,omitempty"`
					Meaning       *string `json:"meaning,omitempty"`
					Order         *int    `json:"order,omitempty"`
				} `json:"ID,omitempty"`
				IE *[]struct {
					Certification *string `json:"certification,omitempty"`
					Meaning       *string `json:"meaning,omitempty"`
					Order         *int    `json:"order,omitempty"`
				} `json:"IE,omitempty"`
				IL *[]struct {
					Certification *string `json:"certification,omitempty"`
					Meaning       *string `json:"meaning,omitempty"`
					Order         *int    `json:"order,omitempty"`
				} `json:"IL,omitempty"`
				IN *[]struct {
					Certification *string `json:"certification,omitempty"`
					Meaning       *string `json:"meaning,omitempty"`
					Order         *int    `json:"order,omitempty"`
				} `json:"IN,omitempty"`
				IT *[]struct {
					Certification *string `json:"certification,omitempty"`
					Meaning       *string `json:"meaning,omitempty"`
					Order         *int    `json:"order,omitempty"`
				} `json:"IT,omitempty"`
				JP *[]struct {
					Certification *string `json:"certification,omitempty"`
					Meaning       *string `json:"meaning,omitempty"`
					Order         *int    `json:"order,omitempty"`
				} `json:"JP,omitempty"`
				KR *[]struct {
					Certification *string `json:"certification,omitempty"`
					Meaning       *string `json:"meaning,omitempty"`
					Order         *int    `json:"order,omitempty"`
				} `json:"KR,omitempty"`
				LT *[]struct {
					Certification *string `json:"certification,omitempty"`
					Meaning       *string `json:"meaning,omitempty"`
					Order         *int    `json:"order,omitempty"`
				} `json:"LT,omitempty"`
				LU *[]struct {
					Certification *string `json:"certification,omitempty"`
					Meaning       *string `json:"meaning,omitempty"`
					Order         *int    `json:"order,omitempty"`
				} `json:"LU,omitempty"`
				LV *[]struct {
					Certification *string `json:"certification,omitempty"`
					Meaning       *string `json:"meaning,omitempty"`
					Order         *int    `json:"order,omitempty"`
				} `json:"LV,omitempty"`
				MO *[]struct {
					Certification *string `json:"certification,omitempty"`
					Meaning       *string `json:"meaning,omitempty"`
					Order         *int    `json:"order,omitempty"`
				} `json:"MO,omitempty"`
				MX *[]struct {
					Certification *string `json:"certification,omitempty"`
					Meaning       *string `json:"meaning,omitempty"`
					Order         *int    `json:"order,omitempty"`
				} `json:"MX,omitempty"`
				MY *[]struct {
					Certification *string `json:"certification,omitempty"`
					Meaning       *string `json:"meaning,omitempty"`
					Order         *int    `json:"order,omitempty"`
				} `json:"MY,omitempty"`
				NL *[]struct {
					Certification *string `json:"certification,omitempty"`
					Meaning       *string `json:"meaning,omitempty"`
					Order         *int    `json:"order,omitempty"`
				} `json:"NL,omitempty"`
				NO *[]struct {
					Certification *string `json:"certification,omitempty"`
					Meaning       *string `json:"meaning,omitempty"`
					Order         *int    `json:"order,omitempty"`
				} `json:"NO,omitempty"`
				NZ *[]struct {
					Certification *string `json:"certification,omitempty"`
					Meaning       *string `json:"meaning,omitempty"`
					Order         *int    `json:"order,omitempty"`
				} `json:"NZ,omitempty"`
				PH *[]struct {
					Certification *string `json:"certification,omitempty"`
					Meaning       *string `json:"meaning,omitempty"`
					Order         *int    `json:"order,omitempty"`
				} `json:"PH,omitempty"`
				PR *[]struct {
					Certification *string `json:"certification,omitempty"`
					Meaning       *string `json:"meaning,omitempty"`
					Order         *int    `json:"order,omitempty"`
				} `json:"PR,omitempty"`
				PT *[]struct {
					Certification *string `json:"certification,omitempty"`
					Meaning       *string `json:"meaning,omitempty"`
					Order         *int    `json:"order,omitempty"`
				} `json:"PT,omitempty"`
				RU *[]struct {
					Certification *string `json:"certification,omitempty"`
					Meaning       *string `json:"meaning,omitempty"`
					Order         *int    `json:"order,omitempty"`
				} `json:"RU,omitempty"`
				SE *[]struct {
					Certification *string `json:"certification,omitempty"`
					Meaning       *string `json:"meaning,omitempty"`
					Order         *int    `json:"order,omitempty"`
				} `json:"SE,omitempty"`
				SG *[]struct {
					Certification *string `json:"certification,omitempty"`
					Meaning       *string `json:"meaning,omitempty"`
					Order         *int    `json:"order,omitempty"`
				} `json:"SG,omitempty"`
				SK *[]struct {
					Certification *string `json:"certification,omitempty"`
					Meaning       *string `json:"meaning,omitempty"`
					Order         *int    `json:"order,omitempty"`
				} `json:"SK,omitempty"`
				TH *[]struct {
					Certification *string `json:"certification,omitempty"`
					Meaning       *string `json:"meaning,omitempty"`
					Order         *int    `json:"order,omitempty"`
				} `json:"TH,omitempty"`
				TR *[]struct {
					Certification *string `json:"certification,omitempty"`
					Meaning       *string `json:"meaning,omitempty"`
					Order         *int    `json:"order,omitempty"`
				} `json:"TR,omitempty"`
				TW *[]struct {
					Certification *string `json:"certification,omitempty"`
					Meaning       *string `json:"meaning,omitempty"`
					Order         *int    `json:"order,omitempty"`
				} `json:"TW,omitempty"`
				US *[]struct {
					Certification *string `json:"certification,omitempty"`
					Meaning       *string `json:"meaning,omitempty"`
					Order         *int    `json:"order,omitempty"`
				} `json:"US,omitempty"`
				VI *[]struct {
					Certification *string `json:"certification,omitempty"`
					Meaning       *string `json:"meaning,omitempty"`
					Order         *int    `json:"order,omitempty"`
				} `json:"VI,omitempty"`
				ZA *[]struct {
					Certification *string `json:"certification,omitempty"`
					Meaning       *string `json:"meaning,omitempty"`
					Order         *int    `json:"order,omitempty"`
				} `json:"ZA,omitempty"`
			} `json:"certifications,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCertificationsTvListResponse parses an HTTP response from a CertificationsTvListWithResponse call
func ParseCertificationsTvListResponse(rsp *http.Response) (*CertificationsTvListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CertificationsTvListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Certifications *struct {
				AR *[]struct {
					Certification *string `json:"certification,omitempty"`
					Meaning       *string `json:"meaning,omitempty"`
					Order         *int    `json:"order,omitempty"`
				} `json:"AR,omitempty"`
				AU *[]struct {
					Certification *string `json:"certification,omitempty"`
					Meaning       *string `json:"meaning,omitempty"`
					Order         *int    `json:"order,omitempty"`
				} `json:"AU,omitempty"`
				BG *[]struct {
					Certification *string `json:"certification,omitempty"`
					Meaning       *string `json:"meaning,omitempty"`
					Order         *int    `json:"order,omitempty"`
				} `json:"BG,omitempty"`
				BR *[]struct {
					Certification *string `json:"certification,omitempty"`
					Meaning       *string `json:"meaning,omitempty"`
					Order         *int    `json:"order,omitempty"`
				} `json:"BR,omitempty"`
				CA *[]struct {
					Certification *string `json:"certification,omitempty"`
					Meaning       *string `json:"meaning,omitempty"`
					Order         *int    `json:"order,omitempty"`
				} `json:"CA,omitempty"`
				CAQC *[]struct {
					Certification *string `json:"certification,omitempty"`
					Meaning       *string `json:"meaning,omitempty"`
					Order         *int    `json:"order,omitempty"`
				} `json:"CA-QC,omitempty"`
				DE *[]struct {
					Certification *string `json:"certification,omitempty"`
					Meaning       *string `json:"meaning,omitempty"`
					Order         *int    `json:"order,omitempty"`
				} `json:"DE,omitempty"`
				DK *[]struct {
					Certification *string `json:"certification,omitempty"`
					Meaning       *string `json:"meaning,omitempty"`
					Order         *int    `json:"order,omitempty"`
				} `json:"DK,omitempty"`
				ES *[]struct {
					Certification *string `json:"certification,omitempty"`
					Meaning       *string `json:"meaning,omitempty"`
					Order         *int    `json:"order,omitempty"`
				} `json:"ES,omitempty"`
				FI *[]struct {
					Certification *string `json:"certification,omitempty"`
					Meaning       *string `json:"meaning,omitempty"`
					Order         *int    `json:"order,omitempty"`
				} `json:"FI,omitempty"`
				FR *[]struct {
					Certification *string `json:"certification,omitempty"`
					Meaning       *string `json:"meaning,omitempty"`
					Order         *int    `json:"order,omitempty"`
				} `json:"FR,omitempty"`
				GB *[]struct {
					Certification *string `json:"certification,omitempty"`
					Meaning       *string `json:"meaning,omitempty"`
					Order         *int    `json:"order,omitempty"`
				} `json:"GB,omitempty"`
				GR *[]struct {
					Certification *string `json:"certification,omitempty"`
					Meaning       *string `json:"meaning,omitempty"`
					Order         *int    `json:"order,omitempty"`
				} `json:"GR,omitempty"`
				HU *[]struct {
					Certification *string `json:"certification,omitempty"`
					Meaning       *string `json:"meaning,omitempty"`
					Order         *int    `json:"order,omitempty"`
				} `json:"HU,omitempty"`
				ID *[]struct {
					Certification *string `json:"certification,omitempty"`
					Meaning       *string `json:"meaning,omitempty"`
					Order         *int    `json:"order,omitempty"`
				} `json:"ID,omitempty"`
				IL *[]struct {
					Certification *string `json:"certification,omitempty"`
					Meaning       *string `json:"meaning,omitempty"`
					Order         *int    `json:"order,omitempty"`
				} `json:"IL,omitempty"`
				IN *[]struct {
					Certification *string `json:"certification,omitempty"`
					Meaning       *string `json:"meaning,omitempty"`
					Order         *int    `json:"order,omitempty"`
				} `json:"IN,omitempty"`
				IT *[]struct {
					Certification *string `json:"certification,omitempty"`
					Meaning       *string `json:"meaning,omitempty"`
					Order         *int    `json:"order,omitempty"`
				} `json:"IT,omitempty"`
				KR *[]struct {
					Certification *string `json:"certification,omitempty"`
					Meaning       *string `json:"meaning,omitempty"`
					Order         *int    `json:"order,omitempty"`
				} `json:"KR,omitempty"`
				LT *[]struct {
					Certification *string `json:"certification,omitempty"`
					Meaning       *string `json:"meaning,omitempty"`
					Order         *int    `json:"order,omitempty"`
				} `json:"LT,omitempty"`
				MA *[]struct {
					Certification *string `json:"certification,omitempty"`
					Meaning       *string `json:"meaning,omitempty"`
					Order         *int    `json:"order,omitempty"`
				} `json:"MA,omitempty"`
				MX *[]struct {
					Certification *string `json:"certification,omitempty"`
					Meaning       *string `json:"meaning,omitempty"`
					Order         *int    `json:"order,omitempty"`
				} `json:"MX,omitempty"`
				MY *[]struct {
					Certification *string `json:"certification,omitempty"`
					Meaning       *string `json:"meaning,omitempty"`
					Order         *int    `json:"order,omitempty"`
				} `json:"MY,omitempty"`
				NL *[]struct {
					Certification *string `json:"certification,omitempty"`
					Meaning       *string `json:"meaning,omitempty"`
					Order         *int    `json:"order,omitempty"`
				} `json:"NL,omitempty"`
				NO *[]struct {
					Certification *string `json:"certification,omitempty"`
					Meaning       *string `json:"meaning,omitempty"`
					Order         *int    `json:"order,omitempty"`
				} `json:"NO,omitempty"`
				NZ *[]struct {
					Certification *string `json:"certification,omitempty"`
					Meaning       *string `json:"meaning,omitempty"`
					Order         *int    `json:"order,omitempty"`
				} `json:"NZ,omitempty"`
				PH *[]struct {
					Certification *string `json:"certification,omitempty"`
					Meaning       *string `json:"meaning,omitempty"`
					Order         *int    `json:"order,omitempty"`
				} `json:"PH,omitempty"`
				PL *[]struct {
					Certification *string `json:"certification,omitempty"`
					Meaning       *string `json:"meaning,omitempty"`
					Order         *int    `json:"order,omitempty"`
				} `json:"PL,omitempty"`
				PR *[]struct {
					Certification *string `json:"certification,omitempty"`
					Meaning       *string `json:"meaning,omitempty"`
					Order         *int    `json:"order,omitempty"`
				} `json:"PR,omitempty"`
				PT *[]struct {
					Certification *string `json:"certification,omitempty"`
					Meaning       *string `json:"meaning,omitempty"`
					Order         *int    `json:"order,omitempty"`
				} `json:"PT,omitempty"`
				RU *[]struct {
					Certification *string `json:"certification,omitempty"`
					Meaning       *string `json:"meaning,omitempty"`
					Order         *int    `json:"order,omitempty"`
				} `json:"RU,omitempty"`
				SE *[]struct {
					Certification *string `json:"certification,omitempty"`
					Meaning       *string `json:"meaning,omitempty"`
					Order         *int    `json:"order,omitempty"`
				} `json:"SE,omitempty"`
				SG *[]struct {
					Certification *string `json:"certification,omitempty"`
					Meaning       *string `json:"meaning,omitempty"`
					Order         *int    `json:"order,omitempty"`
				} `json:"SG,omitempty"`
				SK *[]struct {
					Certification *string `json:"certification,omitempty"`
					Meaning       *string `json:"meaning,omitempty"`
					Order         *int    `json:"order,omitempty"`
				} `json:"SK,omitempty"`
				TH *[]struct {
					Certification *string `json:"certification,omitempty"`
					Meaning       *string `json:"meaning,omitempty"`
					Order         *int    `json:"order,omitempty"`
				} `json:"TH,omitempty"`
				TR *[]struct {
					Certification *string `json:"certification,omitempty"`
					Meaning       *string `json:"meaning,omitempty"`
					Order         *int    `json:"order,omitempty"`
				} `json:"TR,omitempty"`
				TW *[]struct {
					Certification *string `json:"certification,omitempty"`
					Meaning       *string `json:"meaning,omitempty"`
					Order         *int    `json:"order,omitempty"`
				} `json:"TW,omitempty"`
				US *[]struct {
					Certification *string `json:"certification,omitempty"`
					Meaning       *string `json:"meaning,omitempty"`
					Order         *int    `json:"order,omitempty"`
				} `json:"US,omitempty"`
				VI *[]struct {
					Certification *string `json:"certification,omitempty"`
					Meaning       *string `json:"meaning,omitempty"`
					Order         *int    `json:"order,omitempty"`
				} `json:"VI,omitempty"`
				ZA *[]struct {
					Certification *string `json:"certification,omitempty"`
					Meaning       *string `json:"meaning,omitempty"`
					Order         *int    `json:"order,omitempty"`
				} `json:"ZA,omitempty"`
			} `json:"certifications,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCollectionDetailsResponse parses an HTTP response from a CollectionDetailsWithResponse call
func ParseCollectionDetailsResponse(rsp *http.Response) (*CollectionDetailsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CollectionDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			BackdropPath *string `json:"backdrop_path,omitempty"`
			ID           *int    `json:"id,omitempty"`
			Name         *string `json:"name,omitempty"`
			Overview     *string `json:"overview,omitempty"`
			Parts        *[]struct {
				Adult            *bool    `json:"adult,omitempty"`
				BackdropPath     *string  `json:"backdrop_path,omitempty"`
				GenreIds         *[]int   `json:"genre_ids,omitempty"`
				ID               *int     `json:"id,omitempty"`
				MediaType        *string  `json:"media_type,omitempty"`
				OriginalLanguage *string  `json:"original_language,omitempty"`
				OriginalTitle    *string  `json:"original_title,omitempty"`
				Overview         *string  `json:"overview,omitempty"`
				Popularity       *float32 `json:"popularity,omitempty"`
				PosterPath       *string  `json:"poster_path,omitempty"`
				ReleaseDate      *string  `json:"release_date,omitempty"`
				Title            *string  `json:"title,omitempty"`
				Video            *bool    `json:"video,omitempty"`
				VoteAverage      *float32 `json:"vote_average,omitempty"`
				VoteCount        *int     `json:"vote_count,omitempty"`
			} `json:"parts,omitempty"`
			PosterPath *string `json:"poster_path,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCollectionImagesResponse parses an HTTP response from a CollectionImagesWithResponse call
func ParseCollectionImagesResponse(rsp *http.Response) (*CollectionImagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CollectionImagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Backdrops *[]struct {
				AspectRatio *float32     `json:"aspect_ratio,omitempty"`
				FilePath    *string      `json:"file_path,omitempty"`
				Height      *int         `json:"height,omitempty"`
				Iso6391     *interface{} `json:"iso_639_1,omitempty"`
				VoteAverage *float32     `json:"vote_average,omitempty"`
				VoteCount   *int         `json:"vote_count,omitempty"`
				Width       *int         `json:"width,omitempty"`
			} `json:"backdrops,omitempty"`
			ID      *int `json:"id,omitempty"`
			Posters *[]struct {
				AspectRatio *float32 `json:"aspect_ratio,omitempty"`
				FilePath    *string  `json:"file_path,omitempty"`
				Height      *int     `json:"height,omitempty"`
				Iso6391     *string  `json:"iso_639_1,omitempty"`
				VoteAverage *float32 `json:"vote_average,omitempty"`
				VoteCount   *int     `json:"vote_count,omitempty"`
				Width       *int     `json:"width,omitempty"`
			} `json:"posters,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCollectionTranslationsResponse parses an HTTP response from a CollectionTranslationsWithResponse call
func ParseCollectionTranslationsResponse(rsp *http.Response) (*CollectionTranslationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CollectionTranslationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			ID           *int `json:"id,omitempty"`
			Translations *[]struct {
				Data *struct {
					Homepage *string `json:"homepage,omitempty"`
					Overview *string `json:"overview,omitempty"`
					Title    *string `json:"title,omitempty"`
				} `json:"data,omitempty"`
				EnglishName *string `json:"english_name,omitempty"`
				Iso31661    *string `json:"iso_3166_1,omitempty"`
				Iso6391     *string `json:"iso_639_1,omitempty"`
				Name        *string `json:"name,omitempty"`
			} `json:"translations,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCompanyDetailsResponse parses an HTTP response from a CompanyDetailsWithResponse call
func ParseCompanyDetailsResponse(rsp *http.Response) (*CompanyDetailsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CompanyDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Description   *string      `json:"description,omitempty"`
			Headquarters  *string      `json:"headquarters,omitempty"`
			Homepage      *string      `json:"homepage,omitempty"`
			ID            *int         `json:"id,omitempty"`
			LogoPath      *string      `json:"logo_path,omitempty"`
			Name          *string      `json:"name,omitempty"`
			OriginCountry *string      `json:"origin_country,omitempty"`
			ParentCompany *interface{} `json:"parent_company,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCompanyAlternativeNamesResponse parses an HTTP response from a CompanyAlternativeNamesWithResponse call
func ParseCompanyAlternativeNamesResponse(rsp *http.Response) (*CompanyAlternativeNamesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CompanyAlternativeNamesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			ID      *int `json:"id,omitempty"`
			Results *[]struct {
				Name *string `json:"name,omitempty"`
				Type *string `json:"type,omitempty"`
			} `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCompanyImagesResponse parses an HTTP response from a CompanyImagesWithResponse call
func ParseCompanyImagesResponse(rsp *http.Response) (*CompanyImagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CompanyImagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			ID    *int `json:"id,omitempty"`
			Logos *[]struct {
				AspectRatio *float32 `json:"aspect_ratio,omitempty"`
				FilePath    *string  `json:"file_path,omitempty"`
				FileType    *string  `json:"file_type,omitempty"`
				Height      *int     `json:"height,omitempty"`
				ID          *string  `json:"id,omitempty"`
				VoteAverage *float32 `json:"vote_average,omitempty"`
				VoteCount   *int     `json:"vote_count,omitempty"`
				Width       *int     `json:"width,omitempty"`
			} `json:"logos,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseConfigurationDetailsResponse parses an HTTP response from a ConfigurationDetailsWithResponse call
func ParseConfigurationDetailsResponse(rsp *http.Response) (*ConfigurationDetailsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ConfigurationDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			ChangeKeys *[]string `json:"change_keys,omitempty"`
			Images     *struct {
				BackdropSizes *[]string `json:"backdrop_sizes,omitempty"`
				BaseURL       *string   `json:"base_url,omitempty"`
				LogoSizes     *[]string `json:"logo_sizes,omitempty"`
				PosterSizes   *[]string `json:"poster_sizes,omitempty"`
				ProfileSizes  *[]string `json:"profile_sizes,omitempty"`
				SecureBaseURL *string   `json:"secure_base_url,omitempty"`
				StillSizes    *[]string `json:"still_sizes,omitempty"`
			} `json:"images,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseConfigurationCountriesResponse parses an HTTP response from a ConfigurationCountriesWithResponse call
func ParseConfigurationCountriesResponse(rsp *http.Response) (*ConfigurationCountriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ConfigurationCountriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			EnglishName *string `json:"english_name,omitempty"`
			Iso31661    *string `json:"iso_3166_1,omitempty"`
			NativeName  *string `json:"native_name,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseConfigurationJobsResponse parses an HTTP response from a ConfigurationJobsWithResponse call
func ParseConfigurationJobsResponse(rsp *http.Response) (*ConfigurationJobsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ConfigurationJobsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			Department *string   `json:"department,omitempty"`
			Jobs       *[]string `json:"jobs,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseConfigurationLanguagesResponse parses an HTTP response from a ConfigurationLanguagesWithResponse call
func ParseConfigurationLanguagesResponse(rsp *http.Response) (*ConfigurationLanguagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ConfigurationLanguagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			EnglishName *string `json:"english_name,omitempty"`
			Iso6391     *string `json:"iso_639_1,omitempty"`
			Name        *string `json:"name,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseConfigurationPrimaryTranslationsResponse parses an HTTP response from a ConfigurationPrimaryTranslationsWithResponse call
func ParseConfigurationPrimaryTranslationsResponse(rsp *http.Response) (*ConfigurationPrimaryTranslationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ConfigurationPrimaryTranslationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseConfigurationTimezonesResponse parses an HTTP response from a ConfigurationTimezonesWithResponse call
func ParseConfigurationTimezonesResponse(rsp *http.Response) (*ConfigurationTimezonesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ConfigurationTimezonesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			Iso31661 *string   `json:"iso_3166_1,omitempty"`
			Zones    *[]string `json:"zones,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreditDetailsResponse parses an HTTP response from a CreditDetailsWithResponse call
func ParseCreditDetailsResponse(rsp *http.Response) (*CreditDetailsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreditDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			CreditType *string `json:"credit_type,omitempty"`
			Department *string `json:"department,omitempty"`
			ID         *string `json:"id,omitempty"`
			Job        *string `json:"job,omitempty"`
			Media      *struct {
				Adult            *bool          `json:"adult,omitempty"`
				BackdropPath     *string        `json:"backdrop_path,omitempty"`
				Character        *string        `json:"character,omitempty"`
				Episodes         *[]interface{} `json:"episodes,omitempty"`
				FirstAirDate     *string        `json:"first_air_date,omitempty"`
				GenreIds         *[]int         `json:"genre_ids,omitempty"`
				ID               *int           `json:"id,omitempty"`
				MediaType        *string        `json:"media_type,omitempty"`
				Name             *string        `json:"name,omitempty"`
				OriginCountry    *[]string      `json:"origin_country,omitempty"`
				OriginalLanguage *string        `json:"original_language,omitempty"`
				OriginalName     *string        `json:"original_name,omitempty"`
				Overview         *string        `json:"overview,omitempty"`
				Popularity       *float32       `json:"popularity,omitempty"`
				PosterPath       *string        `json:"poster_path,omitempty"`
				Seasons          *[]struct {
					AirDate      *string `json:"air_date,omitempty"`
					EpisodeCount *int    `json:"episode_count,omitempty"`
					ID           *int    `json:"id,omitempty"`
					Name         *string `json:"name,omitempty"`
					Overview     *string `json:"overview,omitempty"`
					PosterPath   *string `json:"poster_path,omitempty"`
					SeasonNumber *int    `json:"season_number,omitempty"`
					ShowID       *int    `json:"show_id,omitempty"`
				} `json:"seasons,omitempty"`
				VoteAverage *float32 `json:"vote_average,omitempty"`
				VoteCount   *int     `json:"vote_count,omitempty"`
			} `json:"media,omitempty"`
			MediaType *string `json:"media_type,omitempty"`
			Person    *struct {
				Adult              *bool    `json:"adult,omitempty"`
				Gender             *int     `json:"gender,omitempty"`
				ID                 *int     `json:"id,omitempty"`
				KnownForDepartment *string  `json:"known_for_department,omitempty"`
				MediaType          *string  `json:"media_type,omitempty"`
				Name               *string  `json:"name,omitempty"`
				OriginalName       *string  `json:"original_name,omitempty"`
				Popularity         *float32 `json:"popularity,omitempty"`
				ProfilePath        *string  `json:"profile_path,omitempty"`
			} `json:"person,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDiscoverMovieResponse parses an HTTP response from a DiscoverMovieWithResponse call
func ParseDiscoverMovieResponse(rsp *http.Response) (*DiscoverMovieResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DiscoverMovieResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Page    *int `json:"page,omitempty"`
			Results *[]struct {
				Adult            *bool    `json:"adult,omitempty"`
				BackdropPath     *string  `json:"backdrop_path,omitempty"`
				GenreIds         *[]int   `json:"genre_ids,omitempty"`
				ID               *int     `json:"id,omitempty"`
				OriginalLanguage *string  `json:"original_language,omitempty"`
				OriginalTitle    *string  `json:"original_title,omitempty"`
				Overview         *string  `json:"overview,omitempty"`
				Popularity       *float32 `json:"popularity,omitempty"`
				PosterPath       *string  `json:"poster_path,omitempty"`
				ReleaseDate      *string  `json:"release_date,omitempty"`
				Title            *string  `json:"title,omitempty"`
				Video            *bool    `json:"video,omitempty"`
				VoteAverage      *float32 `json:"vote_average,omitempty"`
				VoteCount        *int     `json:"vote_count,omitempty"`
			} `json:"results,omitempty"`
			TotalPages   *int `json:"total_pages,omitempty"`
			TotalResults *int `json:"total_results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDiscoverTvResponse parses an HTTP response from a DiscoverTvWithResponse call
func ParseDiscoverTvResponse(rsp *http.Response) (*DiscoverTvResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DiscoverTvResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Page    *int `json:"page,omitempty"`
			Results *[]struct {
				BackdropPath     *string   `json:"backdrop_path,omitempty"`
				FirstAirDate     *string   `json:"first_air_date,omitempty"`
				GenreIds         *[]int    `json:"genre_ids,omitempty"`
				ID               *int      `json:"id,omitempty"`
				Name             *string   `json:"name,omitempty"`
				OriginCountry    *[]string `json:"origin_country,omitempty"`
				OriginalLanguage *string   `json:"original_language,omitempty"`
				OriginalName     *string   `json:"original_name,omitempty"`
				Overview         *string   `json:"overview,omitempty"`
				Popularity       *float32  `json:"popularity,omitempty"`
				PosterPath       *string   `json:"poster_path,omitempty"`
				VoteAverage      *int      `json:"vote_average,omitempty"`
				VoteCount        *int      `json:"vote_count,omitempty"`
			} `json:"results,omitempty"`
			TotalPages   *int `json:"total_pages,omitempty"`
			TotalResults *int `json:"total_results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFindByIDResponse parses an HTTP response from a FindByIDWithResponse call
func ParseFindByIDResponse(rsp *http.Response) (*FindByIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindByIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			MovieResults *[]struct {
				Adult            *bool    `json:"adult,omitempty"`
				BackdropPath     *string  `json:"backdrop_path,omitempty"`
				GenreIds         *[]int   `json:"genre_ids,omitempty"`
				ID               *int     `json:"id,omitempty"`
				MediaType        *string  `json:"media_type,omitempty"`
				OriginalLanguage *string  `json:"original_language,omitempty"`
				OriginalTitle    *string  `json:"original_title,omitempty"`
				Overview         *string  `json:"overview,omitempty"`
				Popularity       *float32 `json:"popularity,omitempty"`
				PosterPath       *string  `json:"poster_path,omitempty"`
				ReleaseDate      *string  `json:"release_date,omitempty"`
				Title            *string  `json:"title,omitempty"`
				Video            *bool    `json:"video,omitempty"`
				VoteAverage      *float32 `json:"vote_average,omitempty"`
				VoteCount        *int     `json:"vote_count,omitempty"`
			} `json:"movie_results,omitempty"`
			PersonResults    *[]interface{} `json:"person_results,omitempty"`
			TvEpisodeResults *[]interface{} `json:"tv_episode_results,omitempty"`
			TvResults        *[]interface{} `json:"tv_results,omitempty"`
			TvSeasonResults  *[]interface{} `json:"tv_season_results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGenreMovieListResponse parses an HTTP response from a GenreMovieListWithResponse call
func ParseGenreMovieListResponse(rsp *http.Response) (*GenreMovieListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GenreMovieListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Genres *[]struct {
				ID   *int    `json:"id,omitempty"`
				Name *string `json:"name,omitempty"`
			} `json:"genres,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGenreTvListResponse parses an HTTP response from a GenreTvListWithResponse call
func ParseGenreTvListResponse(rsp *http.Response) (*GenreTvListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GenreTvListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Genres *[]struct {
				ID   *int    `json:"id,omitempty"`
				Name *string `json:"name,omitempty"`
			} `json:"genres,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGuestSessionRatedMoviesResponse parses an HTTP response from a GuestSessionRatedMoviesWithResponse call
func ParseGuestSessionRatedMoviesResponse(rsp *http.Response) (*GuestSessionRatedMoviesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GuestSessionRatedMoviesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Page    *int `json:"page,omitempty"`
			Results *[]struct {
				Adult            *bool    `json:"adult,omitempty"`
				BackdropPath     *string  `json:"backdrop_path,omitempty"`
				GenreIds         *[]int   `json:"genre_ids,omitempty"`
				ID               *int     `json:"id,omitempty"`
				OriginalLanguage *string  `json:"original_language,omitempty"`
				OriginalTitle    *string  `json:"original_title,omitempty"`
				Overview         *string  `json:"overview,omitempty"`
				Popularity       *float32 `json:"popularity,omitempty"`
				PosterPath       *string  `json:"poster_path,omitempty"`
				Rating           *float32 `json:"rating,omitempty"`
				ReleaseDate      *string  `json:"release_date,omitempty"`
				Title            *string  `json:"title,omitempty"`
				Video            *bool    `json:"video,omitempty"`
				VoteAverage      *float32 `json:"vote_average,omitempty"`
				VoteCount        *int     `json:"vote_count,omitempty"`
			} `json:"results,omitempty"`
			TotalPages   *int `json:"total_pages,omitempty"`
			TotalResults *int `json:"total_results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGuestSessionRatedTvResponse parses an HTTP response from a GuestSessionRatedTvWithResponse call
func ParseGuestSessionRatedTvResponse(rsp *http.Response) (*GuestSessionRatedTvResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GuestSessionRatedTvResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Page    *int `json:"page,omitempty"`
			Results *[]struct {
				Adult            *bool     `json:"adult,omitempty"`
				BackdropPath     *string   `json:"backdrop_path,omitempty"`
				FirstAirDate     *string   `json:"first_air_date,omitempty"`
				GenreIds         *[]int    `json:"genre_ids,omitempty"`
				ID               *int      `json:"id,omitempty"`
				Name             *string   `json:"name,omitempty"`
				OriginCountry    *[]string `json:"origin_country,omitempty"`
				OriginalLanguage *string   `json:"original_language,omitempty"`
				OriginalName     *string   `json:"original_name,omitempty"`
				Overview         *string   `json:"overview,omitempty"`
				Popularity       *float32  `json:"popularity,omitempty"`
				PosterPath       *string   `json:"poster_path,omitempty"`
				Rating           *float32  `json:"rating,omitempty"`
				VoteAverage      *float32  `json:"vote_average,omitempty"`
				VoteCount        *int      `json:"vote_count,omitempty"`
			} `json:"results,omitempty"`
			TotalPages   *int `json:"total_pages,omitempty"`
			TotalResults *int `json:"total_results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGuestSessionRatedTvEpisodesResponse parses an HTTP response from a GuestSessionRatedTvEpisodesWithResponse call
func ParseGuestSessionRatedTvEpisodesResponse(rsp *http.Response) (*GuestSessionRatedTvEpisodesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GuestSessionRatedTvEpisodesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Page    *int `json:"page,omitempty"`
			Results *[]struct {
				AirDate        *string  `json:"air_date,omitempty"`
				EpisodeNumber  *int     `json:"episode_number,omitempty"`
				ID             *int     `json:"id,omitempty"`
				Name           *string  `json:"name,omitempty"`
				Overview       *string  `json:"overview,omitempty"`
				ProductionCode *string  `json:"production_code,omitempty"`
				Rating         *float32 `json:"rating,omitempty"`
				Runtime        *int     `json:"runtime,omitempty"`
				SeasonNumber   *int     `json:"season_number,omitempty"`
				ShowID         *int     `json:"show_id,omitempty"`
				StillPath      *string  `json:"still_path,omitempty"`
				VoteAverage    *float32 `json:"vote_average,omitempty"`
				VoteCount      *int     `json:"vote_count,omitempty"`
			} `json:"results,omitempty"`
			TotalPages   *int `json:"total_pages,omitempty"`
			TotalResults *int `json:"total_results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseKeywordDetailsResponse parses an HTTP response from a KeywordDetailsWithResponse call
func ParseKeywordDetailsResponse(rsp *http.Response) (*KeywordDetailsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &KeywordDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			ID   *int    `json:"id,omitempty"`
			Name *string `json:"name,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseKeywordMoviesResponse parses an HTTP response from a KeywordMoviesWithResponse call
func ParseKeywordMoviesResponse(rsp *http.Response) (*KeywordMoviesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &KeywordMoviesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			ID      *int `json:"id,omitempty"`
			Page    *int `json:"page,omitempty"`
			Results *[]struct {
				Adult            *bool    `json:"adult,omitempty"`
				BackdropPath     *string  `json:"backdrop_path,omitempty"`
				GenreIds         *[]int   `json:"genre_ids,omitempty"`
				ID               *int     `json:"id,omitempty"`
				OriginalLanguage *string  `json:"original_language,omitempty"`
				OriginalTitle    *string  `json:"original_title,omitempty"`
				Overview         *string  `json:"overview,omitempty"`
				Popularity       *float32 `json:"popularity,omitempty"`
				PosterPath       *string  `json:"poster_path,omitempty"`
				ReleaseDate      *string  `json:"release_date,omitempty"`
				Title            *string  `json:"title,omitempty"`
				Video            *bool    `json:"video,omitempty"`
				VoteAverage      *float32 `json:"vote_average,omitempty"`
				VoteCount        *int     `json:"vote_count,omitempty"`
			} `json:"results,omitempty"`
			TotalPages   *int `json:"total_pages,omitempty"`
			TotalResults *int `json:"total_results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListCreateResponse parses an HTTP response from a ListCreateWithResponse call
func ParseListCreateResponse(rsp *http.Response) (*ListCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			ListID        *int    `json:"list_id,omitempty"`
			StatusCode    *int    `json:"status_code,omitempty"`
			StatusMessage *string `json:"status_message,omitempty"`
			Success       *bool   `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListDeleteResponse parses an HTTP response from a ListDeleteWithResponse call
func ParseListDeleteResponse(rsp *http.Response) (*ListDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			StatusCode    *int    `json:"status_code,omitempty"`
			StatusMessage *string `json:"status_message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListDetailsResponse parses an HTTP response from a ListDetailsWithResponse call
func ParseListDetailsResponse(rsp *http.Response) (*ListDetailsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			CreatedBy     *string `json:"created_by,omitempty"`
			Description   *string `json:"description,omitempty"`
			FavoriteCount *int    `json:"favorite_count,omitempty"`
			ID            *string `json:"id,omitempty"`
			Iso6391       *string `json:"iso_639_1,omitempty"`
			ItemCount     *int    `json:"item_count,omitempty"`
			Items         *[]struct {
				Adult            *bool    `json:"adult,omitempty"`
				BackdropPath     *string  `json:"backdrop_path,omitempty"`
				GenreIds         *[]int   `json:"genre_ids,omitempty"`
				ID               *int     `json:"id,omitempty"`
				MediaType        *string  `json:"media_type,omitempty"`
				OriginalLanguage *string  `json:"original_language,omitempty"`
				OriginalTitle    *string  `json:"original_title,omitempty"`
				Overview         *string  `json:"overview,omitempty"`
				Popularity       *float32 `json:"popularity,omitempty"`
				PosterPath       *string  `json:"poster_path,omitempty"`
				ReleaseDate      *string  `json:"release_date,omitempty"`
				Title            *string  `json:"title,omitempty"`
				Video            *bool    `json:"video,omitempty"`
				VoteAverage      *int     `json:"vote_average,omitempty"`
				VoteCount        *int     `json:"vote_count,omitempty"`
			} `json:"items,omitempty"`
			Name       *string `json:"name,omitempty"`
			PosterPath *string `json:"poster_path,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListAddMovieResponse parses an HTTP response from a ListAddMovieWithResponse call
func ParseListAddMovieResponse(rsp *http.Response) (*ListAddMovieResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAddMovieResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			StatusCode    *int    `json:"status_code,omitempty"`
			StatusMessage *string `json:"status_message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListClearResponse parses an HTTP response from a ListClearWithResponse call
func ParseListClearResponse(rsp *http.Response) (*ListClearResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListClearResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			StatusCode    *int    `json:"status_code,omitempty"`
			StatusMessage *string `json:"status_message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListCheckItemStatusResponse parses an HTTP response from a ListCheckItemStatusWithResponse call
func ParseListCheckItemStatusResponse(rsp *http.Response) (*ListCheckItemStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListCheckItemStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			ID          *int  `json:"id,omitempty"`
			ItemPresent *bool `json:"item_present,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListRemoveMovieResponse parses an HTTP response from a ListRemoveMovieWithResponse call
func ParseListRemoveMovieResponse(rsp *http.Response) (*ListRemoveMovieResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListRemoveMovieResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			StatusCode    *int    `json:"status_code,omitempty"`
			StatusMessage *string `json:"status_message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseChangesMovieListResponse parses an HTTP response from a ChangesMovieListWithResponse call
func ParseChangesMovieListResponse(rsp *http.Response) (*ChangesMovieListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ChangesMovieListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Page    *int `json:"page,omitempty"`
			Results *[]struct {
				Adult *bool `json:"adult,omitempty"`
				ID    *int  `json:"id,omitempty"`
			} `json:"results,omitempty"`
			TotalPages   *int `json:"total_pages,omitempty"`
			TotalResults *int `json:"total_results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseMovieLatestIDResponse parses an HTTP response from a MovieLatestIDWithResponse call
func ParseMovieLatestIDResponse(rsp *http.Response) (*MovieLatestIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MovieLatestIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Adult               *bool          `json:"adult,omitempty"`
			BackdropPath        *interface{}   `json:"backdrop_path,omitempty"`
			BelongsToCollection *interface{}   `json:"belongs_to_collection,omitempty"`
			Budget              *int           `json:"budget,omitempty"`
			Genres              *[]interface{} `json:"genres,omitempty"`
			Homepage            *string        `json:"homepage,omitempty"`
			ID                  *int           `json:"id,omitempty"`
			ImdbID              *interface{}   `json:"imdb_id,omitempty"`
			OriginalLanguage    *string        `json:"original_language,omitempty"`
			OriginalTitle       *string        `json:"original_title,omitempty"`
			Overview            *string        `json:"overview,omitempty"`
			Popularity          *int           `json:"popularity,omitempty"`
			PosterPath          *interface{}   `json:"poster_path,omitempty"`
			ProductionCompanies *[]interface{} `json:"production_companies,omitempty"`
			ProductionCountries *[]interface{} `json:"production_countries,omitempty"`
			ReleaseDate         *string        `json:"release_date,omitempty"`
			Revenue             *int           `json:"revenue,omitempty"`
			Runtime             *int           `json:"runtime,omitempty"`
			SpokenLanguages     *[]interface{} `json:"spoken_languages,omitempty"`
			Status              *string        `json:"status,omitempty"`
			Tagline             *string        `json:"tagline,omitempty"`
			Title               *string        `json:"title,omitempty"`
			Video               *bool          `json:"video,omitempty"`
			VoteAverage         *int           `json:"vote_average,omitempty"`
			VoteCount           *int           `json:"vote_count,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseMovieNowPlayingListResponse parses an HTTP response from a MovieNowPlayingListWithResponse call
func ParseMovieNowPlayingListResponse(rsp *http.Response) (*MovieNowPlayingListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MovieNowPlayingListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Dates *struct {
				Maximum *string `json:"maximum,omitempty"`
				Minimum *string `json:"minimum,omitempty"`
			} `json:"dates,omitempty"`
			Page    *int `json:"page,omitempty"`
			Results *[]struct {
				Adult            *bool    `json:"adult,omitempty"`
				BackdropPath     *string  `json:"backdrop_path,omitempty"`
				GenreIds         *[]int   `json:"genre_ids,omitempty"`
				ID               *int     `json:"id,omitempty"`
				OriginalLanguage *string  `json:"original_language,omitempty"`
				OriginalTitle    *string  `json:"original_title,omitempty"`
				Overview         *string  `json:"overview,omitempty"`
				Popularity       *float32 `json:"popularity,omitempty"`
				PosterPath       *string  `json:"poster_path,omitempty"`
				ReleaseDate      *string  `json:"release_date,omitempty"`
				Title            *string  `json:"title,omitempty"`
				Video            *bool    `json:"video,omitempty"`
				VoteAverage      *float32 `json:"vote_average,omitempty"`
				VoteCount        *int     `json:"vote_count,omitempty"`
			} `json:"results,omitempty"`
			TotalPages   *int `json:"total_pages,omitempty"`
			TotalResults *int `json:"total_results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseMoviePopularListResponse parses an HTTP response from a MoviePopularListWithResponse call
func ParseMoviePopularListResponse(rsp *http.Response) (*MoviePopularListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MoviePopularListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Page    *int `json:"page,omitempty"`
			Results *[]struct {
				Adult            *bool    `json:"adult,omitempty"`
				BackdropPath     *string  `json:"backdrop_path,omitempty"`
				GenreIds         *[]int   `json:"genre_ids,omitempty"`
				ID               *int     `json:"id,omitempty"`
				OriginalLanguage *string  `json:"original_language,omitempty"`
				OriginalTitle    *string  `json:"original_title,omitempty"`
				Overview         *string  `json:"overview,omitempty"`
				Popularity       *float32 `json:"popularity,omitempty"`
				PosterPath       *string  `json:"poster_path,omitempty"`
				ReleaseDate      *string  `json:"release_date,omitempty"`
				Title            *string  `json:"title,omitempty"`
				Video            *bool    `json:"video,omitempty"`
				VoteAverage      *float32 `json:"vote_average,omitempty"`
				VoteCount        *int     `json:"vote_count,omitempty"`
			} `json:"results,omitempty"`
			TotalPages   *int `json:"total_pages,omitempty"`
			TotalResults *int `json:"total_results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseMovieTopRatedListResponse parses an HTTP response from a MovieTopRatedListWithResponse call
func ParseMovieTopRatedListResponse(rsp *http.Response) (*MovieTopRatedListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MovieTopRatedListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Page    *int `json:"page,omitempty"`
			Results *[]struct {
				Adult            *bool    `json:"adult,omitempty"`
				BackdropPath     *string  `json:"backdrop_path,omitempty"`
				GenreIds         *[]int   `json:"genre_ids,omitempty"`
				ID               *int     `json:"id,omitempty"`
				OriginalLanguage *string  `json:"original_language,omitempty"`
				OriginalTitle    *string  `json:"original_title,omitempty"`
				Overview         *string  `json:"overview,omitempty"`
				Popularity       *float32 `json:"popularity,omitempty"`
				PosterPath       *string  `json:"poster_path,omitempty"`
				ReleaseDate      *string  `json:"release_date,omitempty"`
				Title            *string  `json:"title,omitempty"`
				Video            *bool    `json:"video,omitempty"`
				VoteAverage      *float32 `json:"vote_average,omitempty"`
				VoteCount        *int     `json:"vote_count,omitempty"`
			} `json:"results,omitempty"`
			TotalPages   *int `json:"total_pages,omitempty"`
			TotalResults *int `json:"total_results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseMovieUpcomingListResponse parses an HTTP response from a MovieUpcomingListWithResponse call
func ParseMovieUpcomingListResponse(rsp *http.Response) (*MovieUpcomingListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MovieUpcomingListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Dates *struct {
				Maximum *string `json:"maximum,omitempty"`
				Minimum *string `json:"minimum,omitempty"`
			} `json:"dates,omitempty"`
			Page    *int `json:"page,omitempty"`
			Results *[]struct {
				Adult            *bool    `json:"adult,omitempty"`
				BackdropPath     *string  `json:"backdrop_path,omitempty"`
				GenreIds         *[]int   `json:"genre_ids,omitempty"`
				ID               *int     `json:"id,omitempty"`
				OriginalLanguage *string  `json:"original_language,omitempty"`
				OriginalTitle    *string  `json:"original_title,omitempty"`
				Overview         *string  `json:"overview,omitempty"`
				Popularity       *float32 `json:"popularity,omitempty"`
				PosterPath       *string  `json:"poster_path,omitempty"`
				ReleaseDate      *string  `json:"release_date,omitempty"`
				Title            *string  `json:"title,omitempty"`
				Video            *bool    `json:"video,omitempty"`
				VoteAverage      *int     `json:"vote_average,omitempty"`
				VoteCount        *int     `json:"vote_count,omitempty"`
			} `json:"results,omitempty"`
			TotalPages   *int `json:"total_pages,omitempty"`
			TotalResults *int `json:"total_results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseMovieDetailsResponse parses an HTTP response from a MovieDetailsWithResponse call
func ParseMovieDetailsResponse(rsp *http.Response) (*MovieDetailsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MovieDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Adult               *bool        `json:"adult,omitempty"`
			BackdropPath        *string      `json:"backdrop_path,omitempty"`
			BelongsToCollection *interface{} `json:"belongs_to_collection,omitempty"`
			Budget              *int         `json:"budget,omitempty"`
			Genres              *[]struct {
				ID   *int    `json:"id,omitempty"`
				Name *string `json:"name,omitempty"`
			} `json:"genres,omitempty"`
			Homepage            *string  `json:"homepage,omitempty"`
			ID                  *int     `json:"id,omitempty"`
			ImdbID              *string  `json:"imdb_id,omitempty"`
			OriginalLanguage    *string  `json:"original_language,omitempty"`
			OriginalTitle       *string  `json:"original_title,omitempty"`
			Overview            *string  `json:"overview,omitempty"`
			Popularity          *float32 `json:"popularity,omitempty"`
			PosterPath          *string  `json:"poster_path,omitempty"`
			ProductionCompanies *[]struct {
				ID            *int    `json:"id,omitempty"`
				LogoPath      *string `json:"logo_path,omitempty"`
				Name          *string `json:"name,omitempty"`
				OriginCountry *string `json:"origin_country,omitempty"`
			} `json:"production_companies,omitempty"`
			ProductionCountries *[]struct {
				Iso31661 *string `json:"iso_3166_1,omitempty"`
				Name     *string `json:"name,omitempty"`
			} `json:"production_countries,omitempty"`
			ReleaseDate     *string `json:"release_date,omitempty"`
			Revenue         *int    `json:"revenue,omitempty"`
			Runtime         *int    `json:"runtime,omitempty"`
			SpokenLanguages *[]struct {
				EnglishName *string `json:"english_name,omitempty"`
				Iso6391     *string `json:"iso_639_1,omitempty"`
				Name        *string `json:"name,omitempty"`
			} `json:"spoken_languages,omitempty"`
			Status      *string  `json:"status,omitempty"`
			Tagline     *string  `json:"tagline,omitempty"`
			Title       *string  `json:"title,omitempty"`
			Video       *bool    `json:"video,omitempty"`
			VoteAverage *float32 `json:"vote_average,omitempty"`
			VoteCount   *int     `json:"vote_count,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseMovieAccountStatesResponse parses an HTTP response from a MovieAccountStatesWithResponse call
func ParseMovieAccountStatesResponse(rsp *http.Response) (*MovieAccountStatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MovieAccountStatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Favorite *bool `json:"favorite,omitempty"`
			ID       *int  `json:"id,omitempty"`
			Rated    *struct {
				Value *int `json:"value,omitempty"`
			} `json:"rated,omitempty"`
			Watchlist *bool `json:"watchlist,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseMovieAlternativeTitlesResponse parses an HTTP response from a MovieAlternativeTitlesWithResponse call
func ParseMovieAlternativeTitlesResponse(rsp *http.Response) (*MovieAlternativeTitlesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MovieAlternativeTitlesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			ID     *int `json:"id,omitempty"`
			Titles *[]struct {
				Iso31661 *string `json:"iso_3166_1,omitempty"`
				Title    *string `json:"title,omitempty"`
				Type     *string `json:"type,omitempty"`
			} `json:"titles,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseMovieChangesResponse parses an HTTP response from a MovieChangesWithResponse call
func ParseMovieChangesResponse(rsp *http.Response) (*MovieChangesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MovieChangesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Changes *[]struct {
				Items *[]struct {
					Action   *string `json:"action,omitempty"`
					ID       *string `json:"id,omitempty"`
					Iso31661 *string `json:"iso_3166_1,omitempty"`
					Iso6391  *string `json:"iso_639_1,omitempty"`
					Time     *string `json:"time,omitempty"`
					Value    *struct {
						Poster *struct {
							FilePath *string `json:"file_path,omitempty"`
						} `json:"poster,omitempty"`
					} `json:"value,omitempty"`
				} `json:"items,omitempty"`
				Key *string `json:"key,omitempty"`
			} `json:"changes,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseMovieCreditsResponse parses an HTTP response from a MovieCreditsWithResponse call
func ParseMovieCreditsResponse(rsp *http.Response) (*MovieCreditsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MovieCreditsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Cast *[]struct {
				Adult              *bool    `json:"adult,omitempty"`
				CastID             *int     `json:"cast_id,omitempty"`
				Character          *string  `json:"character,omitempty"`
				CreditID           *string  `json:"credit_id,omitempty"`
				Gender             *int     `json:"gender,omitempty"`
				ID                 *int     `json:"id,omitempty"`
				KnownForDepartment *string  `json:"known_for_department,omitempty"`
				Name               *string  `json:"name,omitempty"`
				Order              *int     `json:"order,omitempty"`
				OriginalName       *string  `json:"original_name,omitempty"`
				Popularity         *float32 `json:"popularity,omitempty"`
				ProfilePath        *string  `json:"profile_path,omitempty"`
			} `json:"cast,omitempty"`
			Crew *[]struct {
				Adult              *bool    `json:"adult,omitempty"`
				CreditID           *string  `json:"credit_id,omitempty"`
				Department         *string  `json:"department,omitempty"`
				Gender             *int     `json:"gender,omitempty"`
				ID                 *int     `json:"id,omitempty"`
				Job                *string  `json:"job,omitempty"`
				KnownForDepartment *string  `json:"known_for_department,omitempty"`
				Name               *string  `json:"name,omitempty"`
				OriginalName       *string  `json:"original_name,omitempty"`
				Popularity         *float32 `json:"popularity,omitempty"`
				ProfilePath        *string  `json:"profile_path,omitempty"`
			} `json:"crew,omitempty"`
			ID *int `json:"id,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseMovieExternalIdsResponse parses an HTTP response from a MovieExternalIdsWithResponse call
func ParseMovieExternalIdsResponse(rsp *http.Response) (*MovieExternalIdsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MovieExternalIdsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			FacebookID  *string      `json:"facebook_id,omitempty"`
			ID          *int         `json:"id,omitempty"`
			ImdbID      *string      `json:"imdb_id,omitempty"`
			InstagramID *interface{} `json:"instagram_id,omitempty"`
			TwitterID   *interface{} `json:"twitter_id,omitempty"`
			WikidataID  *interface{} `json:"wikidata_id,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseMovieImagesResponse parses an HTTP response from a MovieImagesWithResponse call
func ParseMovieImagesResponse(rsp *http.Response) (*MovieImagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MovieImagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Backdrops *[]struct {
				AspectRatio *float32     `json:"aspect_ratio,omitempty"`
				FilePath    *string      `json:"file_path,omitempty"`
				Height      *int         `json:"height,omitempty"`
				Iso6391     *interface{} `json:"iso_639_1,omitempty"`
				VoteAverage *float32     `json:"vote_average,omitempty"`
				VoteCount   *int         `json:"vote_count,omitempty"`
				Width       *int         `json:"width,omitempty"`
			} `json:"backdrops,omitempty"`
			ID    *int `json:"id,omitempty"`
			Logos *[]struct {
				AspectRatio *float32 `json:"aspect_ratio,omitempty"`
				FilePath    *string  `json:"file_path,omitempty"`
				Height      *int     `json:"height,omitempty"`
				Iso6391     *string  `json:"iso_639_1,omitempty"`
				VoteAverage *float32 `json:"vote_average,omitempty"`
				VoteCount   *int     `json:"vote_count,omitempty"`
				Width       *int     `json:"width,omitempty"`
			} `json:"logos,omitempty"`
			Posters *[]struct {
				AspectRatio *float32 `json:"aspect_ratio,omitempty"`
				FilePath    *string  `json:"file_path,omitempty"`
				Height      *int     `json:"height,omitempty"`
				Iso6391     *string  `json:"iso_639_1,omitempty"`
				VoteAverage *float32 `json:"vote_average,omitempty"`
				VoteCount   *int     `json:"vote_count,omitempty"`
				Width       *int     `json:"width,omitempty"`
			} `json:"posters,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseMovieKeywordsResponse parses an HTTP response from a MovieKeywordsWithResponse call
func ParseMovieKeywordsResponse(rsp *http.Response) (*MovieKeywordsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MovieKeywordsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			ID       *int `json:"id,omitempty"`
			Keywords *[]struct {
				ID   *int    `json:"id,omitempty"`
				Name *string `json:"name,omitempty"`
			} `json:"keywords,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseMovieListsResponse parses an HTTP response from a MovieListsWithResponse call
func ParseMovieListsResponse(rsp *http.Response) (*MovieListsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MovieListsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			ID      *int `json:"id,omitempty"`
			Page    *int `json:"page,omitempty"`
			Results *[]struct {
				Description   *string      `json:"description,omitempty"`
				FavoriteCount *int         `json:"favorite_count,omitempty"`
				ID            *int         `json:"id,omitempty"`
				Iso6391       *string      `json:"iso_639_1,omitempty"`
				ItemCount     *int         `json:"item_count,omitempty"`
				ListType      *string      `json:"list_type,omitempty"`
				Name          *string      `json:"name,omitempty"`
				PosterPath    *interface{} `json:"poster_path,omitempty"`
			} `json:"results,omitempty"`
			TotalPages   *int `json:"total_pages,omitempty"`
			TotalResults *int `json:"total_results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseMovieDeleteRatingResponse parses an HTTP response from a MovieDeleteRatingWithResponse call
func ParseMovieDeleteRatingResponse(rsp *http.Response) (*MovieDeleteRatingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MovieDeleteRatingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			StatusCode    *int    `json:"status_code,omitempty"`
			StatusMessage *string `json:"status_message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseMovieAddRatingResponse parses an HTTP response from a MovieAddRatingWithResponse call
func ParseMovieAddRatingResponse(rsp *http.Response) (*MovieAddRatingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MovieAddRatingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			StatusCode    *int    `json:"status_code,omitempty"`
			StatusMessage *string `json:"status_message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseMovieRecommendationsResponse parses an HTTP response from a MovieRecommendationsWithResponse call
func ParseMovieRecommendationsResponse(rsp *http.Response) (*MovieRecommendationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MovieRecommendationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseMovieReleaseDatesResponse parses an HTTP response from a MovieReleaseDatesWithResponse call
func ParseMovieReleaseDatesResponse(rsp *http.Response) (*MovieReleaseDatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MovieReleaseDatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			ID      *int `json:"id,omitempty"`
			Results *[]struct {
				Iso31661     *string `json:"iso_3166_1,omitempty"`
				ReleaseDates *[]struct {
					Certification *string        `json:"certification,omitempty"`
					Descriptors   *[]interface{} `json:"descriptors,omitempty"`
					Iso6391       *string        `json:"iso_639_1,omitempty"`
					Note          *string        `json:"note,omitempty"`
					ReleaseDate   *string        `json:"release_date,omitempty"`
					Type          *int           `json:"type,omitempty"`
				} `json:"release_dates,omitempty"`
			} `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseMovieReviewsResponse parses an HTTP response from a MovieReviewsWithResponse call
func ParseMovieReviewsResponse(rsp *http.Response) (*MovieReviewsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MovieReviewsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			ID      *int `json:"id,omitempty"`
			Page    *int `json:"page,omitempty"`
			Results *[]struct {
				Author        *string `json:"author,omitempty"`
				AuthorDetails *struct {
					AvatarPath *string      `json:"avatar_path,omitempty"`
					Name       *string      `json:"name,omitempty"`
					Rating     *interface{} `json:"rating,omitempty"`
					Username   *string      `json:"username,omitempty"`
				} `json:"author_details,omitempty"`
				Content   *string `json:"content,omitempty"`
				CreatedAt *string `json:"created_at,omitempty"`
				ID        *string `json:"id,omitempty"`
				UpdatedAt *string `json:"updated_at,omitempty"`
				URL       *string `json:"url,omitempty"`
			} `json:"results,omitempty"`
			TotalPages   *int `json:"total_pages,omitempty"`
			TotalResults *int `json:"total_results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseMovieSimilarResponse parses an HTTP response from a MovieSimilarWithResponse call
func ParseMovieSimilarResponse(rsp *http.Response) (*MovieSimilarResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MovieSimilarResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Page    *int `json:"page,omitempty"`
			Results *[]struct {
				Adult            *bool    `json:"adult,omitempty"`
				BackdropPath     *string  `json:"backdrop_path,omitempty"`
				GenreIds         *[]int   `json:"genre_ids,omitempty"`
				ID               *int     `json:"id,omitempty"`
				OriginalLanguage *string  `json:"original_language,omitempty"`
				OriginalTitle    *string  `json:"original_title,omitempty"`
				Overview         *string  `json:"overview,omitempty"`
				Popularity       *float32 `json:"popularity,omitempty"`
				PosterPath       *string  `json:"poster_path,omitempty"`
				ReleaseDate      *string  `json:"release_date,omitempty"`
				Title            *string  `json:"title,omitempty"`
				Video            *bool    `json:"video,omitempty"`
				VoteAverage      *float32 `json:"vote_average,omitempty"`
				VoteCount        *int     `json:"vote_count,omitempty"`
			} `json:"results,omitempty"`
			TotalPages   *int `json:"total_pages,omitempty"`
			TotalResults *int `json:"total_results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseMovieTranslationsResponse parses an HTTP response from a MovieTranslationsWithResponse call
func ParseMovieTranslationsResponse(rsp *http.Response) (*MovieTranslationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MovieTranslationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			ID           *int `json:"id,omitempty"`
			Translations *[]struct {
				Data *struct {
					Homepage *string `json:"homepage,omitempty"`
					Overview *string `json:"overview,omitempty"`
					Runtime  *int    `json:"runtime,omitempty"`
					Tagline  *string `json:"tagline,omitempty"`
					Title    *string `json:"title,omitempty"`
				} `json:"data,omitempty"`
				EnglishName *string `json:"english_name,omitempty"`
				Iso31661    *string `json:"iso_3166_1,omitempty"`
				Iso6391     *string `json:"iso_639_1,omitempty"`
				Name        *string `json:"name,omitempty"`
			} `json:"translations,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseMovieVideosResponse parses an HTTP response from a MovieVideosWithResponse call
func ParseMovieVideosResponse(rsp *http.Response) (*MovieVideosResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MovieVideosResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			ID      *int `json:"id,omitempty"`
			Results *[]struct {
				ID          *string `json:"id,omitempty"`
				Iso31661    *string `json:"iso_3166_1,omitempty"`
				Iso6391     *string `json:"iso_639_1,omitempty"`
				Key         *string `json:"key,omitempty"`
				Name        *string `json:"name,omitempty"`
				Official    *bool   `json:"official,omitempty"`
				PublishedAt *string `json:"published_at,omitempty"`
				Site        *string `json:"site,omitempty"`
				Size        *int    `json:"size,omitempty"`
				Type        *string `json:"type,omitempty"`
			} `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseMovieWatchProvidersResponse parses an HTTP response from a MovieWatchProvidersWithResponse call
func ParseMovieWatchProvidersResponse(rsp *http.Response) (*MovieWatchProvidersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MovieWatchProvidersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			ID      *int `json:"id,omitempty"`
			Results *struct {
				AE *struct {
					Buy *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"buy,omitempty"`
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
					Rent *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"rent,omitempty"`
				} `json:"AE,omitempty"`
				AL *struct {
					Buy *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"buy,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"AL,omitempty"`
				AR *struct {
					Buy *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"buy,omitempty"`
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
					Rent *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"rent,omitempty"`
				} `json:"AR,omitempty"`
				AT *struct {
					Buy *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"buy,omitempty"`
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
					Rent *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"rent,omitempty"`
				} `json:"AT,omitempty"`
				AU *struct {
					Buy *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"buy,omitempty"`
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"AU,omitempty"`
				BA *struct {
					Buy *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"buy,omitempty"`
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"BA,omitempty"`
				BB *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"BB,omitempty"`
				BE *struct {
					Buy *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"buy,omitempty"`
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
					Rent *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"rent,omitempty"`
				} `json:"BE,omitempty"`
				BG *struct {
					Buy *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"buy,omitempty"`
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
					Rent *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"rent,omitempty"`
				} `json:"BG,omitempty"`
				BH *struct {
					Buy *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"buy,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"BH,omitempty"`
				BO *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"BO,omitempty"`
				BR *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"BR,omitempty"`
				BS *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"BS,omitempty"`
				CA *struct {
					Buy *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"buy,omitempty"`
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
					Rent *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"rent,omitempty"`
				} `json:"CA,omitempty"`
				CH *struct {
					Buy *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"buy,omitempty"`
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
					Rent *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"rent,omitempty"`
				} `json:"CH,omitempty"`
				CL *struct {
					Buy *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"buy,omitempty"`
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
					Rent *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"rent,omitempty"`
				} `json:"CL,omitempty"`
				CO *struct {
					Buy *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"buy,omitempty"`
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
					Rent *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"rent,omitempty"`
				} `json:"CO,omitempty"`
				CR *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"CR,omitempty"`
				CV *struct {
					Buy *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"buy,omitempty"`
					Link *string `json:"link,omitempty"`
					Rent *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"rent,omitempty"`
				} `json:"CV,omitempty"`
				CZ *struct {
					Buy *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"buy,omitempty"`
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
					Rent *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"rent,omitempty"`
				} `json:"CZ,omitempty"`
				DE *struct {
					Buy *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"buy,omitempty"`
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
					Rent *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"rent,omitempty"`
				} `json:"DE,omitempty"`
				DK *struct {
					Buy *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"buy,omitempty"`
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
					Rent *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"rent,omitempty"`
				} `json:"DK,omitempty"`
				DO *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"DO,omitempty"`
				EC *struct {
					Buy *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"buy,omitempty"`
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
					Rent *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"rent,omitempty"`
				} `json:"EC,omitempty"`
				EE *struct {
					Buy *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"buy,omitempty"`
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
					Rent *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"rent,omitempty"`
				} `json:"EE,omitempty"`
				EG *struct {
					Buy *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"buy,omitempty"`
					Link *string `json:"link,omitempty"`
					Rent *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"rent,omitempty"`
				} `json:"EG,omitempty"`
				ES *struct {
					Ads *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"ads,omitempty"`
					Buy *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"buy,omitempty"`
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
					Rent *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"rent,omitempty"`
				} `json:"ES,omitempty"`
				FI *struct {
					Buy *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"buy,omitempty"`
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
					Rent *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"rent,omitempty"`
				} `json:"FI,omitempty"`
				FJ *struct {
					Buy *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"buy,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"FJ,omitempty"`
				FR *struct {
					Buy *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"buy,omitempty"`
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
					Rent *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"rent,omitempty"`
				} `json:"FR,omitempty"`
				GB *struct {
					Buy *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"buy,omitempty"`
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
					Rent *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"rent,omitempty"`
				} `json:"GB,omitempty"`
				GF *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"GF,omitempty"`
				GI *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"GI,omitempty"`
				GR *struct {
					Buy *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"buy,omitempty"`
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
					Rent *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"rent,omitempty"`
				} `json:"GR,omitempty"`
				GT *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"GT,omitempty"`
				HK *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"HK,omitempty"`
				HN *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"HN,omitempty"`
				HR *struct {
					Ads *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"ads,omitempty"`
					Buy *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"buy,omitempty"`
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"HR,omitempty"`
				HU *struct {
					Buy *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"buy,omitempty"`
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
					Rent *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"rent,omitempty"`
				} `json:"HU,omitempty"`
				ID *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"ID,omitempty"`
				IE *struct {
					Buy *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"buy,omitempty"`
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
					Rent *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"rent,omitempty"`
				} `json:"IE,omitempty"`
				IL *struct {
					Buy *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"buy,omitempty"`
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"IL,omitempty"`
				IN *struct {
					Buy *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"buy,omitempty"`
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
					Rent *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"rent,omitempty"`
				} `json:"IN,omitempty"`
				IQ *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"IQ,omitempty"`
				IS *struct {
					Buy *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"buy,omitempty"`
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"IS,omitempty"`
				IT *struct {
					Buy *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"buy,omitempty"`
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
					Rent *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"rent,omitempty"`
				} `json:"IT,omitempty"`
				JM *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"JM,omitempty"`
				JO *struct {
					Buy *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"buy,omitempty"`
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"JO,omitempty"`
				JP *struct {
					Buy *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"buy,omitempty"`
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
					Rent *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"rent,omitempty"`
				} `json:"JP,omitempty"`
				KR *struct {
					Buy *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"buy,omitempty"`
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"KR,omitempty"`
				KW *struct {
					Buy *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"buy,omitempty"`
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"KW,omitempty"`
				LB *struct {
					Buy *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"buy,omitempty"`
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"LB,omitempty"`
				LI *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"LI,omitempty"`
				LT *struct {
					Buy *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"buy,omitempty"`
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
					Rent *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"rent,omitempty"`
				} `json:"LT,omitempty"`
				LV *struct {
					Buy *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"buy,omitempty"`
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"LV,omitempty"`
				MD *struct {
					Buy *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"buy,omitempty"`
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"MD,omitempty"`
				MK *struct {
					Buy *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"buy,omitempty"`
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"MK,omitempty"`
				MT *struct {
					Buy *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"buy,omitempty"`
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
					Rent *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"rent,omitempty"`
				} `json:"MT,omitempty"`
				MU *struct {
					Buy *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"buy,omitempty"`
					Link *string `json:"link,omitempty"`
					Rent *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"rent,omitempty"`
				} `json:"MU,omitempty"`
				MX *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"MX,omitempty"`
				MY *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"MY,omitempty"`
				MZ *struct {
					Buy *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"buy,omitempty"`
					Link *string `json:"link,omitempty"`
					Rent *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"rent,omitempty"`
				} `json:"MZ,omitempty"`
				NL *struct {
					Buy *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"buy,omitempty"`
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
					Rent *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"rent,omitempty"`
				} `json:"NL,omitempty"`
				NO *struct {
					Buy *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"buy,omitempty"`
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
					Rent *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"rent,omitempty"`
				} `json:"NO,omitempty"`
				NZ *struct {
					Buy *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"buy,omitempty"`
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"NZ,omitempty"`
				OM *struct {
					Buy *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"buy,omitempty"`
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
					Rent *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"rent,omitempty"`
				} `json:"OM,omitempty"`
				PA *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"PA,omitempty"`
				PE *struct {
					Buy *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"buy,omitempty"`
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
					Rent *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"rent,omitempty"`
				} `json:"PE,omitempty"`
				PH *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"PH,omitempty"`
				PK *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"PK,omitempty"`
				PL *struct {
					Buy *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"buy,omitempty"`
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
					Rent *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"rent,omitempty"`
				} `json:"PL,omitempty"`
				PS *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"PS,omitempty"`
				PT *struct {
					Buy *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"buy,omitempty"`
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
					Rent *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"rent,omitempty"`
				} `json:"PT,omitempty"`
				PY *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"PY,omitempty"`
				QA *struct {
					Buy *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"buy,omitempty"`
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"QA,omitempty"`
				RO *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"RO,omitempty"`
				RS *struct {
					Buy *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"buy,omitempty"`
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"RS,omitempty"`
				RU *struct {
					Buy *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"buy,omitempty"`
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
					Rent *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"rent,omitempty"`
				} `json:"RU,omitempty"`
				SA *struct {
					Buy *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"buy,omitempty"`
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
					Rent *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"rent,omitempty"`
				} `json:"SA,omitempty"`
				SE *struct {
					Buy *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"buy,omitempty"`
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
					Rent *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"rent,omitempty"`
				} `json:"SE,omitempty"`
				SG *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"SG,omitempty"`
				SI *struct {
					Buy *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"buy,omitempty"`
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"SI,omitempty"`
				SK *struct {
					Buy *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"buy,omitempty"`
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
					Rent *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"rent,omitempty"`
				} `json:"SK,omitempty"`
				SM *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"SM,omitempty"`
				SV *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"SV,omitempty"`
				TH *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"TH,omitempty"`
				TR *struct {
					Buy *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"buy,omitempty"`
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
					Rent *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"rent,omitempty"`
				} `json:"TR,omitempty"`
				TT *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"TT,omitempty"`
				TW *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"TW,omitempty"`
				UG *struct {
					Buy *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"buy,omitempty"`
					Link *string `json:"link,omitempty"`
					Rent *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"rent,omitempty"`
				} `json:"UG,omitempty"`
				US *struct {
					Buy *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"buy,omitempty"`
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
					Rent *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"rent,omitempty"`
				} `json:"US,omitempty"`
				UY *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"UY,omitempty"`
				VE *struct {
					Buy *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"buy,omitempty"`
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
					Rent *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"rent,omitempty"`
				} `json:"VE,omitempty"`
				YE *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"YE,omitempty"`
				ZA *struct {
					Buy *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"buy,omitempty"`
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
					Rent *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"rent,omitempty"`
				} `json:"ZA,omitempty"`
			} `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseNetworkDetailsResponse parses an HTTP response from a NetworkDetailsWithResponse call
func ParseNetworkDetailsResponse(rsp *http.Response) (*NetworkDetailsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NetworkDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Headquarters  *string `json:"headquarters,omitempty"`
			Homepage      *string `json:"homepage,omitempty"`
			ID            *int    `json:"id,omitempty"`
			LogoPath      *string `json:"logo_path,omitempty"`
			Name          *string `json:"name,omitempty"`
			OriginCountry *string `json:"origin_country,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDetailsCopyResponse parses an HTTP response from a DetailsCopyWithResponse call
func ParseDetailsCopyResponse(rsp *http.Response) (*DetailsCopyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DetailsCopyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			ID      *int `json:"id,omitempty"`
			Results *[]struct {
				Name *string `json:"name,omitempty"`
				Type *string `json:"type,omitempty"`
			} `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAlternativeNamesCopyResponse parses an HTTP response from a AlternativeNamesCopyWithResponse call
func ParseAlternativeNamesCopyResponse(rsp *http.Response) (*AlternativeNamesCopyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AlternativeNamesCopyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			ID    *int `json:"id,omitempty"`
			Logos *[]struct {
				AspectRatio *float32 `json:"aspect_ratio,omitempty"`
				FilePath    *string  `json:"file_path,omitempty"`
				FileType    *string  `json:"file_type,omitempty"`
				Height      *int     `json:"height,omitempty"`
				ID          *string  `json:"id,omitempty"`
				VoteAverage *float32 `json:"vote_average,omitempty"`
				VoteCount   *int     `json:"vote_count,omitempty"`
				Width       *int     `json:"width,omitempty"`
			} `json:"logos,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseChangesPeopleListResponse parses an HTTP response from a ChangesPeopleListWithResponse call
func ParseChangesPeopleListResponse(rsp *http.Response) (*ChangesPeopleListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ChangesPeopleListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Page    *int `json:"page,omitempty"`
			Results *[]struct {
				Adult *bool `json:"adult,omitempty"`
				ID    *int  `json:"id,omitempty"`
			} `json:"results,omitempty"`
			TotalPages   *int `json:"total_pages,omitempty"`
			TotalResults *int `json:"total_results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePersonLatestIDResponse parses an HTTP response from a PersonLatestIDWithResponse call
func ParsePersonLatestIDResponse(rsp *http.Response) (*PersonLatestIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersonLatestIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Adult              *bool          `json:"adult,omitempty"`
			AlsoKnownAs        *[]interface{} `json:"also_known_as,omitempty"`
			Biography          *string        `json:"biography,omitempty"`
			Birthday           *interface{}   `json:"birthday,omitempty"`
			Deathday           *interface{}   `json:"deathday,omitempty"`
			Gender             *int           `json:"gender,omitempty"`
			Homepage           *interface{}   `json:"homepage,omitempty"`
			ID                 *int           `json:"id,omitempty"`
			ImdbID             *interface{}   `json:"imdb_id,omitempty"`
			KnownForDepartment *interface{}   `json:"known_for_department,omitempty"`
			Name               *string        `json:"name,omitempty"`
			PlaceOfBirth       *interface{}   `json:"place_of_birth,omitempty"`
			Popularity         *int           `json:"popularity,omitempty"`
			ProfilePath        *interface{}   `json:"profile_path,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePersonPopularListResponse parses an HTTP response from a PersonPopularListWithResponse call
func ParsePersonPopularListResponse(rsp *http.Response) (*PersonPopularListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersonPopularListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Page    *int `json:"page,omitempty"`
			Results *[]struct {
				Adult    *bool `json:"adult,omitempty"`
				Gender   *int  `json:"gender,omitempty"`
				ID       *int  `json:"id,omitempty"`
				KnownFor *[]struct {
					Adult            *bool    `json:"adult,omitempty"`
					BackdropPath     *string  `json:"backdrop_path,omitempty"`
					GenreIds         *[]int   `json:"genre_ids,omitempty"`
					ID               *int     `json:"id,omitempty"`
					MediaType        *string  `json:"media_type,omitempty"`
					OriginalLanguage *string  `json:"original_language,omitempty"`
					OriginalTitle    *string  `json:"original_title,omitempty"`
					Overview         *string  `json:"overview,omitempty"`
					PosterPath       *string  `json:"poster_path,omitempty"`
					ReleaseDate      *string  `json:"release_date,omitempty"`
					Title            *string  `json:"title,omitempty"`
					Video            *bool    `json:"video,omitempty"`
					VoteAverage      *float32 `json:"vote_average,omitempty"`
					VoteCount        *int     `json:"vote_count,omitempty"`
				} `json:"known_for,omitempty"`
				KnownForDepartment *string  `json:"known_for_department,omitempty"`
				Name               *string  `json:"name,omitempty"`
				Popularity         *float32 `json:"popularity,omitempty"`
				ProfilePath        *string  `json:"profile_path,omitempty"`
			} `json:"results,omitempty"`
			TotalPages   *int `json:"total_pages,omitempty"`
			TotalResults *int `json:"total_results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePersonDetailsResponse parses an HTTP response from a PersonDetailsWithResponse call
func ParsePersonDetailsResponse(rsp *http.Response) (*PersonDetailsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersonDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Adult              *bool        `json:"adult,omitempty"`
			AlsoKnownAs        *[]string    `json:"also_known_as,omitempty"`
			Biography          *string      `json:"biography,omitempty"`
			Birthday           *string      `json:"birthday,omitempty"`
			Deathday           *interface{} `json:"deathday,omitempty"`
			Gender             *int         `json:"gender,omitempty"`
			Homepage           *interface{} `json:"homepage,omitempty"`
			ID                 *int         `json:"id,omitempty"`
			ImdbID             *string      `json:"imdb_id,omitempty"`
			KnownForDepartment *string      `json:"known_for_department,omitempty"`
			Name               *string      `json:"name,omitempty"`
			PlaceOfBirth       *string      `json:"place_of_birth,omitempty"`
			Popularity         *float32     `json:"popularity,omitempty"`
			ProfilePath        *string      `json:"profile_path,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePersonChangesResponse parses an HTTP response from a PersonChangesWithResponse call
func ParsePersonChangesResponse(rsp *http.Response) (*PersonChangesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersonChangesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Changes *[]struct {
				Items *[]struct {
					Action   *string `json:"action,omitempty"`
					ID       *string `json:"id,omitempty"`
					Iso31661 *string `json:"iso_3166_1,omitempty"`
					Iso6391  *string `json:"iso_639_1,omitempty"`
					Time     *string `json:"time,omitempty"`
					Value    *string `json:"value,omitempty"`
				} `json:"items,omitempty"`
				Key *string `json:"key,omitempty"`
			} `json:"changes,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePersonCombinedCreditsResponse parses an HTTP response from a PersonCombinedCreditsWithResponse call
func ParsePersonCombinedCreditsResponse(rsp *http.Response) (*PersonCombinedCreditsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersonCombinedCreditsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Cast *[]struct {
				Adult            *bool    `json:"adult,omitempty"`
				BackdropPath     *string  `json:"backdrop_path,omitempty"`
				Character        *string  `json:"character,omitempty"`
				CreditID         *string  `json:"credit_id,omitempty"`
				GenreIds         *[]int   `json:"genre_ids,omitempty"`
				ID               *int     `json:"id,omitempty"`
				MediaType        *string  `json:"media_type,omitempty"`
				Order            *int     `json:"order,omitempty"`
				OriginalLanguage *string  `json:"original_language,omitempty"`
				OriginalTitle    *string  `json:"original_title,omitempty"`
				Overview         *string  `json:"overview,omitempty"`
				Popularity       *float32 `json:"popularity,omitempty"`
				PosterPath       *string  `json:"poster_path,omitempty"`
				ReleaseDate      *string  `json:"release_date,omitempty"`
				Title            *string  `json:"title,omitempty"`
				Video            *bool    `json:"video,omitempty"`
				VoteAverage      *float32 `json:"vote_average,omitempty"`
				VoteCount        *int     `json:"vote_count,omitempty"`
			} `json:"cast,omitempty"`
			Crew *[]struct {
				Adult            *bool    `json:"adult,omitempty"`
				BackdropPath     *string  `json:"backdrop_path,omitempty"`
				CreditID         *string  `json:"credit_id,omitempty"`
				Department       *string  `json:"department,omitempty"`
				GenreIds         *[]int   `json:"genre_ids,omitempty"`
				ID               *int     `json:"id,omitempty"`
				Job              *string  `json:"job,omitempty"`
				MediaType        *string  `json:"media_type,omitempty"`
				OriginalLanguage *string  `json:"original_language,omitempty"`
				OriginalTitle    *string  `json:"original_title,omitempty"`
				Overview         *string  `json:"overview,omitempty"`
				Popularity       *float32 `json:"popularity,omitempty"`
				PosterPath       *string  `json:"poster_path,omitempty"`
				ReleaseDate      *string  `json:"release_date,omitempty"`
				Title            *string  `json:"title,omitempty"`
				Video            *bool    `json:"video,omitempty"`
				VoteAverage      *float32 `json:"vote_average,omitempty"`
				VoteCount        *int     `json:"vote_count,omitempty"`
			} `json:"crew,omitempty"`
			ID *int `json:"id,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePersonExternalIdsResponse parses an HTTP response from a PersonExternalIdsWithResponse call
func ParsePersonExternalIdsResponse(rsp *http.Response) (*PersonExternalIdsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersonExternalIdsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			FacebookID  *string      `json:"facebook_id,omitempty"`
			FreebaseID  *string      `json:"freebase_id,omitempty"`
			FreebaseMid *string      `json:"freebase_mid,omitempty"`
			ID          *int         `json:"id,omitempty"`
			ImdbID      *string      `json:"imdb_id,omitempty"`
			InstagramID *string      `json:"instagram_id,omitempty"`
			TiktokID    *string      `json:"tiktok_id,omitempty"`
			TvrageID    *int         `json:"tvrage_id,omitempty"`
			TwitterID   *string      `json:"twitter_id,omitempty"`
			WikidataID  *string      `json:"wikidata_id,omitempty"`
			YoutubeID   *interface{} `json:"youtube_id,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePersonImagesResponse parses an HTTP response from a PersonImagesWithResponse call
func ParsePersonImagesResponse(rsp *http.Response) (*PersonImagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersonImagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			ID       *int `json:"id,omitempty"`
			Profiles *[]struct {
				AspectRatio *float32     `json:"aspect_ratio,omitempty"`
				FilePath    *string      `json:"file_path,omitempty"`
				Height      *int         `json:"height,omitempty"`
				Iso6391     *interface{} `json:"iso_639_1,omitempty"`
				VoteAverage *float32     `json:"vote_average,omitempty"`
				VoteCount   *int         `json:"vote_count,omitempty"`
				Width       *int         `json:"width,omitempty"`
			} `json:"profiles,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePersonMovieCreditsResponse parses an HTTP response from a PersonMovieCreditsWithResponse call
func ParsePersonMovieCreditsResponse(rsp *http.Response) (*PersonMovieCreditsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersonMovieCreditsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Cast *[]struct {
				Adult            *bool    `json:"adult,omitempty"`
				BackdropPath     *string  `json:"backdrop_path,omitempty"`
				Character        *string  `json:"character,omitempty"`
				CreditID         *string  `json:"credit_id,omitempty"`
				GenreIds         *[]int   `json:"genre_ids,omitempty"`
				ID               *int     `json:"id,omitempty"`
				Order            *int     `json:"order,omitempty"`
				OriginalLanguage *string  `json:"original_language,omitempty"`
				OriginalTitle    *string  `json:"original_title,omitempty"`
				Overview         *string  `json:"overview,omitempty"`
				Popularity       *float32 `json:"popularity,omitempty"`
				PosterPath       *string  `json:"poster_path,omitempty"`
				ReleaseDate      *string  `json:"release_date,omitempty"`
				Title            *string  `json:"title,omitempty"`
				Video            *bool    `json:"video,omitempty"`
				VoteAverage      *float32 `json:"vote_average,omitempty"`
				VoteCount        *int     `json:"vote_count,omitempty"`
			} `json:"cast,omitempty"`
			Crew *[]struct {
				Adult            *bool    `json:"adult,omitempty"`
				BackdropPath     *string  `json:"backdrop_path,omitempty"`
				CreditID         *string  `json:"credit_id,omitempty"`
				Department       *string  `json:"department,omitempty"`
				GenreIds         *[]int   `json:"genre_ids,omitempty"`
				ID               *int     `json:"id,omitempty"`
				Job              *string  `json:"job,omitempty"`
				OriginalLanguage *string  `json:"original_language,omitempty"`
				OriginalTitle    *string  `json:"original_title,omitempty"`
				Overview         *string  `json:"overview,omitempty"`
				Popularity       *float32 `json:"popularity,omitempty"`
				PosterPath       *string  `json:"poster_path,omitempty"`
				ReleaseDate      *string  `json:"release_date,omitempty"`
				Title            *string  `json:"title,omitempty"`
				Video            *bool    `json:"video,omitempty"`
				VoteAverage      *float32 `json:"vote_average,omitempty"`
				VoteCount        *int     `json:"vote_count,omitempty"`
			} `json:"crew,omitempty"`
			ID *int `json:"id,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePersonTaggedImagesResponse parses an HTTP response from a PersonTaggedImagesWithResponse call
func ParsePersonTaggedImagesResponse(rsp *http.Response) (*PersonTaggedImagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersonTaggedImagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			ID      *int `json:"id,omitempty"`
			Page    *int `json:"page,omitempty"`
			Results *[]struct {
				AspectRatio *float32 `json:"aspect_ratio,omitempty"`
				FilePath    *string  `json:"file_path,omitempty"`
				Height      *int     `json:"height,omitempty"`
				ID          *string  `json:"id,omitempty"`
				ImageType   *string  `json:"image_type,omitempty"`
				Iso6391     *string  `json:"iso_639_1,omitempty"`
				Media       *struct {
					Adult            *bool    `json:"adult,omitempty"`
					BackdropPath     *string  `json:"backdrop_path,omitempty"`
					GenreIds         *[]int   `json:"genre_ids,omitempty"`
					ID               *int     `json:"id,omitempty"`
					MediaType        *string  `json:"media_type,omitempty"`
					OriginalLanguage *string  `json:"original_language,omitempty"`
					OriginalTitle    *string  `json:"original_title,omitempty"`
					Overview         *string  `json:"overview,omitempty"`
					Popularity       *float32 `json:"popularity,omitempty"`
					PosterPath       *string  `json:"poster_path,omitempty"`
					ReleaseDate      *string  `json:"release_date,omitempty"`
					Title            *string  `json:"title,omitempty"`
					Video            *bool    `json:"video,omitempty"`
					VoteAverage      *float32 `json:"vote_average,omitempty"`
					VoteCount        *int     `json:"vote_count,omitempty"`
				} `json:"media,omitempty"`
				MediaType   *string  `json:"media_type,omitempty"`
				VoteAverage *float32 `json:"vote_average,omitempty"`
				VoteCount   *int     `json:"vote_count,omitempty"`
				Width       *int     `json:"width,omitempty"`
			} `json:"results,omitempty"`
			TotalPages   *int `json:"total_pages,omitempty"`
			TotalResults *int `json:"total_results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTranslationsResponse parses an HTTP response from a TranslationsWithResponse call
func ParseTranslationsResponse(rsp *http.Response) (*TranslationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TranslationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			ID           *int `json:"id,omitempty"`
			Translations *[]struct {
				Data *struct {
					Biography *string `json:"biography,omitempty"`
				} `json:"data,omitempty"`
				EnglishName *string `json:"english_name,omitempty"`
				Iso31661    *string `json:"iso_3166_1,omitempty"`
				Iso6391     *string `json:"iso_639_1,omitempty"`
				Name        *string `json:"name,omitempty"`
			} `json:"translations,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePersonTvCreditsResponse parses an HTTP response from a PersonTvCreditsWithResponse call
func ParsePersonTvCreditsResponse(rsp *http.Response) (*PersonTvCreditsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersonTvCreditsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Cast *[]struct {
				Adult            *bool     `json:"adult,omitempty"`
				BackdropPath     *string   `json:"backdrop_path,omitempty"`
				Character        *string   `json:"character,omitempty"`
				CreditID         *string   `json:"credit_id,omitempty"`
				EpisodeCount     *int      `json:"episode_count,omitempty"`
				FirstAirDate     *string   `json:"first_air_date,omitempty"`
				GenreIds         *[]int    `json:"genre_ids,omitempty"`
				ID               *int      `json:"id,omitempty"`
				Name             *string   `json:"name,omitempty"`
				OriginCountry    *[]string `json:"origin_country,omitempty"`
				OriginalLanguage *string   `json:"original_language,omitempty"`
				OriginalName     *string   `json:"original_name,omitempty"`
				Overview         *string   `json:"overview,omitempty"`
				Popularity       *float32  `json:"popularity,omitempty"`
				PosterPath       *string   `json:"poster_path,omitempty"`
				VoteAverage      *float32  `json:"vote_average,omitempty"`
				VoteCount        *int      `json:"vote_count,omitempty"`
			} `json:"cast,omitempty"`
			Crew *[]struct {
				Adult            *bool     `json:"adult,omitempty"`
				BackdropPath     *string   `json:"backdrop_path,omitempty"`
				CreditID         *string   `json:"credit_id,omitempty"`
				Department       *string   `json:"department,omitempty"`
				EpisodeCount     *int      `json:"episode_count,omitempty"`
				FirstAirDate     *string   `json:"first_air_date,omitempty"`
				GenreIds         *[]int    `json:"genre_ids,omitempty"`
				ID               *int      `json:"id,omitempty"`
				Job              *string   `json:"job,omitempty"`
				Name             *string   `json:"name,omitempty"`
				OriginCountry    *[]string `json:"origin_country,omitempty"`
				OriginalLanguage *string   `json:"original_language,omitempty"`
				OriginalName     *string   `json:"original_name,omitempty"`
				Overview         *string   `json:"overview,omitempty"`
				Popularity       *float32  `json:"popularity,omitempty"`
				PosterPath       *string   `json:"poster_path,omitempty"`
				VoteAverage      *float32  `json:"vote_average,omitempty"`
				VoteCount        *int      `json:"vote_count,omitempty"`
			} `json:"crew,omitempty"`
			ID *int `json:"id,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseReviewDetailsResponse parses an HTTP response from a ReviewDetailsWithResponse call
func ParseReviewDetailsResponse(rsp *http.Response) (*ReviewDetailsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReviewDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Author        *string `json:"author,omitempty"`
			AuthorDetails *struct {
				AvatarPath *string `json:"avatar_path,omitempty"`
				Name       *string `json:"name,omitempty"`
				Rating     *int    `json:"rating,omitempty"`
				Username   *string `json:"username,omitempty"`
			} `json:"author_details,omitempty"`
			Content    *string `json:"content,omitempty"`
			CreatedAt  *string `json:"created_at,omitempty"`
			ID         *string `json:"id,omitempty"`
			Iso6391    *string `json:"iso_639_1,omitempty"`
			MediaID    *int    `json:"media_id,omitempty"`
			MediaTitle *string `json:"media_title,omitempty"`
			MediaType  *string `json:"media_type,omitempty"`
			UpdatedAt  *string `json:"updated_at,omitempty"`
			URL        *string `json:"url,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSearchCollectionResponse parses an HTTP response from a SearchCollectionWithResponse call
func ParseSearchCollectionResponse(rsp *http.Response) (*SearchCollectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchCollectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Page    *int `json:"page,omitempty"`
			Results *[]struct {
				Adult            *bool   `json:"adult,omitempty"`
				BackdropPath     *string `json:"backdrop_path,omitempty"`
				ID               *int    `json:"id,omitempty"`
				Name             *string `json:"name,omitempty"`
				OriginalLanguage *string `json:"original_language,omitempty"`
				OriginalName     *string `json:"original_name,omitempty"`
				Overview         *string `json:"overview,omitempty"`
				PosterPath       *string `json:"poster_path,omitempty"`
			} `json:"results,omitempty"`
			TotalPages   *int `json:"total_pages,omitempty"`
			TotalResults *int `json:"total_results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSearchCompanyResponse parses an HTTP response from a SearchCompanyWithResponse call
func ParseSearchCompanyResponse(rsp *http.Response) (*SearchCompanyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchCompanyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Page    *int `json:"page,omitempty"`
			Results *[]struct {
				ID            *int    `json:"id,omitempty"`
				LogoPath      *string `json:"logo_path,omitempty"`
				Name          *string `json:"name,omitempty"`
				OriginCountry *string `json:"origin_country,omitempty"`
			} `json:"results,omitempty"`
			TotalPages   *int `json:"total_pages,omitempty"`
			TotalResults *int `json:"total_results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSearchKeywordResponse parses an HTTP response from a SearchKeywordWithResponse call
func ParseSearchKeywordResponse(rsp *http.Response) (*SearchKeywordResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchKeywordResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Page    *int `json:"page,omitempty"`
			Results *[]struct {
				ID   *int    `json:"id,omitempty"`
				Name *string `json:"name,omitempty"`
			} `json:"results,omitempty"`
			TotalPages   *int `json:"total_pages,omitempty"`
			TotalResults *int `json:"total_results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSearchMovieResponse parses an HTTP response from a SearchMovieWithResponse call
func ParseSearchMovieResponse(rsp *http.Response) (*SearchMovieResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchMovieResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Page    *int `json:"page,omitempty"`
			Results *[]struct {
				Adult            *bool    `json:"adult,omitempty"`
				BackdropPath     *string  `json:"backdrop_path,omitempty"`
				GenreIds         *[]int   `json:"genre_ids,omitempty"`
				ID               *int     `json:"id,omitempty"`
				OriginalLanguage *string  `json:"original_language,omitempty"`
				OriginalTitle    *string  `json:"original_title,omitempty"`
				Overview         *string  `json:"overview,omitempty"`
				Popularity       *float32 `json:"popularity,omitempty"`
				PosterPath       *string  `json:"poster_path,omitempty"`
				ReleaseDate      *string  `json:"release_date,omitempty"`
				Title            *string  `json:"title,omitempty"`
				Video            *bool    `json:"video,omitempty"`
				VoteAverage      *float32 `json:"vote_average,omitempty"`
				VoteCount        *int     `json:"vote_count,omitempty"`
			} `json:"results,omitempty"`
			TotalPages   *int `json:"total_pages,omitempty"`
			TotalResults *int `json:"total_results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSearchMultiResponse parses an HTTP response from a SearchMultiWithResponse call
func ParseSearchMultiResponse(rsp *http.Response) (*SearchMultiResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchMultiResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Page    *int `json:"page,omitempty"`
			Results *[]struct {
				Adult            *bool    `json:"adult,omitempty"`
				BackdropPath     *string  `json:"backdrop_path,omitempty"`
				GenreIds         *[]int   `json:"genre_ids,omitempty"`
				ID               *int     `json:"id,omitempty"`
				MediaType        *string  `json:"media_type,omitempty"`
				OriginalLanguage *string  `json:"original_language,omitempty"`
				OriginalTitle    *string  `json:"original_title,omitempty"`
				Overview         *string  `json:"overview,omitempty"`
				Popularity       *float32 `json:"popularity,omitempty"`
				PosterPath       *string  `json:"poster_path,omitempty"`
				ReleaseDate      *string  `json:"release_date,omitempty"`
				Title            *string  `json:"title,omitempty"`
				Video            *bool    `json:"video,omitempty"`
				VoteAverage      *float32 `json:"vote_average,omitempty"`
				VoteCount        *int     `json:"vote_count,omitempty"`
			} `json:"results,omitempty"`
			TotalPages   *int `json:"total_pages,omitempty"`
			TotalResults *int `json:"total_results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSearchPersonResponse parses an HTTP response from a SearchPersonWithResponse call
func ParseSearchPersonResponse(rsp *http.Response) (*SearchPersonResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchPersonResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Page    *int `json:"page,omitempty"`
			Results *[]struct {
				Adult    *bool `json:"adult,omitempty"`
				Gender   *int  `json:"gender,omitempty"`
				ID       *int  `json:"id,omitempty"`
				KnownFor *[]struct {
					Adult            *bool    `json:"adult,omitempty"`
					BackdropPath     *string  `json:"backdrop_path,omitempty"`
					GenreIds         *[]int   `json:"genre_ids,omitempty"`
					ID               *int     `json:"id,omitempty"`
					MediaType        *string  `json:"media_type,omitempty"`
					OriginalLanguage *string  `json:"original_language,omitempty"`
					OriginalTitle    *string  `json:"original_title,omitempty"`
					Overview         *string  `json:"overview,omitempty"`
					Popularity       *float32 `json:"popularity,omitempty"`
					PosterPath       *string  `json:"poster_path,omitempty"`
					ReleaseDate      *string  `json:"release_date,omitempty"`
					Title            *string  `json:"title,omitempty"`
					Video            *bool    `json:"video,omitempty"`
					VoteAverage      *float32 `json:"vote_average,omitempty"`
					VoteCount        *int     `json:"vote_count,omitempty"`
				} `json:"known_for,omitempty"`
				KnownForDepartment *string  `json:"known_for_department,omitempty"`
				Name               *string  `json:"name,omitempty"`
				OriginalName       *string  `json:"original_name,omitempty"`
				Popularity         *float32 `json:"popularity,omitempty"`
				ProfilePath        *string  `json:"profile_path,omitempty"`
			} `json:"results,omitempty"`
			TotalPages   *int `json:"total_pages,omitempty"`
			TotalResults *int `json:"total_results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSearchTvResponse parses an HTTP response from a SearchTvWithResponse call
func ParseSearchTvResponse(rsp *http.Response) (*SearchTvResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchTvResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Page    *int `json:"page,omitempty"`
			Results *[]struct {
				Adult            *bool     `json:"adult,omitempty"`
				BackdropPath     *string   `json:"backdrop_path,omitempty"`
				FirstAirDate     *string   `json:"first_air_date,omitempty"`
				GenreIds         *[]int    `json:"genre_ids,omitempty"`
				ID               *int      `json:"id,omitempty"`
				Name             *string   `json:"name,omitempty"`
				OriginCountry    *[]string `json:"origin_country,omitempty"`
				OriginalLanguage *string   `json:"original_language,omitempty"`
				OriginalName     *string   `json:"original_name,omitempty"`
				Overview         *string   `json:"overview,omitempty"`
				Popularity       *float32  `json:"popularity,omitempty"`
				PosterPath       *string   `json:"poster_path,omitempty"`
				VoteAverage      *float32  `json:"vote_average,omitempty"`
				VoteCount        *int      `json:"vote_count,omitempty"`
			} `json:"results,omitempty"`
			TotalPages   *int `json:"total_pages,omitempty"`
			TotalResults *int `json:"total_results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTrendingAllResponse parses an HTTP response from a TrendingAllWithResponse call
func ParseTrendingAllResponse(rsp *http.Response) (*TrendingAllResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TrendingAllResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Page    *int `json:"page,omitempty"`
			Results *[]struct {
				Adult            *bool    `json:"adult,omitempty"`
				BackdropPath     *string  `json:"backdrop_path,omitempty"`
				GenreIds         *[]int   `json:"genre_ids,omitempty"`
				ID               *int     `json:"id,omitempty"`
				MediaType        *string  `json:"media_type,omitempty"`
				OriginalLanguage *string  `json:"original_language,omitempty"`
				OriginalTitle    *string  `json:"original_title,omitempty"`
				Overview         *string  `json:"overview,omitempty"`
				Popularity       *float32 `json:"popularity,omitempty"`
				PosterPath       *string  `json:"poster_path,omitempty"`
				ReleaseDate      *string  `json:"release_date,omitempty"`
				Title            *string  `json:"title,omitempty"`
				Video            *bool    `json:"video,omitempty"`
				VoteAverage      *float32 `json:"vote_average,omitempty"`
				VoteCount        *int     `json:"vote_count,omitempty"`
			} `json:"results,omitempty"`
			TotalPages   *int `json:"total_pages,omitempty"`
			TotalResults *int `json:"total_results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTrendingMoviesResponse parses an HTTP response from a TrendingMoviesWithResponse call
func ParseTrendingMoviesResponse(rsp *http.Response) (*TrendingMoviesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TrendingMoviesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Page    *int `json:"page,omitempty"`
			Results *[]struct {
				Adult            *bool    `json:"adult,omitempty"`
				BackdropPath     *string  `json:"backdrop_path,omitempty"`
				GenreIds         *[]int   `json:"genre_ids,omitempty"`
				ID               *int     `json:"id,omitempty"`
				MediaType        *string  `json:"media_type,omitempty"`
				OriginalLanguage *string  `json:"original_language,omitempty"`
				OriginalTitle    *string  `json:"original_title,omitempty"`
				Overview         *string  `json:"overview,omitempty"`
				Popularity       *float32 `json:"popularity,omitempty"`
				PosterPath       *string  `json:"poster_path,omitempty"`
				ReleaseDate      *string  `json:"release_date,omitempty"`
				Title            *string  `json:"title,omitempty"`
				Video            *bool    `json:"video,omitempty"`
				VoteAverage      *float32 `json:"vote_average,omitempty"`
				VoteCount        *int     `json:"vote_count,omitempty"`
			} `json:"results,omitempty"`
			TotalPages   *int `json:"total_pages,omitempty"`
			TotalResults *int `json:"total_results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTrendingPeopleResponse parses an HTTP response from a TrendingPeopleWithResponse call
func ParseTrendingPeopleResponse(rsp *http.Response) (*TrendingPeopleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TrendingPeopleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Page    *int `json:"page,omitempty"`
			Results *[]struct {
				Adult    *bool `json:"adult,omitempty"`
				Gender   *int  `json:"gender,omitempty"`
				ID       *int  `json:"id,omitempty"`
				KnownFor *[]struct {
					Adult            *bool    `json:"adult,omitempty"`
					BackdropPath     *string  `json:"backdrop_path,omitempty"`
					GenreIds         *[]int   `json:"genre_ids,omitempty"`
					ID               *int     `json:"id,omitempty"`
					MediaType        *string  `json:"media_type,omitempty"`
					OriginalLanguage *string  `json:"original_language,omitempty"`
					OriginalTitle    *string  `json:"original_title,omitempty"`
					Overview         *string  `json:"overview,omitempty"`
					Popularity       *float32 `json:"popularity,omitempty"`
					PosterPath       *string  `json:"poster_path,omitempty"`
					ReleaseDate      *string  `json:"release_date,omitempty"`
					Title            *string  `json:"title,omitempty"`
					Video            *bool    `json:"video,omitempty"`
					VoteAverage      *float32 `json:"vote_average,omitempty"`
					VoteCount        *int     `json:"vote_count,omitempty"`
				} `json:"known_for,omitempty"`
				KnownForDepartment *string  `json:"known_for_department,omitempty"`
				MediaType          *string  `json:"media_type,omitempty"`
				Name               *string  `json:"name,omitempty"`
				OriginalName       *string  `json:"original_name,omitempty"`
				Popularity         *float32 `json:"popularity,omitempty"`
				ProfilePath        *string  `json:"profile_path,omitempty"`
			} `json:"results,omitempty"`
			TotalPages   *int `json:"total_pages,omitempty"`
			TotalResults *int `json:"total_results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTrendingTvResponse parses an HTTP response from a TrendingTvWithResponse call
func ParseTrendingTvResponse(rsp *http.Response) (*TrendingTvResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TrendingTvResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Page    *int `json:"page,omitempty"`
			Results *[]struct {
				Adult            *bool     `json:"adult,omitempty"`
				BackdropPath     *string   `json:"backdrop_path,omitempty"`
				FirstAirDate     *string   `json:"first_air_date,omitempty"`
				GenreIds         *[]int    `json:"genre_ids,omitempty"`
				ID               *int      `json:"id,omitempty"`
				MediaType        *string   `json:"media_type,omitempty"`
				Name             *string   `json:"name,omitempty"`
				OriginCountry    *[]string `json:"origin_country,omitempty"`
				OriginalLanguage *string   `json:"original_language,omitempty"`
				OriginalName     *string   `json:"original_name,omitempty"`
				Overview         *string   `json:"overview,omitempty"`
				Popularity       *float32  `json:"popularity,omitempty"`
				PosterPath       *string   `json:"poster_path,omitempty"`
				VoteAverage      *float32  `json:"vote_average,omitempty"`
				VoteCount        *int      `json:"vote_count,omitempty"`
			} `json:"results,omitempty"`
			TotalPages   *int `json:"total_pages,omitempty"`
			TotalResults *int `json:"total_results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTvSeriesAiringTodayListResponse parses an HTTP response from a TvSeriesAiringTodayListWithResponse call
func ParseTvSeriesAiringTodayListResponse(rsp *http.Response) (*TvSeriesAiringTodayListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TvSeriesAiringTodayListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Page    *int `json:"page,omitempty"`
			Results *[]struct {
				BackdropPath     *string   `json:"backdrop_path,omitempty"`
				FirstAirDate     *string   `json:"first_air_date,omitempty"`
				GenreIds         *[]int    `json:"genre_ids,omitempty"`
				ID               *int      `json:"id,omitempty"`
				Name             *string   `json:"name,omitempty"`
				OriginCountry    *[]string `json:"origin_country,omitempty"`
				OriginalLanguage *string   `json:"original_language,omitempty"`
				OriginalName     *string   `json:"original_name,omitempty"`
				Overview         *string   `json:"overview,omitempty"`
				Popularity       *float32  `json:"popularity,omitempty"`
				PosterPath       *string   `json:"poster_path,omitempty"`
				VoteAverage      *int      `json:"vote_average,omitempty"`
				VoteCount        *int      `json:"vote_count,omitempty"`
			} `json:"results,omitempty"`
			TotalPages   *int `json:"total_pages,omitempty"`
			TotalResults *int `json:"total_results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseChangesTvListResponse parses an HTTP response from a ChangesTvListWithResponse call
func ParseChangesTvListResponse(rsp *http.Response) (*ChangesTvListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ChangesTvListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Page    *int `json:"page,omitempty"`
			Results *[]struct {
				Adult *bool `json:"adult,omitempty"`
				ID    *int  `json:"id,omitempty"`
			} `json:"results,omitempty"`
			TotalPages   *int `json:"total_pages,omitempty"`
			TotalResults *int `json:"total_results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTvEpisodeChangesByIDResponse parses an HTTP response from a TvEpisodeChangesByIDWithResponse call
func ParseTvEpisodeChangesByIDResponse(rsp *http.Response) (*TvEpisodeChangesByIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TvEpisodeChangesByIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Changes *[]struct {
				Items *[]struct {
					Action *string `json:"action,omitempty"`
					ID     *string `json:"id,omitempty"`
					Time   *string `json:"time,omitempty"`
					Value  *string `json:"value,omitempty"`
				} `json:"items,omitempty"`
				Key *string `json:"key,omitempty"`
			} `json:"changes,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTvEpisodeGroupDetailsResponse parses an HTTP response from a TvEpisodeGroupDetailsWithResponse call
func ParseTvEpisodeGroupDetailsResponse(rsp *http.Response) (*TvEpisodeGroupDetailsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TvEpisodeGroupDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Description  *string `json:"description,omitempty"`
			EpisodeCount *int    `json:"episode_count,omitempty"`
			GroupCount   *int    `json:"group_count,omitempty"`
			Groups       *[]struct {
				Episodes *[]struct {
					AirDate        *string      `json:"air_date,omitempty"`
					EpisodeNumber  *int         `json:"episode_number,omitempty"`
					ID             *int         `json:"id,omitempty"`
					Name           *string      `json:"name,omitempty"`
					Order          *int         `json:"order,omitempty"`
					Overview       *string      `json:"overview,omitempty"`
					ProductionCode *string      `json:"production_code,omitempty"`
					Runtime        *interface{} `json:"runtime,omitempty"`
					SeasonNumber   *int         `json:"season_number,omitempty"`
					ShowID         *int         `json:"show_id,omitempty"`
					StillPath      *string      `json:"still_path,omitempty"`
					VoteAverage    *float32     `json:"vote_average,omitempty"`
					VoteCount      *int         `json:"vote_count,omitempty"`
				} `json:"episodes,omitempty"`
				ID     *string `json:"id,omitempty"`
				Locked *bool   `json:"locked,omitempty"`
				Name   *string `json:"name,omitempty"`
				Order  *int    `json:"order,omitempty"`
			} `json:"groups,omitempty"`
			ID      *string `json:"id,omitempty"`
			Name    *string `json:"name,omitempty"`
			Network *struct {
				ID            *int    `json:"id,omitempty"`
				LogoPath      *string `json:"logo_path,omitempty"`
				Name          *string `json:"name,omitempty"`
				OriginCountry *string `json:"origin_country,omitempty"`
			} `json:"network,omitempty"`
			Type *int `json:"type,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTvSeriesLatestIDResponse parses an HTTP response from a TvSeriesLatestIDWithResponse call
func ParseTvSeriesLatestIDResponse(rsp *http.Response) (*TvSeriesLatestIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TvSeriesLatestIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Adult            *bool          `json:"adult,omitempty"`
			BackdropPath     *interface{}   `json:"backdrop_path,omitempty"`
			CreatedBy        *[]interface{} `json:"created_by,omitempty"`
			EpisodeRunTime   *[]interface{} `json:"episode_run_time,omitempty"`
			FirstAirDate     *string        `json:"first_air_date,omitempty"`
			Genres           *[]interface{} `json:"genres,omitempty"`
			Homepage         *string        `json:"homepage,omitempty"`
			ID               *int           `json:"id,omitempty"`
			InProduction     *bool          `json:"in_production,omitempty"`
			Languages        *[]interface{} `json:"languages,omitempty"`
			LastAirDate      *string        `json:"last_air_date,omitempty"`
			LastEpisodeToAir *struct {
				AirDate        *string      `json:"air_date,omitempty"`
				EpisodeNumber  *int         `json:"episode_number,omitempty"`
				ID             *int         `json:"id,omitempty"`
				Name           *string      `json:"name,omitempty"`
				Overview       *string      `json:"overview,omitempty"`
				ProductionCode *string      `json:"production_code,omitempty"`
				Runtime        *interface{} `json:"runtime,omitempty"`
				SeasonNumber   *int         `json:"season_number,omitempty"`
				ShowID         *int         `json:"show_id,omitempty"`
				StillPath      *interface{} `json:"still_path,omitempty"`
				VoteAverage    *int         `json:"vote_average,omitempty"`
				VoteCount      *int         `json:"vote_count,omitempty"`
			} `json:"last_episode_to_air,omitempty"`
			Name                *string        `json:"name,omitempty"`
			Networks            *[]interface{} `json:"networks,omitempty"`
			NextEpisodeToAir    *interface{}   `json:"next_episode_to_air,omitempty"`
			NumberOfEpisodes    *int           `json:"number_of_episodes,omitempty"`
			NumberOfSeasons     *int           `json:"number_of_seasons,omitempty"`
			OriginCountry       *[]string      `json:"origin_country,omitempty"`
			OriginalLanguage    *string        `json:"original_language,omitempty"`
			OriginalName        *string        `json:"original_name,omitempty"`
			Overview            *string        `json:"overview,omitempty"`
			Popularity          *int           `json:"popularity,omitempty"`
			PosterPath          *interface{}   `json:"poster_path,omitempty"`
			ProductionCompanies *[]interface{} `json:"production_companies,omitempty"`
			ProductionCountries *[]interface{} `json:"production_countries,omitempty"`
			Seasons             *[]struct {
				AirDate      *interface{} `json:"air_date,omitempty"`
				EpisodeCount *int         `json:"episode_count,omitempty"`
				ID           *int         `json:"id,omitempty"`
				Name         *string      `json:"name,omitempty"`
				Overview     *string      `json:"overview,omitempty"`
				PosterPath   *interface{} `json:"poster_path,omitempty"`
				SeasonNumber *int         `json:"season_number,omitempty"`
			} `json:"seasons,omitempty"`
			SpokenLanguages *[]interface{} `json:"spoken_languages,omitempty"`
			Status          *string        `json:"status,omitempty"`
			Tagline         *string        `json:"tagline,omitempty"`
			Type            *string        `json:"type,omitempty"`
			VoteAverage     *int           `json:"vote_average,omitempty"`
			VoteCount       *int           `json:"vote_count,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTvSeriesOnTheAirListResponse parses an HTTP response from a TvSeriesOnTheAirListWithResponse call
func ParseTvSeriesOnTheAirListResponse(rsp *http.Response) (*TvSeriesOnTheAirListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TvSeriesOnTheAirListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Page    *int `json:"page,omitempty"`
			Results *[]struct {
				BackdropPath     *string   `json:"backdrop_path,omitempty"`
				FirstAirDate     *string   `json:"first_air_date,omitempty"`
				GenreIds         *[]int    `json:"genre_ids,omitempty"`
				ID               *int      `json:"id,omitempty"`
				Name             *string   `json:"name,omitempty"`
				OriginCountry    *[]string `json:"origin_country,omitempty"`
				OriginalLanguage *string   `json:"original_language,omitempty"`
				OriginalName     *string   `json:"original_name,omitempty"`
				Overview         *string   `json:"overview,omitempty"`
				Popularity       *float32  `json:"popularity,omitempty"`
				PosterPath       *string   `json:"poster_path,omitempty"`
				VoteAverage      *int      `json:"vote_average,omitempty"`
				VoteCount        *int      `json:"vote_count,omitempty"`
			} `json:"results,omitempty"`
			TotalPages   *int `json:"total_pages,omitempty"`
			TotalResults *int `json:"total_results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTvSeriesPopularListResponse parses an HTTP response from a TvSeriesPopularListWithResponse call
func ParseTvSeriesPopularListResponse(rsp *http.Response) (*TvSeriesPopularListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TvSeriesPopularListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Page    *int `json:"page,omitempty"`
			Results *[]struct {
				BackdropPath     *string   `json:"backdrop_path,omitempty"`
				FirstAirDate     *string   `json:"first_air_date,omitempty"`
				GenreIds         *[]int    `json:"genre_ids,omitempty"`
				ID               *int      `json:"id,omitempty"`
				Name             *string   `json:"name,omitempty"`
				OriginCountry    *[]string `json:"origin_country,omitempty"`
				OriginalLanguage *string   `json:"original_language,omitempty"`
				OriginalName     *string   `json:"original_name,omitempty"`
				Overview         *string   `json:"overview,omitempty"`
				Popularity       *float32  `json:"popularity,omitempty"`
				PosterPath       *string   `json:"poster_path,omitempty"`
				VoteAverage      *int      `json:"vote_average,omitempty"`
				VoteCount        *int      `json:"vote_count,omitempty"`
			} `json:"results,omitempty"`
			TotalPages   *int `json:"total_pages,omitempty"`
			TotalResults *int `json:"total_results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTvSeasonChangesByIDResponse parses an HTTP response from a TvSeasonChangesByIDWithResponse call
func ParseTvSeasonChangesByIDResponse(rsp *http.Response) (*TvSeasonChangesByIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TvSeasonChangesByIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Changes *[]struct {
				Items *[]struct {
					Action *string `json:"action,omitempty"`
					ID     *string `json:"id,omitempty"`
					Time   *string `json:"time,omitempty"`
					Value  *struct {
						EpisodeID     *int `json:"episode_id,omitempty"`
						EpisodeNumber *int `json:"episode_number,omitempty"`
					} `json:"value,omitempty"`
				} `json:"items,omitempty"`
				Key *string `json:"key,omitempty"`
			} `json:"changes,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTvSeriesTopRatedListResponse parses an HTTP response from a TvSeriesTopRatedListWithResponse call
func ParseTvSeriesTopRatedListResponse(rsp *http.Response) (*TvSeriesTopRatedListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TvSeriesTopRatedListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Page    *int `json:"page,omitempty"`
			Results *[]struct {
				BackdropPath     *string   `json:"backdrop_path,omitempty"`
				FirstAirDate     *string   `json:"first_air_date,omitempty"`
				GenreIds         *[]int    `json:"genre_ids,omitempty"`
				ID               *int      `json:"id,omitempty"`
				Name             *string   `json:"name,omitempty"`
				OriginCountry    *[]string `json:"origin_country,omitempty"`
				OriginalLanguage *string   `json:"original_language,omitempty"`
				OriginalName     *string   `json:"original_name,omitempty"`
				Overview         *string   `json:"overview,omitempty"`
				Popularity       *float32  `json:"popularity,omitempty"`
				PosterPath       *string   `json:"poster_path,omitempty"`
				VoteAverage      *float32  `json:"vote_average,omitempty"`
				VoteCount        *int      `json:"vote_count,omitempty"`
			} `json:"results,omitempty"`
			TotalPages   *int `json:"total_pages,omitempty"`
			TotalResults *int `json:"total_results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTvSeriesDetailsResponse parses an HTTP response from a TvSeriesDetailsWithResponse call
func ParseTvSeriesDetailsResponse(rsp *http.Response) (*TvSeriesDetailsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TvSeriesDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Adult        *bool   `json:"adult,omitempty"`
			BackdropPath *string `json:"backdrop_path,omitempty"`
			CreatedBy    *[]struct {
				CreditID    *string `json:"credit_id,omitempty"`
				Gender      *int    `json:"gender,omitempty"`
				ID          *int    `json:"id,omitempty"`
				Name        *string `json:"name,omitempty"`
				ProfilePath *string `json:"profile_path,omitempty"`
			} `json:"created_by,omitempty"`
			EpisodeRunTime *[]int  `json:"episode_run_time,omitempty"`
			FirstAirDate   *string `json:"first_air_date,omitempty"`
			Genres         *[]struct {
				ID   *int    `json:"id,omitempty"`
				Name *string `json:"name,omitempty"`
			} `json:"genres,omitempty"`
			Homepage         *string   `json:"homepage,omitempty"`
			ID               *int      `json:"id,omitempty"`
			InProduction     *bool     `json:"in_production,omitempty"`
			Languages        *[]string `json:"languages,omitempty"`
			LastAirDate      *string   `json:"last_air_date,omitempty"`
			LastEpisodeToAir *struct {
				AirDate        *string  `json:"air_date,omitempty"`
				EpisodeNumber  *int     `json:"episode_number,omitempty"`
				ID             *int     `json:"id,omitempty"`
				Name           *string  `json:"name,omitempty"`
				Overview       *string  `json:"overview,omitempty"`
				ProductionCode *string  `json:"production_code,omitempty"`
				Runtime        *int     `json:"runtime,omitempty"`
				SeasonNumber   *int     `json:"season_number,omitempty"`
				ShowID         *int     `json:"show_id,omitempty"`
				StillPath      *string  `json:"still_path,omitempty"`
				VoteAverage    *float32 `json:"vote_average,omitempty"`
				VoteCount      *int     `json:"vote_count,omitempty"`
			} `json:"last_episode_to_air,omitempty"`
			Name     *string `json:"name,omitempty"`
			Networks *[]struct {
				ID            *int    `json:"id,omitempty"`
				LogoPath      *string `json:"logo_path,omitempty"`
				Name          *string `json:"name,omitempty"`
				OriginCountry *string `json:"origin_country,omitempty"`
			} `json:"networks,omitempty"`
			NextEpisodeToAir    *interface{} `json:"next_episode_to_air,omitempty"`
			NumberOfEpisodes    *int         `json:"number_of_episodes,omitempty"`
			NumberOfSeasons     *int         `json:"number_of_seasons,omitempty"`
			OriginCountry       *[]string    `json:"origin_country,omitempty"`
			OriginalLanguage    *string      `json:"original_language,omitempty"`
			OriginalName        *string      `json:"original_name,omitempty"`
			Overview            *string      `json:"overview,omitempty"`
			Popularity          *float32     `json:"popularity,omitempty"`
			PosterPath          *string      `json:"poster_path,omitempty"`
			ProductionCompanies *[]struct {
				ID            *int    `json:"id,omitempty"`
				LogoPath      *string `json:"logo_path,omitempty"`
				Name          *string `json:"name,omitempty"`
				OriginCountry *string `json:"origin_country,omitempty"`
			} `json:"production_companies,omitempty"`
			ProductionCountries *[]struct {
				Iso31661 *string `json:"iso_3166_1,omitempty"`
				Name     *string `json:"name,omitempty"`
			} `json:"production_countries,omitempty"`
			Seasons *[]struct {
				AirDate      *string `json:"air_date,omitempty"`
				EpisodeCount *int    `json:"episode_count,omitempty"`
				ID           *int    `json:"id,omitempty"`
				Name         *string `json:"name,omitempty"`
				Overview     *string `json:"overview,omitempty"`
				PosterPath   *string `json:"poster_path,omitempty"`
				SeasonNumber *int    `json:"season_number,omitempty"`
				VoteAverage  *int    `json:"vote_average,omitempty"`
			} `json:"seasons,omitempty"`
			SpokenLanguages *[]struct {
				EnglishName *string `json:"english_name,omitempty"`
				Iso6391     *string `json:"iso_639_1,omitempty"`
				Name        *string `json:"name,omitempty"`
			} `json:"spoken_languages,omitempty"`
			Status      *string  `json:"status,omitempty"`
			Tagline     *string  `json:"tagline,omitempty"`
			Type        *string  `json:"type,omitempty"`
			VoteAverage *float32 `json:"vote_average,omitempty"`
			VoteCount   *int     `json:"vote_count,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTvSeriesAccountStatesResponse parses an HTTP response from a TvSeriesAccountStatesWithResponse call
func ParseTvSeriesAccountStatesResponse(rsp *http.Response) (*TvSeriesAccountStatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TvSeriesAccountStatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Favorite *bool `json:"favorite,omitempty"`
			ID       *int  `json:"id,omitempty"`
			Rated    *struct {
				Value *int `json:"value,omitempty"`
			} `json:"rated,omitempty"`
			Watchlist *bool `json:"watchlist,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTvSeriesAggregateCreditsResponse parses an HTTP response from a TvSeriesAggregateCreditsWithResponse call
func ParseTvSeriesAggregateCreditsResponse(rsp *http.Response) (*TvSeriesAggregateCreditsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TvSeriesAggregateCreditsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Cast *[]struct {
				Adult              *bool    `json:"adult,omitempty"`
				Gender             *int     `json:"gender,omitempty"`
				ID                 *int     `json:"id,omitempty"`
				KnownForDepartment *string  `json:"known_for_department,omitempty"`
				Name               *string  `json:"name,omitempty"`
				Order              *int     `json:"order,omitempty"`
				OriginalName       *string  `json:"original_name,omitempty"`
				Popularity         *float32 `json:"popularity,omitempty"`
				ProfilePath        *string  `json:"profile_path,omitempty"`
				Roles              *[]struct {
					Character    *string `json:"character,omitempty"`
					CreditID     *string `json:"credit_id,omitempty"`
					EpisodeCount *int    `json:"episode_count,omitempty"`
				} `json:"roles,omitempty"`
				TotalEpisodeCount *int `json:"total_episode_count,omitempty"`
			} `json:"cast,omitempty"`
			Crew *[]struct {
				Adult      *bool   `json:"adult,omitempty"`
				Department *string `json:"department,omitempty"`
				Gender     *int    `json:"gender,omitempty"`
				ID         *int    `json:"id,omitempty"`
				Jobs       *[]struct {
					CreditID     *string `json:"credit_id,omitempty"`
					EpisodeCount *int    `json:"episode_count,omitempty"`
					Job          *string `json:"job,omitempty"`
				} `json:"jobs,omitempty"`
				KnownForDepartment *string  `json:"known_for_department,omitempty"`
				Name               *string  `json:"name,omitempty"`
				OriginalName       *string  `json:"original_name,omitempty"`
				Popularity         *float32 `json:"popularity,omitempty"`
				ProfilePath        *string  `json:"profile_path,omitempty"`
				TotalEpisodeCount  *int     `json:"total_episode_count,omitempty"`
			} `json:"crew,omitempty"`
			ID *int `json:"id,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTvSeriesAlternativeTitlesResponse parses an HTTP response from a TvSeriesAlternativeTitlesWithResponse call
func ParseTvSeriesAlternativeTitlesResponse(rsp *http.Response) (*TvSeriesAlternativeTitlesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TvSeriesAlternativeTitlesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			ID      *int `json:"id,omitempty"`
			Results *[]struct {
				Iso31661 *string `json:"iso_3166_1,omitempty"`
				Title    *string `json:"title,omitempty"`
				Type     *string `json:"type,omitempty"`
			} `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTvSeriesChangesResponse parses an HTTP response from a TvSeriesChangesWithResponse call
func ParseTvSeriesChangesResponse(rsp *http.Response) (*TvSeriesChangesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TvSeriesChangesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Changes *[]struct {
				Items *[]struct {
					Action        *string `json:"action,omitempty"`
					ID            *string `json:"id,omitempty"`
					Iso31661      *string `json:"iso_3166_1,omitempty"`
					Iso6391       *string `json:"iso_639_1,omitempty"`
					OriginalValue *struct {
						Poster *struct {
							FilePath *string `json:"file_path,omitempty"`
							Iso6391  *string `json:"iso_639_1,omitempty"`
						} `json:"poster,omitempty"`
					} `json:"original_value,omitempty"`
					Time  *string `json:"time,omitempty"`
					Value *struct {
						Poster *struct {
							FilePath *string `json:"file_path,omitempty"`
							Iso6391  *string `json:"iso_639_1,omitempty"`
						} `json:"poster,omitempty"`
					} `json:"value,omitempty"`
				} `json:"items,omitempty"`
				Key *string `json:"key,omitempty"`
			} `json:"changes,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTvSeriesContentRatingsResponse parses an HTTP response from a TvSeriesContentRatingsWithResponse call
func ParseTvSeriesContentRatingsResponse(rsp *http.Response) (*TvSeriesContentRatingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TvSeriesContentRatingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			ID      *int `json:"id,omitempty"`
			Results *[]struct {
				Descriptors *[]interface{} `json:"descriptors,omitempty"`
				Iso31661    *string        `json:"iso_3166_1,omitempty"`
				Rating      *string        `json:"rating,omitempty"`
			} `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTvSeriesCreditsResponse parses an HTTP response from a TvSeriesCreditsWithResponse call
func ParseTvSeriesCreditsResponse(rsp *http.Response) (*TvSeriesCreditsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TvSeriesCreditsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Cast *[]struct {
				Adult              *bool    `json:"adult,omitempty"`
				Character          *string  `json:"character,omitempty"`
				CreditID           *string  `json:"credit_id,omitempty"`
				Gender             *int     `json:"gender,omitempty"`
				ID                 *int     `json:"id,omitempty"`
				KnownForDepartment *string  `json:"known_for_department,omitempty"`
				Name               *string  `json:"name,omitempty"`
				Order              *int     `json:"order,omitempty"`
				OriginalName       *string  `json:"original_name,omitempty"`
				Popularity         *float32 `json:"popularity,omitempty"`
				ProfilePath        *string  `json:"profile_path,omitempty"`
			} `json:"cast,omitempty"`
			Crew *[]struct {
				Adult              *bool    `json:"adult,omitempty"`
				CreditID           *string  `json:"credit_id,omitempty"`
				Department         *string  `json:"department,omitempty"`
				Gender             *int     `json:"gender,omitempty"`
				ID                 *int     `json:"id,omitempty"`
				Job                *string  `json:"job,omitempty"`
				KnownForDepartment *string  `json:"known_for_department,omitempty"`
				Name               *string  `json:"name,omitempty"`
				OriginalName       *string  `json:"original_name,omitempty"`
				Popularity         *float32 `json:"popularity,omitempty"`
				ProfilePath        *string  `json:"profile_path,omitempty"`
			} `json:"crew,omitempty"`
			ID *int `json:"id,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTvSeriesEpisodeGroupsResponse parses an HTTP response from a TvSeriesEpisodeGroupsWithResponse call
func ParseTvSeriesEpisodeGroupsResponse(rsp *http.Response) (*TvSeriesEpisodeGroupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TvSeriesEpisodeGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			ID      *int `json:"id,omitempty"`
			Results *[]struct {
				Description  *string `json:"description,omitempty"`
				EpisodeCount *int    `json:"episode_count,omitempty"`
				GroupCount   *int    `json:"group_count,omitempty"`
				ID           *string `json:"id,omitempty"`
				Name         *string `json:"name,omitempty"`
				Network      *struct {
					ID            *int    `json:"id,omitempty"`
					LogoPath      *string `json:"logo_path,omitempty"`
					Name          *string `json:"name,omitempty"`
					OriginCountry *string `json:"origin_country,omitempty"`
				} `json:"network,omitempty"`
				Type *int `json:"type,omitempty"`
			} `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTvSeriesExternalIdsResponse parses an HTTP response from a TvSeriesExternalIdsWithResponse call
func ParseTvSeriesExternalIdsResponse(rsp *http.Response) (*TvSeriesExternalIdsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TvSeriesExternalIdsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			FacebookID  *string `json:"facebook_id,omitempty"`
			FreebaseID  *string `json:"freebase_id,omitempty"`
			FreebaseMid *string `json:"freebase_mid,omitempty"`
			ID          *int    `json:"id,omitempty"`
			ImdbID      *string `json:"imdb_id,omitempty"`
			InstagramID *string `json:"instagram_id,omitempty"`
			TvdbID      *int    `json:"tvdb_id,omitempty"`
			TvrageID    *int    `json:"tvrage_id,omitempty"`
			TwitterID   *string `json:"twitter_id,omitempty"`
			WikidataID  *string `json:"wikidata_id,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTvSeriesImagesResponse parses an HTTP response from a TvSeriesImagesWithResponse call
func ParseTvSeriesImagesResponse(rsp *http.Response) (*TvSeriesImagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TvSeriesImagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Backdrops *[]struct {
				AspectRatio *float32     `json:"aspect_ratio,omitempty"`
				FilePath    *string      `json:"file_path,omitempty"`
				Height      *int         `json:"height,omitempty"`
				Iso6391     *interface{} `json:"iso_639_1,omitempty"`
				VoteAverage *float32     `json:"vote_average,omitempty"`
				VoteCount   *int         `json:"vote_count,omitempty"`
				Width       *int         `json:"width,omitempty"`
			} `json:"backdrops,omitempty"`
			ID    *int `json:"id,omitempty"`
			Logos *[]struct {
				AspectRatio *float32 `json:"aspect_ratio,omitempty"`
				FilePath    *string  `json:"file_path,omitempty"`
				Height      *int     `json:"height,omitempty"`
				Iso6391     *string  `json:"iso_639_1,omitempty"`
				VoteAverage *float32 `json:"vote_average,omitempty"`
				VoteCount   *int     `json:"vote_count,omitempty"`
				Width       *int     `json:"width,omitempty"`
			} `json:"logos,omitempty"`
			Posters *[]struct {
				AspectRatio *float32 `json:"aspect_ratio,omitempty"`
				FilePath    *string  `json:"file_path,omitempty"`
				Height      *int     `json:"height,omitempty"`
				Iso6391     *string  `json:"iso_639_1,omitempty"`
				VoteAverage *float32 `json:"vote_average,omitempty"`
				VoteCount   *int     `json:"vote_count,omitempty"`
				Width       *int     `json:"width,omitempty"`
			} `json:"posters,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTvSeriesKeywordsResponse parses an HTTP response from a TvSeriesKeywordsWithResponse call
func ParseTvSeriesKeywordsResponse(rsp *http.Response) (*TvSeriesKeywordsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TvSeriesKeywordsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			ID      *int `json:"id,omitempty"`
			Results *[]struct {
				ID   *int    `json:"id,omitempty"`
				Name *string `json:"name,omitempty"`
			} `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListsCopyResponse parses an HTTP response from a ListsCopyWithResponse call
func ParseListsCopyResponse(rsp *http.Response) (*ListsCopyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListsCopyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			ID      *int `json:"id,omitempty"`
			Page    *int `json:"page,omitempty"`
			Results *[]struct {
				Description   *string      `json:"description,omitempty"`
				FavoriteCount *int         `json:"favorite_count,omitempty"`
				ID            *int         `json:"id,omitempty"`
				Iso31661      *string      `json:"iso_3166_1,omitempty"`
				Iso6391       *string      `json:"iso_639_1,omitempty"`
				ItemCount     *int         `json:"item_count,omitempty"`
				Name          *string      `json:"name,omitempty"`
				PosterPath    *interface{} `json:"poster_path,omitempty"`
			} `json:"results,omitempty"`
			TotalPages   *int `json:"total_pages,omitempty"`
			TotalResults *int `json:"total_results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTvSeriesDeleteRatingResponse parses an HTTP response from a TvSeriesDeleteRatingWithResponse call
func ParseTvSeriesDeleteRatingResponse(rsp *http.Response) (*TvSeriesDeleteRatingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TvSeriesDeleteRatingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			StatusCode    *int    `json:"status_code,omitempty"`
			StatusMessage *string `json:"status_message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTvSeriesAddRatingResponse parses an HTTP response from a TvSeriesAddRatingWithResponse call
func ParseTvSeriesAddRatingResponse(rsp *http.Response) (*TvSeriesAddRatingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TvSeriesAddRatingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			StatusCode    *int    `json:"status_code,omitempty"`
			StatusMessage *string `json:"status_message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTvSeriesRecommendationsResponse parses an HTTP response from a TvSeriesRecommendationsWithResponse call
func ParseTvSeriesRecommendationsResponse(rsp *http.Response) (*TvSeriesRecommendationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TvSeriesRecommendationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Page    *int `json:"page,omitempty"`
			Results *[]struct {
				Adult            *bool     `json:"adult,omitempty"`
				BackdropPath     *string   `json:"backdrop_path,omitempty"`
				FirstAirDate     *string   `json:"first_air_date,omitempty"`
				GenreIds         *[]int    `json:"genre_ids,omitempty"`
				ID               *int      `json:"id,omitempty"`
				MediaType        *string   `json:"media_type,omitempty"`
				Name             *string   `json:"name,omitempty"`
				OriginCountry    *[]string `json:"origin_country,omitempty"`
				OriginalLanguage *string   `json:"original_language,omitempty"`
				OriginalName     *string   `json:"original_name,omitempty"`
				Overview         *string   `json:"overview,omitempty"`
				Popularity       *float32  `json:"popularity,omitempty"`
				PosterPath       *string   `json:"poster_path,omitempty"`
				VoteAverage      *float32  `json:"vote_average,omitempty"`
				VoteCount        *int      `json:"vote_count,omitempty"`
			} `json:"results,omitempty"`
			TotalPages   *int `json:"total_pages,omitempty"`
			TotalResults *int `json:"total_results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTvSeriesReviewsResponse parses an HTTP response from a TvSeriesReviewsWithResponse call
func ParseTvSeriesReviewsResponse(rsp *http.Response) (*TvSeriesReviewsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TvSeriesReviewsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			ID      *int `json:"id,omitempty"`
			Page    *int `json:"page,omitempty"`
			Results *[]struct {
				Author        *string `json:"author,omitempty"`
				AuthorDetails *struct {
					AvatarPath *string `json:"avatar_path,omitempty"`
					Name       *string `json:"name,omitempty"`
					Rating     *int    `json:"rating,omitempty"`
					Username   *string `json:"username,omitempty"`
				} `json:"author_details,omitempty"`
				Content   *string `json:"content,omitempty"`
				CreatedAt *string `json:"created_at,omitempty"`
				ID        *string `json:"id,omitempty"`
				UpdatedAt *string `json:"updated_at,omitempty"`
				URL       *string `json:"url,omitempty"`
			} `json:"results,omitempty"`
			TotalPages   *int `json:"total_pages,omitempty"`
			TotalResults *int `json:"total_results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTvSeriesScreenedTheatricallyResponse parses an HTTP response from a TvSeriesScreenedTheatricallyWithResponse call
func ParseTvSeriesScreenedTheatricallyResponse(rsp *http.Response) (*TvSeriesScreenedTheatricallyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TvSeriesScreenedTheatricallyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			ID      *int `json:"id,omitempty"`
			Results *[]struct {
				EpisodeNumber *int `json:"episode_number,omitempty"`
				ID            *int `json:"id,omitempty"`
				SeasonNumber  *int `json:"season_number,omitempty"`
			} `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTvSeasonDetailsResponse parses an HTTP response from a TvSeasonDetailsWithResponse call
func ParseTvSeasonDetailsResponse(rsp *http.Response) (*TvSeasonDetailsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TvSeasonDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Identifier *string `json:"_id,omitempty"`
			AirDate    *string `json:"air_date,omitempty"`
			Episodes   *[]struct {
				AirDate *string `json:"air_date,omitempty"`
				Crew    *[]struct {
					Adult              *bool    `json:"adult,omitempty"`
					CreditID           *string  `json:"credit_id,omitempty"`
					Department         *string  `json:"department,omitempty"`
					Gender             *int     `json:"gender,omitempty"`
					ID                 *int     `json:"id,omitempty"`
					Job                *string  `json:"job,omitempty"`
					KnownForDepartment *string  `json:"known_for_department,omitempty"`
					Name               *string  `json:"name,omitempty"`
					OriginalName       *string  `json:"original_name,omitempty"`
					Popularity         *float32 `json:"popularity,omitempty"`
					ProfilePath        *string  `json:"profile_path,omitempty"`
				} `json:"crew,omitempty"`
				EpisodeNumber *int `json:"episode_number,omitempty"`
				GuestStars    *[]struct {
					Adult              *bool    `json:"adult,omitempty"`
					Character          *string  `json:"character,omitempty"`
					CreditID           *string  `json:"credit_id,omitempty"`
					Gender             *int     `json:"gender,omitempty"`
					ID                 *int     `json:"id,omitempty"`
					KnownForDepartment *string  `json:"known_for_department,omitempty"`
					Name               *string  `json:"name,omitempty"`
					Order              *int     `json:"order,omitempty"`
					OriginalName       *string  `json:"original_name,omitempty"`
					Popularity         *float32 `json:"popularity,omitempty"`
					ProfilePath        *string  `json:"profile_path,omitempty"`
				} `json:"guest_stars,omitempty"`
				ID             *int     `json:"id,omitempty"`
				Name           *string  `json:"name,omitempty"`
				Overview       *string  `json:"overview,omitempty"`
				ProductionCode *string  `json:"production_code,omitempty"`
				Runtime        *int     `json:"runtime,omitempty"`
				SeasonNumber   *int     `json:"season_number,omitempty"`
				ShowID         *int     `json:"show_id,omitempty"`
				StillPath      *string  `json:"still_path,omitempty"`
				VoteAverage    *float32 `json:"vote_average,omitempty"`
				VoteCount      *int     `json:"vote_count,omitempty"`
			} `json:"episodes,omitempty"`
			ID           *int     `json:"id,omitempty"`
			Name         *string  `json:"name,omitempty"`
			Overview     *string  `json:"overview,omitempty"`
			PosterPath   *string  `json:"poster_path,omitempty"`
			SeasonNumber *int     `json:"season_number,omitempty"`
			VoteAverage  *float32 `json:"vote_average,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTvSeasonAccountStatesResponse parses an HTTP response from a TvSeasonAccountStatesWithResponse call
func ParseTvSeasonAccountStatesResponse(rsp *http.Response) (*TvSeasonAccountStatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TvSeasonAccountStatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			ID      *int `json:"id,omitempty"`
			Results *[]struct {
				EpisodeNumber *int `json:"episode_number,omitempty"`
				ID            *int `json:"id,omitempty"`
				Rated         *struct {
					Value *int `json:"value,omitempty"`
				} `json:"rated,omitempty"`
			} `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTvSeasonAggregateCreditsResponse parses an HTTP response from a TvSeasonAggregateCreditsWithResponse call
func ParseTvSeasonAggregateCreditsResponse(rsp *http.Response) (*TvSeasonAggregateCreditsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TvSeasonAggregateCreditsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Cast *[]struct {
				Adult              *bool    `json:"adult,omitempty"`
				Gender             *int     `json:"gender,omitempty"`
				ID                 *int     `json:"id,omitempty"`
				KnownForDepartment *string  `json:"known_for_department,omitempty"`
				Name               *string  `json:"name,omitempty"`
				Order              *int     `json:"order,omitempty"`
				OriginalName       *string  `json:"original_name,omitempty"`
				Popularity         *float32 `json:"popularity,omitempty"`
				ProfilePath        *string  `json:"profile_path,omitempty"`
				Roles              *[]struct {
					Character    *string `json:"character,omitempty"`
					CreditID     *string `json:"credit_id,omitempty"`
					EpisodeCount *int    `json:"episode_count,omitempty"`
				} `json:"roles,omitempty"`
				TotalEpisodeCount *int `json:"total_episode_count,omitempty"`
			} `json:"cast,omitempty"`
			Crew *[]struct {
				Adult      *bool   `json:"adult,omitempty"`
				Department *string `json:"department,omitempty"`
				Gender     *int    `json:"gender,omitempty"`
				ID         *int    `json:"id,omitempty"`
				Jobs       *[]struct {
					CreditID     *string `json:"credit_id,omitempty"`
					EpisodeCount *int    `json:"episode_count,omitempty"`
					Job          *string `json:"job,omitempty"`
				} `json:"jobs,omitempty"`
				KnownForDepartment *string      `json:"known_for_department,omitempty"`
				Name               *string      `json:"name,omitempty"`
				OriginalName       *string      `json:"original_name,omitempty"`
				Popularity         *float32     `json:"popularity,omitempty"`
				ProfilePath        *interface{} `json:"profile_path,omitempty"`
				TotalEpisodeCount  *int         `json:"total_episode_count,omitempty"`
			} `json:"crew,omitempty"`
			ID *int `json:"id,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTvSeasonCreditsResponse parses an HTTP response from a TvSeasonCreditsWithResponse call
func ParseTvSeasonCreditsResponse(rsp *http.Response) (*TvSeasonCreditsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TvSeasonCreditsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Cast *[]struct {
				Adult              *bool    `json:"adult,omitempty"`
				Character          *string  `json:"character,omitempty"`
				CreditID           *string  `json:"credit_id,omitempty"`
				Gender             *int     `json:"gender,omitempty"`
				ID                 *int     `json:"id,omitempty"`
				KnownForDepartment *string  `json:"known_for_department,omitempty"`
				Name               *string  `json:"name,omitempty"`
				Order              *int     `json:"order,omitempty"`
				OriginalName       *string  `json:"original_name,omitempty"`
				Popularity         *float32 `json:"popularity,omitempty"`
				ProfilePath        *string  `json:"profile_path,omitempty"`
			} `json:"cast,omitempty"`
			Crew *[]struct {
				Adult              *bool        `json:"adult,omitempty"`
				CreditID           *string      `json:"credit_id,omitempty"`
				Department         *string      `json:"department,omitempty"`
				Gender             *int         `json:"gender,omitempty"`
				ID                 *int         `json:"id,omitempty"`
				Job                *string      `json:"job,omitempty"`
				KnownForDepartment *string      `json:"known_for_department,omitempty"`
				Name               *string      `json:"name,omitempty"`
				OriginalName       *string      `json:"original_name,omitempty"`
				Popularity         *float32     `json:"popularity,omitempty"`
				ProfilePath        *interface{} `json:"profile_path,omitempty"`
			} `json:"crew,omitempty"`
			ID *int `json:"id,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTvEpisodeDetailsResponse parses an HTTP response from a TvEpisodeDetailsWithResponse call
func ParseTvEpisodeDetailsResponse(rsp *http.Response) (*TvEpisodeDetailsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TvEpisodeDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AirDate *string `json:"air_date,omitempty"`
			Crew    *[]struct {
				Adult              *bool    `json:"adult,omitempty"`
				CreditID           *string  `json:"credit_id,omitempty"`
				Department         *string  `json:"department,omitempty"`
				Gender             *int     `json:"gender,omitempty"`
				ID                 *int     `json:"id,omitempty"`
				Job                *string  `json:"job,omitempty"`
				KnownForDepartment *string  `json:"known_for_department,omitempty"`
				Name               *string  `json:"name,omitempty"`
				OriginalName       *string  `json:"original_name,omitempty"`
				Popularity         *float32 `json:"popularity,omitempty"`
				ProfilePath        *string  `json:"profile_path,omitempty"`
			} `json:"crew,omitempty"`
			EpisodeNumber *int `json:"episode_number,omitempty"`
			GuestStars    *[]struct {
				Adult              *bool    `json:"adult,omitempty"`
				Character          *string  `json:"character,omitempty"`
				CreditID           *string  `json:"credit_id,omitempty"`
				Gender             *int     `json:"gender,omitempty"`
				ID                 *int     `json:"id,omitempty"`
				KnownForDepartment *string  `json:"known_for_department,omitempty"`
				Name               *string  `json:"name,omitempty"`
				Order              *int     `json:"order,omitempty"`
				OriginalName       *string  `json:"original_name,omitempty"`
				Popularity         *float32 `json:"popularity,omitempty"`
				ProfilePath        *string  `json:"profile_path,omitempty"`
			} `json:"guest_stars,omitempty"`
			ID             *int     `json:"id,omitempty"`
			Name           *string  `json:"name,omitempty"`
			Overview       *string  `json:"overview,omitempty"`
			ProductionCode *string  `json:"production_code,omitempty"`
			Runtime        *int     `json:"runtime,omitempty"`
			SeasonNumber   *int     `json:"season_number,omitempty"`
			StillPath      *string  `json:"still_path,omitempty"`
			VoteAverage    *float32 `json:"vote_average,omitempty"`
			VoteCount      *int     `json:"vote_count,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTvEpisodeAccountStatesResponse parses an HTTP response from a TvEpisodeAccountStatesWithResponse call
func ParseTvEpisodeAccountStatesResponse(rsp *http.Response) (*TvEpisodeAccountStatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TvEpisodeAccountStatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Favorite *bool `json:"favorite,omitempty"`
			ID       *int  `json:"id,omitempty"`
			Rated    *struct {
				Value *int `json:"value,omitempty"`
			} `json:"rated,omitempty"`
			Watchlist *bool `json:"watchlist,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTvEpisodeCreditsResponse parses an HTTP response from a TvEpisodeCreditsWithResponse call
func ParseTvEpisodeCreditsResponse(rsp *http.Response) (*TvEpisodeCreditsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TvEpisodeCreditsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Cast *[]struct {
				Adult              *bool    `json:"adult,omitempty"`
				Character          *string  `json:"character,omitempty"`
				CreditID           *string  `json:"credit_id,omitempty"`
				Gender             *int     `json:"gender,omitempty"`
				ID                 *int     `json:"id,omitempty"`
				KnownForDepartment *string  `json:"known_for_department,omitempty"`
				Name               *string  `json:"name,omitempty"`
				Order              *int     `json:"order,omitempty"`
				OriginalName       *string  `json:"original_name,omitempty"`
				Popularity         *float32 `json:"popularity,omitempty"`
				ProfilePath        *string  `json:"profile_path,omitempty"`
			} `json:"cast,omitempty"`
			Crew *[]struct {
				Adult              *bool    `json:"adult,omitempty"`
				CreditID           *string  `json:"credit_id,omitempty"`
				Department         *string  `json:"department,omitempty"`
				Gender             *int     `json:"gender,omitempty"`
				ID                 *int     `json:"id,omitempty"`
				Job                *string  `json:"job,omitempty"`
				KnownForDepartment *string  `json:"known_for_department,omitempty"`
				Name               *string  `json:"name,omitempty"`
				OriginalName       *string  `json:"original_name,omitempty"`
				Popularity         *float32 `json:"popularity,omitempty"`
				ProfilePath        *string  `json:"profile_path,omitempty"`
			} `json:"crew,omitempty"`
			GuestStars *[]struct {
				Adult              *bool    `json:"adult,omitempty"`
				Character          *string  `json:"character,omitempty"`
				CreditID           *string  `json:"credit_id,omitempty"`
				Gender             *int     `json:"gender,omitempty"`
				ID                 *int     `json:"id,omitempty"`
				KnownForDepartment *string  `json:"known_for_department,omitempty"`
				Name               *string  `json:"name,omitempty"`
				Order              *int     `json:"order,omitempty"`
				OriginalName       *string  `json:"original_name,omitempty"`
				Popularity         *float32 `json:"popularity,omitempty"`
				ProfilePath        *string  `json:"profile_path,omitempty"`
			} `json:"guest_stars,omitempty"`
			ID *int `json:"id,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTvEpisodeExternalIdsResponse parses an HTTP response from a TvEpisodeExternalIdsWithResponse call
func ParseTvEpisodeExternalIdsResponse(rsp *http.Response) (*TvEpisodeExternalIdsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TvEpisodeExternalIdsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			FreebaseID  *string `json:"freebase_id,omitempty"`
			FreebaseMid *string `json:"freebase_mid,omitempty"`
			ID          *int    `json:"id,omitempty"`
			ImdbID      *string `json:"imdb_id,omitempty"`
			TvdbID      *int    `json:"tvdb_id,omitempty"`
			TvrageID    *int    `json:"tvrage_id,omitempty"`
			WikidataID  *string `json:"wikidata_id,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTvEpisodeImagesResponse parses an HTTP response from a TvEpisodeImagesWithResponse call
func ParseTvEpisodeImagesResponse(rsp *http.Response) (*TvEpisodeImagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TvEpisodeImagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			ID     *int `json:"id,omitempty"`
			Stills *[]struct {
				AspectRatio *float32     `json:"aspect_ratio,omitempty"`
				FilePath    *string      `json:"file_path,omitempty"`
				Height      *int         `json:"height,omitempty"`
				Iso6391     *interface{} `json:"iso_639_1,omitempty"`
				VoteAverage *float32     `json:"vote_average,omitempty"`
				VoteCount   *int         `json:"vote_count,omitempty"`
				Width       *int         `json:"width,omitempty"`
			} `json:"stills,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTvEpisodeDeleteRatingResponse parses an HTTP response from a TvEpisodeDeleteRatingWithResponse call
func ParseTvEpisodeDeleteRatingResponse(rsp *http.Response) (*TvEpisodeDeleteRatingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TvEpisodeDeleteRatingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			StatusCode    *int    `json:"status_code,omitempty"`
			StatusMessage *string `json:"status_message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTvEpisodeAddRatingResponse parses an HTTP response from a TvEpisodeAddRatingWithResponse call
func ParseTvEpisodeAddRatingResponse(rsp *http.Response) (*TvEpisodeAddRatingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TvEpisodeAddRatingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			StatusCode    *int    `json:"status_code,omitempty"`
			StatusMessage *string `json:"status_message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTvEpisodeTranslationsResponse parses an HTTP response from a TvEpisodeTranslationsWithResponse call
func ParseTvEpisodeTranslationsResponse(rsp *http.Response) (*TvEpisodeTranslationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TvEpisodeTranslationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			ID           *int `json:"id,omitempty"`
			Translations *[]struct {
				Data *struct {
					Name     *string `json:"name,omitempty"`
					Overview *string `json:"overview,omitempty"`
				} `json:"data,omitempty"`
				EnglishName *string `json:"english_name,omitempty"`
				Iso31661    *string `json:"iso_3166_1,omitempty"`
				Iso6391     *string `json:"iso_639_1,omitempty"`
				Name        *string `json:"name,omitempty"`
			} `json:"translations,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTvEpisodeVideosResponse parses an HTTP response from a TvEpisodeVideosWithResponse call
func ParseTvEpisodeVideosResponse(rsp *http.Response) (*TvEpisodeVideosResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TvEpisodeVideosResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			ID      *int `json:"id,omitempty"`
			Results *[]struct {
				ID          *string `json:"id,omitempty"`
				Iso31661    *string `json:"iso_3166_1,omitempty"`
				Iso6391     *string `json:"iso_639_1,omitempty"`
				Key         *string `json:"key,omitempty"`
				Name        *string `json:"name,omitempty"`
				Official    *bool   `json:"official,omitempty"`
				PublishedAt *string `json:"published_at,omitempty"`
				Site        *string `json:"site,omitempty"`
				Size        *int    `json:"size,omitempty"`
				Type        *string `json:"type,omitempty"`
			} `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTvSeasonExternalIdsResponse parses an HTTP response from a TvSeasonExternalIdsWithResponse call
func ParseTvSeasonExternalIdsResponse(rsp *http.Response) (*TvSeasonExternalIdsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TvSeasonExternalIdsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			FreebaseID  *string      `json:"freebase_id,omitempty"`
			FreebaseMid *string      `json:"freebase_mid,omitempty"`
			ID          *int         `json:"id,omitempty"`
			TvdbID      *int         `json:"tvdb_id,omitempty"`
			TvrageID    *interface{} `json:"tvrage_id,omitempty"`
			WikidataID  *string      `json:"wikidata_id,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTvSeasonImagesResponse parses an HTTP response from a TvSeasonImagesWithResponse call
func ParseTvSeasonImagesResponse(rsp *http.Response) (*TvSeasonImagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TvSeasonImagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			ID      *int `json:"id,omitempty"`
			Posters *[]struct {
				AspectRatio *float32 `json:"aspect_ratio,omitempty"`
				FilePath    *string  `json:"file_path,omitempty"`
				Height      *int     `json:"height,omitempty"`
				Iso6391     *string  `json:"iso_639_1,omitempty"`
				VoteAverage *float32 `json:"vote_average,omitempty"`
				VoteCount   *int     `json:"vote_count,omitempty"`
				Width       *int     `json:"width,omitempty"`
			} `json:"posters,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTvSeasonTranslationsResponse parses an HTTP response from a TvSeasonTranslationsWithResponse call
func ParseTvSeasonTranslationsResponse(rsp *http.Response) (*TvSeasonTranslationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TvSeasonTranslationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			ID           *int `json:"id,omitempty"`
			Translations *[]struct {
				Data *struct {
					Name     *string `json:"name,omitempty"`
					Overview *string `json:"overview,omitempty"`
				} `json:"data,omitempty"`
				EnglishName *string `json:"english_name,omitempty"`
				Iso31661    *string `json:"iso_3166_1,omitempty"`
				Iso6391     *string `json:"iso_639_1,omitempty"`
				Name        *string `json:"name,omitempty"`
			} `json:"translations,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTvSeasonVideosResponse parses an HTTP response from a TvSeasonVideosWithResponse call
func ParseTvSeasonVideosResponse(rsp *http.Response) (*TvSeasonVideosResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TvSeasonVideosResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			ID      *int `json:"id,omitempty"`
			Results *[]struct {
				ID          *string `json:"id,omitempty"`
				Iso31661    *string `json:"iso_3166_1,omitempty"`
				Iso6391     *string `json:"iso_639_1,omitempty"`
				Key         *string `json:"key,omitempty"`
				Name        *string `json:"name,omitempty"`
				Official    *bool   `json:"official,omitempty"`
				PublishedAt *string `json:"published_at,omitempty"`
				Site        *string `json:"site,omitempty"`
				Size        *int    `json:"size,omitempty"`
				Type        *string `json:"type,omitempty"`
			} `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTvSeasonWatchProvidersResponse parses an HTTP response from a TvSeasonWatchProvidersWithResponse call
func ParseTvSeasonWatchProvidersResponse(rsp *http.Response) (*TvSeasonWatchProvidersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TvSeasonWatchProvidersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			ID      *int `json:"id,omitempty"`
			Results *struct {
				AE *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"AE,omitempty"`
				AR *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"AR,omitempty"`
				AT *struct {
					Buy *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"buy,omitempty"`
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"AT,omitempty"`
				AU *struct {
					Buy *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"buy,omitempty"`
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"AU,omitempty"`
				BA *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"BA,omitempty"`
				BB *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"BB,omitempty"`
				BE *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"BE,omitempty"`
				BG *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"BG,omitempty"`
				BO *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"BO,omitempty"`
				BR *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"BR,omitempty"`
				BS *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"BS,omitempty"`
				CA *struct {
					Buy *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"buy,omitempty"`
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"CA,omitempty"`
				CH *struct {
					Buy *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"buy,omitempty"`
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"CH,omitempty"`
				CI *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"CI,omitempty"`
				CL *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"CL,omitempty"`
				CO *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"CO,omitempty"`
				CR *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"CR,omitempty"`
				CZ *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"CZ,omitempty"`
				DE *struct {
					Buy *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"buy,omitempty"`
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"DE,omitempty"`
				DK *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"DK,omitempty"`
				DO *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"DO,omitempty"`
				DZ *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"DZ,omitempty"`
				EC *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"EC,omitempty"`
				EG *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"EG,omitempty"`
				ES *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"ES,omitempty"`
				FI *struct {
					Buy *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"buy,omitempty"`
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"FI,omitempty"`
				FR *struct {
					Buy *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"buy,omitempty"`
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"FR,omitempty"`
				GB *struct {
					Buy *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"buy,omitempty"`
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"GB,omitempty"`
				GF *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"GF,omitempty"`
				GH *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"GH,omitempty"`
				GQ *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"GQ,omitempty"`
				GT *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"GT,omitempty"`
				HK *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"HK,omitempty"`
				HN *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"HN,omitempty"`
				HR *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"HR,omitempty"`
				HU *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"HU,omitempty"`
				ID *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"ID,omitempty"`
				IE *struct {
					Buy *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"buy,omitempty"`
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"IE,omitempty"`
				IL *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"IL,omitempty"`
				IQ *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"IQ,omitempty"`
				IT *struct {
					Buy *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"buy,omitempty"`
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"IT,omitempty"`
				JM *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"JM,omitempty"`
				JP *struct {
					Buy *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"buy,omitempty"`
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
					Rent *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"rent,omitempty"`
				} `json:"JP,omitempty"`
				KE *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"KE,omitempty"`
				KR *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"KR,omitempty"`
				LB *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"LB,omitempty"`
				LY *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"LY,omitempty"`
				MD *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"MD,omitempty"`
				MK *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"MK,omitempty"`
				MU *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"MU,omitempty"`
				MX *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"MX,omitempty"`
				MY *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"MY,omitempty"`
				MZ *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"MZ,omitempty"`
				NE *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"NE,omitempty"`
				NG *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"NG,omitempty"`
				NL *struct {
					Buy *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"buy,omitempty"`
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"NL,omitempty"`
				NO *struct {
					Buy *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"buy,omitempty"`
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"NO,omitempty"`
				NZ *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"NZ,omitempty"`
				PA *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"PA,omitempty"`
				PE *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"PE,omitempty"`
				PH *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"PH,omitempty"`
				PL *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
					Rent *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"rent,omitempty"`
				} `json:"PL,omitempty"`
				PS *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"PS,omitempty"`
				PT *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"PT,omitempty"`
				PY *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"PY,omitempty"`
				RO *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"RO,omitempty"`
				RS *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"RS,omitempty"`
				RU *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"RU,omitempty"`
				SA *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"SA,omitempty"`
				SC *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"SC,omitempty"`
				SE *struct {
					Buy *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"buy,omitempty"`
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"SE,omitempty"`
				SG *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"SG,omitempty"`
				SI *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"SI,omitempty"`
				SK *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"SK,omitempty"`
				SN *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"SN,omitempty"`
				SV *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"SV,omitempty"`
				TH *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"TH,omitempty"`
				TR *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"TR,omitempty"`
				TT *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"TT,omitempty"`
				TW *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"TW,omitempty"`
				TZ *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"TZ,omitempty"`
				UG *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"UG,omitempty"`
				US *struct {
					Buy *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"buy,omitempty"`
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Free *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"free,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"US,omitempty"`
				UY *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"UY,omitempty"`
				VE *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"VE,omitempty"`
				ZA *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"ZA,omitempty"`
				ZM *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"ZM,omitempty"`
			} `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTvSeriesSimilarResponse parses an HTTP response from a TvSeriesSimilarWithResponse call
func ParseTvSeriesSimilarResponse(rsp *http.Response) (*TvSeriesSimilarResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TvSeriesSimilarResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Page    *int `json:"page,omitempty"`
			Results *[]struct {
				Adult            *bool     `json:"adult,omitempty"`
				BackdropPath     *string   `json:"backdrop_path,omitempty"`
				FirstAirDate     *string   `json:"first_air_date,omitempty"`
				GenreIds         *[]int    `json:"genre_ids,omitempty"`
				ID               *int      `json:"id,omitempty"`
				Name             *string   `json:"name,omitempty"`
				OriginCountry    *[]string `json:"origin_country,omitempty"`
				OriginalLanguage *string   `json:"original_language,omitempty"`
				OriginalName     *string   `json:"original_name,omitempty"`
				Overview         *string   `json:"overview,omitempty"`
				Popularity       *float32  `json:"popularity,omitempty"`
				PosterPath       *string   `json:"poster_path,omitempty"`
				VoteAverage      *int      `json:"vote_average,omitempty"`
				VoteCount        *int      `json:"vote_count,omitempty"`
			} `json:"results,omitempty"`
			TotalPages   *int `json:"total_pages,omitempty"`
			TotalResults *int `json:"total_results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTvSeriesTranslationsResponse parses an HTTP response from a TvSeriesTranslationsWithResponse call
func ParseTvSeriesTranslationsResponse(rsp *http.Response) (*TvSeriesTranslationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TvSeriesTranslationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			ID           *int `json:"id,omitempty"`
			Translations *[]struct {
				Data *struct {
					Homepage *string `json:"homepage,omitempty"`
					Name     *string `json:"name,omitempty"`
					Overview *string `json:"overview,omitempty"`
					Tagline  *string `json:"tagline,omitempty"`
				} `json:"data,omitempty"`
				EnglishName *string `json:"english_name,omitempty"`
				Iso31661    *string `json:"iso_3166_1,omitempty"`
				Iso6391     *string `json:"iso_639_1,omitempty"`
				Name        *string `json:"name,omitempty"`
			} `json:"translations,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTvSeriesVideosResponse parses an HTTP response from a TvSeriesVideosWithResponse call
func ParseTvSeriesVideosResponse(rsp *http.Response) (*TvSeriesVideosResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TvSeriesVideosResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			ID      *int `json:"id,omitempty"`
			Results *[]struct {
				ID          *string `json:"id,omitempty"`
				Iso31661    *string `json:"iso_3166_1,omitempty"`
				Iso6391     *string `json:"iso_639_1,omitempty"`
				Key         *string `json:"key,omitempty"`
				Name        *string `json:"name,omitempty"`
				Official    *bool   `json:"official,omitempty"`
				PublishedAt *string `json:"published_at,omitempty"`
				Site        *string `json:"site,omitempty"`
				Size        *int    `json:"size,omitempty"`
				Type        *string `json:"type,omitempty"`
			} `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTvSeriesWatchProvidersResponse parses an HTTP response from a TvSeriesWatchProvidersWithResponse call
func ParseTvSeriesWatchProvidersResponse(rsp *http.Response) (*TvSeriesWatchProvidersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TvSeriesWatchProvidersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			ID      *int `json:"id,omitempty"`
			Results *struct {
				AE *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"AE,omitempty"`
				AR *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"AR,omitempty"`
				AT *struct {
					Buy *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"buy,omitempty"`
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"AT,omitempty"`
				AU *struct {
					Buy *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"buy,omitempty"`
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"AU,omitempty"`
				BA *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"BA,omitempty"`
				BB *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"BB,omitempty"`
				BE *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"BE,omitempty"`
				BG *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"BG,omitempty"`
				BO *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"BO,omitempty"`
				BR *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"BR,omitempty"`
				BS *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"BS,omitempty"`
				CA *struct {
					Buy *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"buy,omitempty"`
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"CA,omitempty"`
				CH *struct {
					Buy *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"buy,omitempty"`
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"CH,omitempty"`
				CI *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"CI,omitempty"`
				CL *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"CL,omitempty"`
				CO *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"CO,omitempty"`
				CR *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"CR,omitempty"`
				CZ *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"CZ,omitempty"`
				DE *struct {
					Buy *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"buy,omitempty"`
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"DE,omitempty"`
				DK *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"DK,omitempty"`
				DO *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"DO,omitempty"`
				DZ *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"DZ,omitempty"`
				EC *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"EC,omitempty"`
				EG *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"EG,omitempty"`
				ES *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"ES,omitempty"`
				FI *struct {
					Buy *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"buy,omitempty"`
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"FI,omitempty"`
				FR *struct {
					Buy *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"buy,omitempty"`
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"FR,omitempty"`
				GB *struct {
					Buy *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"buy,omitempty"`
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"GB,omitempty"`
				GF *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"GF,omitempty"`
				GH *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"GH,omitempty"`
				GQ *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"GQ,omitempty"`
				GT *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"GT,omitempty"`
				HK *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"HK,omitempty"`
				HN *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"HN,omitempty"`
				HR *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"HR,omitempty"`
				HU *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"HU,omitempty"`
				ID *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"ID,omitempty"`
				IE *struct {
					Buy *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"buy,omitempty"`
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"IE,omitempty"`
				IL *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"IL,omitempty"`
				IQ *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"IQ,omitempty"`
				IT *struct {
					Buy *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"buy,omitempty"`
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"IT,omitempty"`
				JM *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"JM,omitempty"`
				JP *struct {
					Buy *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"buy,omitempty"`
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
					Rent *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"rent,omitempty"`
				} `json:"JP,omitempty"`
				KE *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"KE,omitempty"`
				KR *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"KR,omitempty"`
				LB *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"LB,omitempty"`
				LT *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"LT,omitempty"`
				LY *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"LY,omitempty"`
				MD *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"MD,omitempty"`
				MK *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"MK,omitempty"`
				MU *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"MU,omitempty"`
				MX *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"MX,omitempty"`
				MY *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"MY,omitempty"`
				MZ *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"MZ,omitempty"`
				NE *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"NE,omitempty"`
				NG *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"NG,omitempty"`
				NL *struct {
					Buy *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"buy,omitempty"`
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"NL,omitempty"`
				NO *struct {
					Buy *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"buy,omitempty"`
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"NO,omitempty"`
				NZ *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"NZ,omitempty"`
				PA *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"PA,omitempty"`
				PE *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"PE,omitempty"`
				PH *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"PH,omitempty"`
				PL *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
					Rent *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"rent,omitempty"`
				} `json:"PL,omitempty"`
				PS *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"PS,omitempty"`
				PT *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"PT,omitempty"`
				PY *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"PY,omitempty"`
				RO *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"RO,omitempty"`
				RS *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"RS,omitempty"`
				RU *struct {
					Ads *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"ads,omitempty"`
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"RU,omitempty"`
				SA *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"SA,omitempty"`
				SC *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"SC,omitempty"`
				SE *struct {
					Buy *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"buy,omitempty"`
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"SE,omitempty"`
				SG *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"SG,omitempty"`
				SI *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"SI,omitempty"`
				SK *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"SK,omitempty"`
				SN *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"SN,omitempty"`
				SV *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"SV,omitempty"`
				TH *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"TH,omitempty"`
				TR *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"TR,omitempty"`
				TT *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"TT,omitempty"`
				TW *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"TW,omitempty"`
				TZ *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"TZ,omitempty"`
				UG *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"UG,omitempty"`
				US *struct {
					Buy *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"buy,omitempty"`
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Free *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"free,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"US,omitempty"`
				UY *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"UY,omitempty"`
				VE *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"VE,omitempty"`
				ZA *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"ZA,omitempty"`
				ZM *struct {
					Flatrate *[]struct {
						DisplayPriority *int    `json:"display_priority,omitempty"`
						LogoPath        *string `json:"logo_path,omitempty"`
						ProviderID      *int    `json:"provider_id,omitempty"`
						ProviderName    *string `json:"provider_name,omitempty"`
					} `json:"flatrate,omitempty"`
					Link *string `json:"link,omitempty"`
				} `json:"ZM,omitempty"`
			} `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseWatchProvidersMovieListResponse parses an HTTP response from a WatchProvidersMovieListWithResponse call
func ParseWatchProvidersMovieListResponse(rsp *http.Response) (*WatchProvidersMovieListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WatchProvidersMovieListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Results *[]struct {
				DisplayPriorities *struct {
					AE *int `json:"AE,omitempty"`
					AR *int `json:"AR,omitempty"`
					AT *int `json:"AT,omitempty"`
					AU *int `json:"AU,omitempty"`
					BE *int `json:"BE,omitempty"`
					BG *int `json:"BG,omitempty"`
					BO *int `json:"BO,omitempty"`
					BR *int `json:"BR,omitempty"`
					CA *int `json:"CA,omitempty"`
					CH *int `json:"CH,omitempty"`
					CL *int `json:"CL,omitempty"`
					CO *int `json:"CO,omitempty"`
					CR *int `json:"CR,omitempty"`
					CV *int `json:"CV,omitempty"`
					CZ *int `json:"CZ,omitempty"`
					DE *int `json:"DE,omitempty"`
					DK *int `json:"DK,omitempty"`
					EC *int `json:"EC,omitempty"`
					EE *int `json:"EE,omitempty"`
					EG *int `json:"EG,omitempty"`
					ES *int `json:"ES,omitempty"`
					FI *int `json:"FI,omitempty"`
					FR *int `json:"FR,omitempty"`
					GB *int `json:"GB,omitempty"`
					GH *int `json:"GH,omitempty"`
					GR *int `json:"GR,omitempty"`
					GT *int `json:"GT,omitempty"`
					HK *int `json:"HK,omitempty"`
					HN *int `json:"HN,omitempty"`
					HU *int `json:"HU,omitempty"`
					ID *int `json:"ID,omitempty"`
					IE *int `json:"IE,omitempty"`
					IL *int `json:"IL,omitempty"`
					IN *int `json:"IN,omitempty"`
					IT *int `json:"IT,omitempty"`
					JP *int `json:"JP,omitempty"`
					LT *int `json:"LT,omitempty"`
					LV *int `json:"LV,omitempty"`
					MU *int `json:"MU,omitempty"`
					MX *int `json:"MX,omitempty"`
					MY *int `json:"MY,omitempty"`
					MZ *int `json:"MZ,omitempty"`
					NL *int `json:"NL,omitempty"`
					NO *int `json:"NO,omitempty"`
					NZ *int `json:"NZ,omitempty"`
					PE *int `json:"PE,omitempty"`
					PH *int `json:"PH,omitempty"`
					PL *int `json:"PL,omitempty"`
					PT *int `json:"PT,omitempty"`
					PY *int `json:"PY,omitempty"`
					RU *int `json:"RU,omitempty"`
					SA *int `json:"SA,omitempty"`
					SE *int `json:"SE,omitempty"`
					SG *int `json:"SG,omitempty"`
					SI *int `json:"SI,omitempty"`
					SK *int `json:"SK,omitempty"`
					TH *int `json:"TH,omitempty"`
					TR *int `json:"TR,omitempty"`
					TW *int `json:"TW,omitempty"`
					UG *int `json:"UG,omitempty"`
					US *int `json:"US,omitempty"`
					VE *int `json:"VE,omitempty"`
					ZA *int `json:"ZA,omitempty"`
				} `json:"display_priorities,omitempty"`
				DisplayPriority *int    `json:"display_priority,omitempty"`
				LogoPath        *string `json:"logo_path,omitempty"`
				ProviderID      *int    `json:"provider_id,omitempty"`
				ProviderName    *string `json:"provider_name,omitempty"`
			} `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseWatchProvidersAvailableRegionsResponse parses an HTTP response from a WatchProvidersAvailableRegionsWithResponse call
func ParseWatchProvidersAvailableRegionsResponse(rsp *http.Response) (*WatchProvidersAvailableRegionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WatchProvidersAvailableRegionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Results *[]struct {
				EnglishName *string `json:"english_name,omitempty"`
				Iso31661    *string `json:"iso_3166_1,omitempty"`
				NativeName  *string `json:"native_name,omitempty"`
			} `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseWatchProviderTvListResponse parses an HTTP response from a WatchProviderTvListWithResponse call
func ParseWatchProviderTvListResponse(rsp *http.Response) (*WatchProviderTvListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WatchProviderTvListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Results *[]struct {
				DisplayPriorities *struct {
					AE *int `json:"AE,omitempty"`
					AR *int `json:"AR,omitempty"`
					AT *int `json:"AT,omitempty"`
					AU *int `json:"AU,omitempty"`
					BE *int `json:"BE,omitempty"`
					BG *int `json:"BG,omitempty"`
					BO *int `json:"BO,omitempty"`
					BR *int `json:"BR,omitempty"`
					CA *int `json:"CA,omitempty"`
					CH *int `json:"CH,omitempty"`
					CL *int `json:"CL,omitempty"`
					CO *int `json:"CO,omitempty"`
					CR *int `json:"CR,omitempty"`
					CV *int `json:"CV,omitempty"`
					CZ *int `json:"CZ,omitempty"`
					DE *int `json:"DE,omitempty"`
					DK *int `json:"DK,omitempty"`
					EC *int `json:"EC,omitempty"`
					EE *int `json:"EE,omitempty"`
					EG *int `json:"EG,omitempty"`
					ES *int `json:"ES,omitempty"`
					FI *int `json:"FI,omitempty"`
					FR *int `json:"FR,omitempty"`
					GB *int `json:"GB,omitempty"`
					GH *int `json:"GH,omitempty"`
					GR *int `json:"GR,omitempty"`
					GT *int `json:"GT,omitempty"`
					HK *int `json:"HK,omitempty"`
					HN *int `json:"HN,omitempty"`
					HU *int `json:"HU,omitempty"`
					ID *int `json:"ID,omitempty"`
					IE *int `json:"IE,omitempty"`
					IL *int `json:"IL,omitempty"`
					IN *int `json:"IN,omitempty"`
					IT *int `json:"IT,omitempty"`
					JP *int `json:"JP,omitempty"`
					LT *int `json:"LT,omitempty"`
					LV *int `json:"LV,omitempty"`
					MU *int `json:"MU,omitempty"`
					MX *int `json:"MX,omitempty"`
					MY *int `json:"MY,omitempty"`
					MZ *int `json:"MZ,omitempty"`
					NL *int `json:"NL,omitempty"`
					NO *int `json:"NO,omitempty"`
					NZ *int `json:"NZ,omitempty"`
					PE *int `json:"PE,omitempty"`
					PH *int `json:"PH,omitempty"`
					PL *int `json:"PL,omitempty"`
					PT *int `json:"PT,omitempty"`
					PY *int `json:"PY,omitempty"`
					RU *int `json:"RU,omitempty"`
					SA *int `json:"SA,omitempty"`
					SE *int `json:"SE,omitempty"`
					SG *int `json:"SG,omitempty"`
					SI *int `json:"SI,omitempty"`
					SK *int `json:"SK,omitempty"`
					TH *int `json:"TH,omitempty"`
					TR *int `json:"TR,omitempty"`
					TW *int `json:"TW,omitempty"`
					UG *int `json:"UG,omitempty"`
					US *int `json:"US,omitempty"`
					VE *int `json:"VE,omitempty"`
					ZA *int `json:"ZA,omitempty"`
				} `json:"display_priorities,omitempty"`
				DisplayPriority *int    `json:"display_priority,omitempty"`
				LogoPath        *string `json:"logo_path,omitempty"`
				ProviderID      *int    `json:"provider_id,omitempty"`
				ProviderName    *string `json:"provider_name,omitempty"`
			} `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}
